
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">distributed-kvstore/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">distributed-kvstore/cmd/kvtool/main.go (0.0%)</option>
				
				<option value="file2">distributed-kvstore/cmd/server/main.go (0.0%)</option>
				
				<option value="file3">distributed-kvstore/examples/correlation_demo/main.go (0.0%)</option>
				
				<option value="file4">distributed-kvstore/examples/logging_demo/main.go (0.0%)</option>
				
				<option value="file5">distributed-kvstore/examples/monitoring_demo/main.go (0.0%)</option>
				
				<option value="file6">distributed-kvstore/internal/api/rest.go (66.7%)</option>
				
				<option value="file7">distributed-kvstore/internal/api/router.go (78.1%)</option>
				
				<option value="file8">distributed-kvstore/internal/config/config.go (61.5%)</option>
				
				<option value="file9">distributed-kvstore/internal/logging/config.go (33.3%)</option>
				
				<option value="file10">distributed-kvstore/internal/logging/correlation.go (34.8%)</option>
				
				<option value="file11">distributed-kvstore/internal/logging/logger.go (73.4%)</option>
				
				<option value="file12">distributed-kvstore/internal/monitoring/dashboard.go (90.6%)</option>
				
				<option value="file13">distributed-kvstore/internal/monitoring/health.go (87.3%)</option>
				
				<option value="file14">distributed-kvstore/internal/monitoring/integration.go (97.5%)</option>
				
				<option value="file15">distributed-kvstore/internal/monitoring/metrics.go (96.9%)</option>
				
				<option value="file16">distributed-kvstore/internal/monitoring/prometheus.go (64.4%)</option>
				
				<option value="file17">distributed-kvstore/internal/server/grpc_server.go (42.9%)</option>
				
				<option value="file18">distributed-kvstore/internal/server/grpc_simple.go (0.0%)</option>
				
				<option value="file19">distributed-kvstore/internal/server/http.go (0.0%)</option>
				
				<option value="file20">distributed-kvstore/internal/server/server.go (0.0%)</option>
				
				<option value="file21">distributed-kvstore/internal/storage/engine.go (76.3%)</option>
				
				<option value="file22">distributed-kvstore/internal/testutil/testutil.go (85.5%)</option>
				
				<option value="file23">distributed-kvstore/pkg/client/client.go (42.9%)</option>
				
				<option value="file24">distributed-kvstore/pkg/client/pool.go (47.0%)</option>
				
				<option value="file25">distributed-kvstore/pkg/client/types.go (97.9%)</option>
				
				<option value="file26">distributed-kvstore/proto/cluster/cluster.pb.go (0.0%)</option>
				
				<option value="file27">distributed-kvstore/proto/cluster/cluster_grpc.pb.go (0.0%)</option>
				
				<option value="file28">distributed-kvstore/proto/kvstore/kvstore.pb.go (0.0%)</option>
				
				<option value="file29">distributed-kvstore/proto/kvstore/kvstore_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"
        "time"

        "distributed-kvstore/proto/kvstore"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        var (
                addr    = flag.String("addr", "localhost:9090", "Server address")
                timeout = flag.Duration("timeout", 30*time.Second, "Request timeout")
        )
        flag.Parse()

        args := flag.Args()
        if len(args) == 0 </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>

        <span class="cov0" title="0">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to server: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        client := kvstore.NewKVStoreClient(conn)
        ctx, cancel := context.WithTimeout(context.Background(), *timeout)
        defer cancel()

        command := args[0]
        switch command </span>{
        case "put":<span class="cov0" title="0">
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        fmt.Println("Usage: put &lt;key&gt; &lt;value&gt; [ttl_seconds]")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">handlePut(ctx, client, args[1:])</span>
        case "get":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        fmt.Println("Usage: get &lt;key&gt;")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">handleGet(ctx, client, args[1])</span>
        case "delete":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        fmt.Println("Usage: delete &lt;key&gt;")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">handleDelete(ctx, client, args[1])</span>
        case "exists":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        fmt.Println("Usage: exists &lt;key&gt;")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">handleExists(ctx, client, args[1])</span>
        case "list":<span class="cov0" title="0">
                prefix := ""
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        prefix = args[1]
                }</span>
                <span class="cov0" title="0">handleList(ctx, client, prefix)</span>
        case "health":<span class="cov0" title="0">
                handleHealth(ctx, client)</span>
        case "stats":<span class="cov0" title="0">
                handleStats(ctx, client)</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func handlePut(ctx context.Context, client kvstore.KVStoreClient, args []string) <span class="cov0" title="0">{
        req := &amp;kvstore.PutRequest{
                Key:   args[0],
                Value: []byte(args[1]),
        }

        if len(args) &gt; 2 </span><span class="cov0" title="0">{
                var ttl int64
                if _, err := fmt.Sscanf(args[2], "%d", &amp;ttl); err == nil </span><span class="cov0" title="0">{
                        req.TtlSeconds = ttl
                }</span>
        }

        <span class="cov0" title="0">resp, err := client.Put(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Put failed: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.Success </span><span class="cov0" title="0">{
                fmt.Println("OK")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Error: %s\n", resp.Error)
                os.Exit(1)
        }</span>
}

func handleGet(ctx context.Context, client kvstore.KVStoreClient, key string) <span class="cov0" title="0">{
        resp, err := client.Get(ctx, &amp;kvstore.GetRequest{Key: key})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Get failed: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.Found </span><span class="cov0" title="0">{
                fmt.Printf("%s\n", string(resp.Value))
        }</span> else<span class="cov0" title="0"> if resp.Error != "" </span><span class="cov0" title="0">{
                fmt.Printf("Error: %s\n", resp.Error)
                os.Exit(1)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("(nil)")
                os.Exit(1)
        }</span>
}

func handleDelete(ctx context.Context, client kvstore.KVStoreClient, key string) <span class="cov0" title="0">{
        resp, err := client.Delete(ctx, &amp;kvstore.DeleteRequest{Key: key})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Delete failed: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.Success </span><span class="cov0" title="0">{
                if resp.Existed </span><span class="cov0" title="0">{
                        fmt.Println("1")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("0")
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Error: %s\n", resp.Error)
                os.Exit(1)
        }</span>
}

func handleExists(ctx context.Context, client kvstore.KVStoreClient, key string) <span class="cov0" title="0">{
        resp, err := client.Exists(ctx, &amp;kvstore.ExistsRequest{Key: key})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Exists failed: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                fmt.Printf("Error: %s\n", resp.Error)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if resp.Exists </span><span class="cov0" title="0">{
                fmt.Println("1")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("0")
        }</span>
}

func handleList(ctx context.Context, client kvstore.KVStoreClient, prefix string) <span class="cov0" title="0">{
        resp, err := client.List(ctx, &amp;kvstore.ListRequest{
                Prefix: prefix,
                Limit:  100,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("List failed: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                fmt.Printf("Error: %s\n", resp.Error)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(resp.Items) == 0 </span><span class="cov0" title="0">{
                fmt.Println("(empty list)")
                return
        }</span>

        <span class="cov0" title="0">for i, item := range resp.Items </span><span class="cov0" title="0">{
                fmt.Printf("%d) \"%s\" =&gt; \"%s\"\n", i+1, item.Key, string(item.Value))
        }</span>

        <span class="cov0" title="0">if resp.HasMore </span><span class="cov0" title="0">{
                fmt.Printf("... and more (use pagination)\n")
        }</span>
}

func handleHealth(ctx context.Context, client kvstore.KVStoreClient) <span class="cov0" title="0">{
        resp, err := client.Health(ctx, &amp;kvstore.HealthRequest{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Health check failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Healthy: %v\n", resp.Healthy)
        fmt.Printf("Status: %s\n", resp.Status)
        fmt.Printf("Uptime: %d seconds\n", resp.UptimeSeconds)
        fmt.Printf("Version: %s\n", resp.Version)</span>
}

func handleStats(ctx context.Context, client kvstore.KVStoreClient) <span class="cov0" title="0">{
        resp, err := client.Stats(ctx, &amp;kvstore.StatsRequest{
                IncludeDetails: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Stats failed: %v", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                fmt.Printf("Error: %s\n", resp.Error)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Total Keys: %d\n", resp.TotalKeys)
        fmt.Printf("Total Size: %d bytes\n", resp.TotalSize)
        fmt.Printf("LSM Size: %d bytes\n", resp.LsmSize)
        fmt.Printf("VLog Size: %d bytes\n", resp.VlogSize)

        if len(resp.Details) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nDetailed Stats:")
                for key, value := range resp.Details </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: %s\n", key, value)
                }</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Printf(`Distributed Key-Value Store Client

Usage:
  %s [options] &lt;command&gt; [args...]

Options:
  -addr string
        Server address (default "localhost:9090")
  -timeout duration
        Request timeout (default "30s")

Commands:
  put &lt;key&gt; &lt;value&gt; [ttl_seconds]
        Store a key-value pair with optional TTL
  
  get &lt;key&gt;
        Retrieve a value by key
  
  delete &lt;key&gt;
        Delete a key-value pair
  
  exists &lt;key&gt;
        Check if a key exists
  
  list [prefix]
        List all keys (or keys with prefix)
  
  health
        Check server health
  
  stats
        Get server statistics

Examples:
  # Store a value
  %s put user:123 "John Doe"
  
  # Store with TTL (1 hour)
  %s put session:abc "token123" 3600
  
  # Retrieve a value
  %s get user:123
  
  # Check existence
  %s exists user:123
  
  # List all user keys
  %s list user:
  
  # Delete a key
  %s delete user:123
  
  # Check server health
  %s health
`, os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0])
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"
        "time"

        "distributed-kvstore/pkg/client"
)

var (
        address     = flag.String("addr", "localhost:9090", "Server address")
        timeout     = flag.Duration("timeout", 30*time.Second, "Request timeout")
        maxRetries  = flag.Int("retries", 3, "Maximum number of retries")
        verbose     = flag.Bool("v", false, "Verbose output")
        jsonOutput  = flag.Bool("json", false, "Output in JSON format")
        connections = flag.Int("connections", 5, "Maximum connections in pool")
)

func main() <span class="cov0" title="0">{
        flag.Parse()

        args := flag.Args()
        if len(args) == 0 </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>

        <span class="cov0" title="0">config := client.DefaultConfig()
        config.Addresses = []string{*address}
        config.RequestTimeout = *timeout
        config.MaxRetries = *maxRetries
        config.MaxConnections = *connections

        kvClient, err := client.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>
        <span class="cov0" title="0">defer kvClient.Close()

        ctx, cancel := context.WithTimeout(context.Background(), *timeout)
        defer cancel()

        command := args[0]
        switch command </span>{
        case "put":<span class="cov0" title="0">
                handlePut(ctx, kvClient, args[1:])</span>
        case "get":<span class="cov0" title="0">
                handleGet(ctx, kvClient, args[1:])</span>
        case "delete", "del":<span class="cov0" title="0">
                handleDelete(ctx, kvClient, args[1:])</span>
        case "exists":<span class="cov0" title="0">
                handleExists(ctx, kvClient, args[1:])</span>
        case "list":<span class="cov0" title="0">
                handleList(ctx, kvClient, args[1:])</span>
        case "keys":<span class="cov0" title="0">
                handleKeys(ctx, kvClient, args[1:])</span>
        case "batch-put":<span class="cov0" title="0">
                handleBatchPut(ctx, kvClient, args[1:])</span>
        case "batch-get":<span class="cov0" title="0">
                handleBatchGet(ctx, kvClient, args[1:])</span>
        case "batch-delete", "batch-del":<span class="cov0" title="0">
                handleBatchDelete(ctx, kvClient, args[1:])</span>
        case "health":<span class="cov0" title="0">
                handleHealth(ctx, kvClient)</span>
        case "stats":<span class="cov0" title="0">
                handleStats(ctx, kvClient, args[1:])</span>
        case "benchmark":<span class="cov0" title="0">
                handleBenchmark(ctx, kvClient, args[1:])</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func handlePut(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: put &lt;key&gt; &lt;value&gt; [ttl_seconds]")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">key := args[0]
        value := []byte(args[1])
        
        var opts []client.PutOption
        if len(args) &gt; 2 </span><span class="cov0" title="0">{
                ttl, err := strconv.ParseInt(args[2], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid TTL: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">opts = append(opts, client.WithTTL(ttl))</span>
        }

        <span class="cov0" title="0">start := time.Now()
        err := kvClient.Put(ctx, key, value, opts...)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "success": false,
                                "error":   err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                outputJSON(map[string]interface{}{
                        "success": true,
                        "duration_ms": duration.Milliseconds(),
                })
        }</span> else<span class="cov0" title="0"> {
                if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("OK (took %v)\n", duration)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("OK")
                }</span>
        }
}

func handleGet(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: get &lt;key&gt;")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">key := args[0]
        start := time.Now()
        result, err := kvClient.Get(ctx, key)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "found": false,
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                data := map[string]interface{}{
                        "found": result.Found,
                        "duration_ms": duration.Milliseconds(),
                }
                if result.Found </span><span class="cov0" title="0">{
                        data["value"] = string(result.Value)
                        data["created_at"] = result.CreatedAt.Unix()
                        if result.HasTTL() </span><span class="cov0" title="0">{
                                data["expires_at"] = result.ExpiresAt.Unix()
                                data["ttl_seconds"] = int64(result.TTL().Seconds())
                        }</span>
                }
                <span class="cov0" title="0">outputJSON(data)</span>
        } else<span class="cov0" title="0"> {
                if result.Found </span><span class="cov0" title="0">{
                        fmt.Printf("%s", string(result.Value))
                        if *verbose </span><span class="cov0" title="0">{
                                fmt.Printf(" (created: %v", result.CreatedAt.Format(time.RFC3339))
                                if result.HasTTL() </span><span class="cov0" title="0">{
                                        fmt.Printf(", expires: %v, ttl: %v", result.ExpiresAt.Format(time.RFC3339), result.TTL())
                                }</span>
                                <span class="cov0" title="0">fmt.Printf(", took %v)", duration)</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("(nil)")
                        os.Exit(1)
                }</span>
        }
}

func handleDelete(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: delete &lt;key&gt;")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">key := args[0]
        start := time.Now()
        result, err := kvClient.Delete(ctx, key)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "success": false,
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                outputJSON(map[string]interface{}{
                        "success": true,
                        "existed": result.Existed,
                        "duration_ms": duration.Milliseconds(),
                })
        }</span> else<span class="cov0" title="0"> {
                if result.Existed </span><span class="cov0" title="0">{
                        fmt.Println("1")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("0")
                }</span>
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(took %v)\n", duration)
                }</span>
        }
}

func handleExists(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: exists &lt;key&gt;")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">key := args[0]
        start := time.Now()
        exists, err := kvClient.Exists(ctx, key)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                outputJSON(map[string]interface{}{
                        "exists": exists,
                        "duration_ms": duration.Milliseconds(),
                })
        }</span> else<span class="cov0" title="0"> {
                if exists </span><span class="cov0" title="0">{
                        fmt.Println("1")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("0")
                }</span>
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(took %v)\n", duration)
                }</span>
        }
}

func handleList(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        prefix := ""
        limit := int32(100)
        
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                prefix = args[0]
        }</span>
        <span class="cov0" title="0">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                l, err := strconv.Atoi(args[1])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid limit: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">limit = int32(l)</span>
        }

        <span class="cov0" title="0">start := time.Now()
        result, err := kvClient.List(ctx, prefix, client.WithLimit(limit))
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                items := make([]map[string]interface{}, len(result.Items))
                for i, item := range result.Items </span><span class="cov0" title="0">{
                        itemData := map[string]interface{}{
                                "key":   item.Key,
                                "value": string(item.Value),
                                "created_at": item.CreatedAt.Unix(),
                        }
                        if item.ExpiresAt.Unix() &gt; 0 </span><span class="cov0" title="0">{
                                itemData["expires_at"] = item.ExpiresAt.Unix()
                        }</span>
                        <span class="cov0" title="0">items[i] = itemData</span>
                }
                
                <span class="cov0" title="0">outputJSON(map[string]interface{}{
                        "items": items,
                        "count": result.Count(),
                        "has_more": result.HasMore,
                        "next_cursor": result.NextCursor,
                        "duration_ms": duration.Milliseconds(),
                })</span>
        } else<span class="cov0" title="0"> {
                if result.IsEmpty() </span><span class="cov0" title="0">{
                        fmt.Println("(empty list)")
                        return
                }</span>

                <span class="cov0" title="0">for i, item := range result.Items </span><span class="cov0" title="0">{
                        fmt.Printf("%d) \"%s\" =&gt; \"%s\"", i+1, item.Key, string(item.Value))
                        if *verbose </span><span class="cov0" title="0">{
                                fmt.Printf(" (created: %v", item.CreatedAt.Format(time.RFC3339))
                                if item.ExpiresAt.Unix() &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf(", expires: %v", item.ExpiresAt.Format(time.RFC3339))
                                }</span>
                                <span class="cov0" title="0">fmt.Printf(")")</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">if result.HasMore </span><span class="cov0" title="0">{
                        fmt.Printf("... and more (next cursor: %s)\n", result.NextCursor)
                }</span>
                
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(returned %d items, took %v)\n", result.Count(), duration)
                }</span>
        }
}

func handleKeys(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        prefix := ""
        limit := int32(100)
        
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                prefix = args[0]
        }</span>
        <span class="cov0" title="0">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                l, err := strconv.Atoi(args[1])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid limit: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">limit = int32(l)</span>
        }

        <span class="cov0" title="0">start := time.Now()
        result, err := kvClient.ListKeys(ctx, prefix, client.WithLimit(limit))
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                outputJSON(map[string]interface{}{
                        "keys": result.Keys,
                        "count": result.Count(),
                        "has_more": result.HasMore,
                        "next_cursor": result.NextCursor,
                        "duration_ms": duration.Milliseconds(),
                })
        }</span> else<span class="cov0" title="0"> {
                if result.IsEmpty() </span><span class="cov0" title="0">{
                        fmt.Println("(empty list)")
                        return
                }</span>

                <span class="cov0" title="0">for i, key := range result.Keys </span><span class="cov0" title="0">{
                        fmt.Printf("%d) %s\n", i+1, key)
                }</span>

                <span class="cov0" title="0">if result.HasMore </span><span class="cov0" title="0">{
                        fmt.Printf("... and more (next cursor: %s)\n", result.NextCursor)
                }</span>
                
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(returned %d keys, took %v)\n", result.Count(), duration)
                }</span>
        }
}

func handleBatchPut(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 2 || len(args)%2 != 0 </span><span class="cov0" title="0">{
                fmt.Println("Usage: batch-put &lt;key1&gt; &lt;value1&gt; [key2] [value2] ...")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var items []*client.PutItem
        for i := 0; i &lt; len(args); i += 2 </span><span class="cov0" title="0">{
                items = append(items, &amp;client.PutItem{
                        Key:   args[i],
                        Value: []byte(args[i+1]),
                })
        }</span>

        <span class="cov0" title="0">start := time.Now()
        result, err := kvClient.BatchPut(ctx, items)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                errors := make([]map[string]string, len(result.Errors))
                for i, batchErr := range result.Errors </span><span class="cov0" title="0">{
                        errors[i] = map[string]string{
                                "key":   batchErr.Key,
                                "error": batchErr.Error,
                        }
                }</span>
                
                <span class="cov0" title="0">outputJSON(map[string]interface{}{
                        "success_count": result.SuccessCount,
                        "error_count": result.ErrorCount,
                        "total": result.TotalOperations(),
                        "success_rate": result.SuccessRate(),
                        "errors": errors,
                        "duration_ms": duration.Milliseconds(),
                })</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Success: %d, Errors: %d, Total: %d\n", 
                        result.SuccessCount, result.ErrorCount, result.TotalOperations())
                
                if result.HasErrors() </span><span class="cov0" title="0">{
                        fmt.Println("Errors:")
                        for _, batchErr := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s\n", batchErr.Key, batchErr.Error)
                        }</span>
                }
                
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(success rate: %.1f%%, took %v)\n", result.SuccessRate(), duration)
                }</span>
        }
}

func handleBatchGet(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: batch-get &lt;key1&gt; [key2] [key3] ...")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        results, err := kvClient.BatchGet(ctx, args)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                items := make([]map[string]interface{}, len(results))
                for i, result := range results </span><span class="cov0" title="0">{
                        itemData := map[string]interface{}{
                                "key":   result.Key,
                                "found": result.Found,
                        }
                        if result.Found </span><span class="cov0" title="0">{
                                itemData["value"] = string(result.Value)
                                itemData["created_at"] = result.CreatedAt.Unix()
                                if result.HasTTL() </span><span class="cov0" title="0">{
                                        itemData["expires_at"] = result.ExpiresAt.Unix()
                                }</span>
                        }
                        <span class="cov0" title="0">items[i] = itemData</span>
                }
                
                <span class="cov0" title="0">outputJSON(map[string]interface{}{
                        "results": items,
                        "total": len(results),
                        "duration_ms": duration.Milliseconds(),
                })</span>
        } else<span class="cov0" title="0"> {
                foundCount := 0
                for i, result := range results </span><span class="cov0" title="0">{
                        fmt.Printf("%d) %s =&gt; ", i+1, result.Key)
                        if result.Found </span><span class="cov0" title="0">{
                                fmt.Printf("\"%s\"", string(result.Value))
                                foundCount++
                                if *verbose &amp;&amp; result.HasTTL() </span><span class="cov0" title="0">{
                                        fmt.Printf(" (ttl: %v)", result.TTL())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("(nil)")
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(found %d/%d keys, took %v)\n", foundCount, len(results), duration)
                }</span>
        }
}

func handleBatchDelete(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: batch-delete &lt;key1&gt; [key2] [key3] ...")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        result, err := kvClient.BatchDelete(ctx, args)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                errors := make([]map[string]string, len(result.Errors))
                for i, batchErr := range result.Errors </span><span class="cov0" title="0">{
                        errors[i] = map[string]string{
                                "key":   batchErr.Key,
                                "error": batchErr.Error,
                        }
                }</span>
                
                <span class="cov0" title="0">outputJSON(map[string]interface{}{
                        "success_count": result.SuccessCount,
                        "error_count": result.ErrorCount,
                        "total": result.TotalOperations(),
                        "success_rate": result.SuccessRate(),
                        "errors": errors,
                        "duration_ms": duration.Milliseconds(),
                })</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Success: %d, Errors: %d, Total: %d\n", 
                        result.SuccessCount, result.ErrorCount, result.TotalOperations())
                
                if result.HasErrors() </span><span class="cov0" title="0">{
                        fmt.Println("Errors:")
                        for _, batchErr := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s\n", batchErr.Key, batchErr.Error)
                        }</span>
                }
                
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(success rate: %.1f%%, took %v)\n", result.SuccessRate(), duration)
                }</span>
        }
}

func handleHealth(ctx context.Context, kvClient *client.Client) <span class="cov0" title="0">{
        start := time.Now()
        result, err := kvClient.Health(ctx)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                outputJSON(map[string]interface{}{
                        "healthy": result.Healthy,
                        "status": result.Status,
                        "uptime_seconds": result.UptimeSeconds,
                        "version": result.Version,
                        "duration_ms": duration.Milliseconds(),
                })
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Healthy: %v\n", result.Healthy)
                fmt.Printf("Status: %s\n", result.Status)
                fmt.Printf("Uptime: %v\n", result.UptimeDuration())
                fmt.Printf("Version: %s\n", result.Version)
                
                if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(took %v)\n", duration)
                }</span>
        }
}

func handleStats(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        includeDetails := len(args) &gt; 0 &amp;&amp; (args[0] == "detailed" || args[0] == "details")
        
        start := time.Now()
        result, err := kvClient.Stats(ctx, includeDetails)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if *jsonOutput </span><span class="cov0" title="0">{
                        outputJSON(map[string]interface{}{
                                "error": err.Error(),
                                "duration_ms": duration.Milliseconds(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                data := map[string]interface{}{
                        "total_keys": result.TotalKeys,
                        "total_size": result.TotalSize,
                        "lsm_size": result.LSMSize,
                        "vlog_size": result.VLogSize,
                        "duration_ms": duration.Milliseconds(),
                }
                if includeDetails &amp;&amp; len(result.Details) &gt; 0 </span><span class="cov0" title="0">{
                        data["details"] = result.Details
                }</span>
                <span class="cov0" title="0">outputJSON(data)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Total Keys: %d\n", result.TotalKeys)
                fmt.Printf("Total Size: %d bytes (%.2f MB)\n", result.TotalSize, result.TotalSizeMB())
                fmt.Printf("LSM Size: %d bytes\n", result.LSMSize)
                fmt.Printf("VLog Size: %d bytes\n", result.VLogSize)

                if includeDetails &amp;&amp; len(result.Details) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("\nDetailed Stats:")
                        for key, value := range result.Details </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s\n", key, value)
                        }</span>
                }
                
                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("(took %v)\n", duration)
                }</span>
        }
}

func handleBenchmark(ctx context.Context, kvClient *client.Client, args []string) <span class="cov0" title="0">{
        operations := 1000
        keySize := 10
        valueSize := 100
        
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                ops, err := strconv.Atoi(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid operations count: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">operations = ops</span>
        }

        <span class="cov0" title="0">fmt.Printf("Running benchmark: %d operations\n", operations)
        
        // Generate test data
        var items []*client.PutItem
        for i := 0; i &lt; operations; i++ </span><span class="cov0" title="0">{
                key := fmt.Sprintf("bench:key:%0*d", keySize-10, i)
                value := strings.Repeat("x", valueSize)
                items = append(items, &amp;client.PutItem{
                        Key:   key,
                        Value: []byte(value),
                })
        }</span>

        // Benchmark PUT operations
        <span class="cov0" title="0">fmt.Println("Benchmarking PUT operations...")
        start := time.Now()
        result, err := kvClient.BatchPut(ctx, items)
        putDuration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("PUT benchmark failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">putOpsPerSec := float64(operations) / putDuration.Seconds()
        fmt.Printf("PUT: %d ops in %v (%.0f ops/sec, %.1f%% success)\n",
                operations, putDuration, putOpsPerSec, result.SuccessRate())

        // Benchmark GET operations
        fmt.Println("Benchmarking GET operations...")
        keys := make([]string, operations)
        for i, item := range items </span><span class="cov0" title="0">{
                keys[i] = item.Key
        }</span>

        <span class="cov0" title="0">start = time.Now()
        getResults, err := kvClient.BatchGet(ctx, keys)
        getDuration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("GET benchmark failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">foundCount := 0
        for _, getResult := range getResults </span><span class="cov0" title="0">{
                if getResult.Found </span><span class="cov0" title="0">{
                        foundCount++
                }</span>
        }

        <span class="cov0" title="0">getOpsPerSec := float64(operations) / getDuration.Seconds()
        successRate := float64(foundCount) / float64(operations) * 100
        fmt.Printf("GET: %d ops in %v (%.0f ops/sec, %.1f%% found)\n",
                operations, getDuration, getOpsPerSec, successRate)

        // Summary
        totalDuration := putDuration + getDuration
        totalOpsPerSec := float64(operations*2) / totalDuration.Seconds()
        fmt.Printf("\nTotal: %d ops in %v (%.0f ops/sec)\n",
                operations*2, totalDuration, totalOpsPerSec)</span>
}

func outputJSON(data interface{}) <span class="cov0" title="0">{
        output, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error formatting JSON: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(output))</span>
}

func printUsage() <span class="cov0" title="0">{
        fmt.Printf(`KV Tool - Distributed Key-Value Store Testing CLI

Usage:
  %s [options] &lt;command&gt; [args...]

Options:
  -addr string
        Server address (default "localhost:9090")
  -timeout duration
        Request timeout (default "30s")
  -retries int
        Maximum number of retries (default "3")
  -connections int
        Maximum connections in pool (default "5")
  -v    Verbose output
  -json Output in JSON format

Commands:
  put &lt;key&gt; &lt;value&gt; [ttl_seconds]
        Store a key-value pair with optional TTL
  
  get &lt;key&gt;
        Retrieve a value by key
  
  delete &lt;key&gt;
        Delete a key-value pair
  
  exists &lt;key&gt;
        Check if a key exists
  
  list [prefix] [limit]
        List key-value pairs (optionally with prefix and limit)
  
  keys [prefix] [limit]
        List keys only (optionally with prefix and limit)
  
  batch-put &lt;key1&gt; &lt;value1&gt; [key2] [value2] ...
        Store multiple key-value pairs
  
  batch-get &lt;key1&gt; [key2] [key3] ...
        Retrieve multiple values
  
  batch-delete &lt;key1&gt; [key2] [key3] ...
        Delete multiple keys
  
  health
        Check server health
  
  stats [detailed]
        Get server statistics (optionally detailed)
  
  benchmark [operations]
        Run performance benchmark (default 1000 operations)

Examples:
  # Basic operations
  %s put user:123 "John Doe"
  %s get user:123
  %s delete user:123
  
  # With TTL (1 hour)
  %s put session:abc "token123" 3600
  
  # Batch operations
  %s batch-put user:1 "Alice" user:2 "Bob" user:3 "Charlie"
  %s batch-get user:1 user:2 user:3
  
  # List operations
  %s list user: 10
  %s keys session: 5
  
  # JSON output
  %s -json get user:123
  %s -json stats detailed
  
  # Benchmark
  %s benchmark 5000
  
  # Verbose output
  %s -v put test:key "test value"
`, os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0], os.Args[0])
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"

        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/server"
)

func main() <span class="cov0" title="0">{
        var configPath string
        flag.StringVar(&amp;configPath, "config", "config.yaml", "Path to configuration file")
        flag.Parse()

        if len(os.Args) &gt; 1 &amp;&amp; (os.Args[1] == "-h" || os.Args[1] == "--help") </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        <span class="cov0" title="0">srv, err := server.NewServer(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create server: %v", err)
        }</span>

        <span class="cov0" title="0">if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start: %v", err)
        }</span>
}

func printUsage() <span class="cov0" title="0">{
        fmt.Printf(`Distributed Key-Value Store Server

Usage:
  %s [options]

Options:
  -config string
        Path to configuration file (default "config.yaml")
  -h, --help
        Show this help message

Environment Variables:
  Configuration can be overridden using environment variables with KV_ prefix.
  See docs/configuration.md for details.

Examples:
  # Start with default config
  %s

  # Start with custom config file
  %s -config /path/to/config.yaml

  # Start with environment override
  KV_SERVER_PORT=9000 %s

For more information, see:
  - Configuration: docs/configuration.md
  - API Reference: docs/api.md
  - Architecture: docs/architecture.md
`, os.Args[0], os.Args[0], os.Args[0], os.Args[0])
}</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "distributed-kvstore/internal/logging"
)

func main() <span class="cov0" title="0">{
        fmt.Println("=== Correlation ID Demo ===")
        fmt.Println("This demo shows how correlation IDs work across HTTP requests")
        fmt.Println()

        // Wait a moment for any previous server to shut down
        time.Sleep(1 * time.Second)

        baseURL := "http://localhost:8080"

        // Test 1: Request without correlation ID (middleware generates one)
        fmt.Println("1. Making request without correlation ID:")
        testRequest(baseURL+"/health", "", "")

        // Test 2: Request with custom correlation ID
        fmt.Println("\n2. Making request with custom correlation ID:")
        customCorrelationID := logging.GenerateCorrelationID()
        customRequestID := logging.GenerateRequestID()
        testRequest(baseURL+"/health", customCorrelationID, customRequestID)

        // Test 3: Multiple requests with same correlation ID (simulating distributed request)
        fmt.Println("\n3. Making multiple requests with same correlation ID:")
        sharedCorrelationID := logging.GenerateCorrelationID()
        for i := 1; i &lt;= 3; i++ </span><span class="cov0" title="0">{
                requestID := logging.GenerateRequestID()
                fmt.Printf("Request %d with correlation ID %s:\n", i, sharedCorrelationID)
                testRequest(baseURL+"/health", sharedCorrelationID, requestID)
                if i &lt; 3 </span><span class="cov0" title="0">{
                        time.Sleep(100 * time.Millisecond)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\n4. Making a key-value operation request:")
        testKVOperation(baseURL)</span>
}

func testRequest(url, correlationID, requestID string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating request: %v\n", err)
                return
        }</span>

        // Add correlation ID headers if provided
        <span class="cov0" title="0">if correlationID != "" </span><span class="cov0" title="0">{
                req.Header.Set("X-Correlation-ID", correlationID)
        }</span>
        <span class="cov0" title="0">if requestID != "" </span><span class="cov0" title="0">{
                req.Header.Set("X-Request-ID", requestID)
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error making request: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading response: %v\n", err)
                return
        }</span>

        // Print the correlation ID returned by server
        <span class="cov0" title="0">serverCorrelationID := resp.Header.Get("X-Correlation-ID")
        serverRequestID := resp.Header.Get("X-Request-ID")

        fmt.Printf("  Status: %d\n", resp.StatusCode)
        fmt.Printf("  Server Correlation ID: %s\n", serverCorrelationID)
        fmt.Printf("  Server Request ID: %s\n", serverRequestID)

        if correlationID != "" &amp;&amp; serverCorrelationID != correlationID </span><span class="cov0" title="0">{
                fmt.Printf("  ⚠️  Correlation ID mismatch! Sent: %s, Received: %s\n", correlationID, serverCorrelationID)
        }</span> else<span class="cov0" title="0"> if correlationID != "" </span><span class="cov0" title="0">{
                fmt.Printf("  ✅ Correlation ID preserved correctly\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  ✅ Server generated correlation ID\n")
        }</span>

        // Pretty print JSON response if it's JSON
        <span class="cov0" title="0">var jsonResponse map[string]interface{}
        if err := json.Unmarshal(body, &amp;jsonResponse); err == nil </span><span class="cov0" title="0">{
                prettyJSON, _ := json.MarshalIndent(jsonResponse, "  ", "  ")
                fmt.Printf("  Response: %s\n", string(prettyJSON))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  Response: %s\n", string(body))
        }</span>
}

func testKVOperation(baseURL string) <span class="cov0" title="0">{
        correlationID := logging.GenerateCorrelationID()
        
        // First, put a key
        putData := map[string]interface{}{
                "value": "test-value-with-correlation",
        }
        jsonData, _ := json.Marshal(putData)

        client := &amp;http.Client{Timeout: 5 * time.Second}
        req, err := http.NewRequest("PUT", baseURL+"/api/v1/kv/demo-key", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating PUT request: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("X-Correlation-ID", correlationID)

        fmt.Printf("  PUT request with correlation ID %s:\n", correlationID)
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Error making PUT request: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        fmt.Printf("    PUT Status: %d\n", resp.StatusCode)
        fmt.Printf("    PUT Correlation ID: %s\n", resp.Header.Get("X-Correlation-ID"))

        // Now get the key with same correlation ID
        time.Sleep(100 * time.Millisecond)
        
        getReq, err := http.NewRequest("GET", baseURL+"/api/v1/kv/demo-key", nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating GET request: %v\n", err)
                return
        }</span>
        
        <span class="cov0" title="0">getReq.Header.Set("X-Correlation-ID", correlationID)

        fmt.Printf("  GET request with same correlation ID:\n")
        getResp, err := client.Do(getReq)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Error making GET request: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer getResp.Body.Close()

        getBody, _ := io.ReadAll(getResp.Body)
        fmt.Printf("    GET Status: %d\n", getResp.StatusCode)
        fmt.Printf("    GET Correlation ID: %s\n", getResp.Header.Get("X-Correlation-ID"))
        fmt.Printf("    GET Response: %s\n", string(getBody))
        
        if getResp.Header.Get("X-Correlation-ID") == correlationID </span><span class="cov0" title="0">{
                fmt.Printf("    ✅ Correlation ID preserved across PUT and GET operations\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("    ⚠️  Correlation ID not preserved\n")
        }</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "time"

        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/logging"
)

func main() <span class="cov0" title="0">{
        fmt.Println("=== Distributed Key-Value Store - Structured Logging Demo ===")
        fmt.Println()

        // Demo different logging configurations
        demonstrateEnvironmentConfigs()
        fmt.Println()

        // Demo correlation IDs and context logging
        demonstrateCorrelationIDs()
        fmt.Println()

        // Demo specialized logging methods
        demonstrateSpecializedLogging()
        fmt.Println()

        // Demo request tracing simulation
        demonstrateRequestTracing()
}</span>

func demonstrateEnvironmentConfigs() <span class="cov0" title="0">{
        fmt.Println("1. Environment-Specific Logging Configurations")
        fmt.Println("----------------------------------------------")

        environments := []struct {
                name   string
                config config.LoggingConfig
        }{
                {"Development", logging.DevelopmentLoggingConfig()},
                {"Production", logging.ProductionLoggingConfig()},
                {"High Volume", logging.HighVolumeLoggingConfig()},
        }

        for _, env := range environments </span><span class="cov0" title="0">{
                fmt.Printf("\n%s Environment:\n", env.name)
                fmt.Printf("- Level: %s\n", env.config.Level)
                fmt.Printf("- Format: %s\n", env.config.Format)
                fmt.Printf("- Request Tracing: %t\n", env.config.EnableRequestTracing)
                fmt.Printf("- Correlation IDs: %t\n", env.config.EnableCorrelationIDs)
                fmt.Printf("- Database Logging: %t\n", env.config.EnableDatabaseLogging)
                fmt.Printf("- Performance Logging: %t\n", env.config.EnablePerformanceLog)
                fmt.Printf("- Log Sampling: %d\n", env.config.LogSampling)

                logger := logging.NewLogger(&amp;env.config)
                logger.Info("Sample log from "+env.name+" environment",
                        "environment", env.name,
                        "feature", "logging_demo",
                )
        }</span>
}

func demonstrateCorrelationIDs() <span class="cov0" title="0">{
        fmt.Println("2. Correlation IDs and Context Logging")
        fmt.Println("-------------------------------------")

        config := logging.DevelopmentLoggingConfig()
        config.Format = "json" // Use JSON for clarity in demo
        logger := logging.NewLogger(&amp;config)

        // Generate correlation and request IDs
        correlationID := logging.GenerateCorrelationID()
        requestID := logging.GenerateRequestID()

        fmt.Printf("Generated Correlation ID: %s\n", correlationID)
        fmt.Printf("Generated Request ID: %s\n", requestID)

        // Create context with IDs
        ctx := context.Background()
        ctx = logging.CreateContextWithIDs(ctx, correlationID, requestID)
        ctx = context.WithValue(ctx, logging.ServiceKey, "demo-service")

        // Log with context - notice how correlation/request IDs are automatically included
        logger.InfoContext(ctx, "User authentication started", "user_id", "user123")
        logger.DebugContext(ctx, "Database query executed", "query", "SELECT * FROM users", "duration_ms", 15)
        logger.InfoContext(ctx, "User authentication completed", "user_id", "user123", "success", true)
}</span>

func demonstrateSpecializedLogging() <span class="cov0" title="0">{
        fmt.Println("\n3. Specialized Logging Methods")
        fmt.Println("-----------------------------")

        config := logging.ProductionLoggingConfig()
        logger := logging.NewLogger(&amp;config)
        ctx := context.Background()
        ctx = logging.CreateContextWithIDs(ctx, logging.GenerateCorrelationID(), logging.GenerateRequestID())

        // Database operation logging
        fmt.Println("\nDatabase Operations:")
        logger.DatabaseOperation(ctx, "put", "user:123", 5*time.Millisecond, nil)
        logger.DatabaseOperation(ctx, "get", "user:456", 2*time.Millisecond, fmt.Errorf("key not found"))

        // Cluster event logging  
        fmt.Println("\nCluster Events:")
        logger.ClusterEvent(ctx, "node_joined", "node2", map[string]interface{}{
                "address":    "10.0.0.2:7000",
                "region":     "us-west-2",
                "datacenter": "west-2a",
        })

        logger.ClusterEvent(ctx, "leader_elected", "node1", map[string]interface{}{
                "term":      5,
                "log_index": 1250,
        })

        // Security event logging
        fmt.Println("\nSecurity Events:")
        logger.SecurityEvent(ctx, "authentication_failure", "192.168.1.100", "medium", map[string]interface{}{
                "username":      "admin",
                "failure_count": 2,
                "source":        "web_ui",
        })

        logger.SecurityEvent(ctx, "unauthorized_access", "192.168.1.100", "high", map[string]interface{}{
                "endpoint":   "/admin/users",
                "user_agent": "curl/7.68.0",
                "blocked":    true,
        })

        // Performance metrics logging
        fmt.Println("\nPerformance Metrics:")
        logger.Performance(ctx, "http_request_duration", 125.5, "milliseconds", map[string]string{
                "method":   "GET",
                "endpoint": "/api/v1/kv/user:123",
                "status":   "200",
        })

        logger.Performance(ctx, "database_connection_pool", 15, "active_connections", map[string]string{
                "pool":     "primary",
                "database": "badger",
        })
}</span>

func demonstrateRequestTracing() <span class="cov0" title="0">{
        fmt.Println("\n4. Request Tracing Simulation")
        fmt.Println("----------------------------")

        config := logging.DevelopmentLoggingConfig()
        config.Format = "json"
        logger := logging.NewLogger(&amp;config)

        // Simulate an HTTP request with correlation ID middleware
        simulateHTTPRequest(logger, "GET", "/api/v1/kv/user:123", "user123")
        fmt.Println()
        simulateHTTPRequest(logger, "POST", "/api/v1/kv/batch/put", "user456")
}</span>

func simulateHTTPRequest(logger *logging.Logger, method, path, userID string) <span class="cov0" title="0">{
        // Create a new context for the request
        ctx := context.Background()
        
        // Generate correlation and request IDs (normally done by middleware)
        correlationID := logging.GenerateCorrelationID()
        requestID := logging.GenerateRequestID()
        
        ctx = logging.CreateContextWithIDs(ctx, correlationID, requestID)
        ctx = context.WithValue(ctx, logging.ServiceKey, "kvstore-api")
        ctx = context.WithValue(ctx, logging.UserIDKey, userID)

        start := time.Now()

        // Log request start
        logger.RequestStart(ctx, method, path, "kvstore-client/1.0.0")

        // Simulate some processing
        time.Sleep(10 * time.Millisecond)

        // Log database operations
        logger.DatabaseOperation(ctx, "get", "user:"+userID, 3*time.Millisecond, nil)
        
        if method == "POST" </span><span class="cov0" title="0">{
                logger.DatabaseOperation(ctx, "batch_put", "multiple_keys", 8*time.Millisecond, nil)
        }</span>

        // Simulate response
        <span class="cov0" title="0">statusCode := 200
        if userID == "user456" &amp;&amp; method == "POST" </span><span class="cov0" title="0">{
                statusCode = 201 // Created
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        logger.RequestEnd(ctx, method, path, statusCode, duration, 1024)

        fmt.Printf("Completed %s %s (correlation_id: %s, duration: %v)\n", 
                method, path, correlationID, duration)</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
)

func main() <span class="cov0" title="0">{
        fmt.Println("=== KVStore Monitoring Demo ===")
        fmt.Println("This demo showcases the monitoring capabilities of the KVStore")
        fmt.Println()

        baseURL := "http://localhost:8080"

        // Wait a moment for server to be ready
        fmt.Println("Waiting for server to be ready...")
        waitForServer(baseURL)

        // Demo 1: Basic Health Check
        fmt.Println("1. Basic Health Check")
        fmt.Println("-------------------")
        testHealthCheck(baseURL)
        fmt.Println()

        // Demo 2: Generate some load to create metrics
        fmt.Println("2. Generating Load for Metrics")
        fmt.Println("-----------------------------")
        generateLoad(baseURL)
        fmt.Println()

        // Demo 3: Check Prometheus Metrics
        fmt.Println("3. Prometheus Metrics")
        fmt.Println("--------------------")
        testPrometheusMetrics(baseURL)
        fmt.Println()

        // Demo 4: Enhanced Health Check with Dependencies
        fmt.Println("4. Enhanced Health Check")
        fmt.Println("-----------------------")
        testEnhancedHealthCheck(baseURL)
        fmt.Println()

        // Demo 5: Monitoring Dashboard
        fmt.Println("5. Monitoring Dashboard")
        fmt.Println("----------------------")
        testMonitoringDashboard(baseURL)
        fmt.Println()

        fmt.Println("Demo completed! Check the following endpoints:")
        fmt.Printf("- Health Check: %s/health\n", baseURL)
        fmt.Printf("- Prometheus Metrics: %s/api/v1/metrics\n", baseURL)
        fmt.Printf("- Monitoring Dashboard: %s/dashboard\n", baseURL)
}</span>

func waitForServer(baseURL string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 2 * time.Second}
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                resp, err := client.Get(baseURL + "/health")
                if err == nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        fmt.Println("✅ Server is ready!")
                        return
                }</span>
                <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                }</span>
                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                fmt.Printf("⏳ Waiting for server... (%d/10)\n", i+1)</span>
        }
        <span class="cov0" title="0">fmt.Println("⚠️  Server may not be ready, continuing anyway...")</span>
}

func testHealthCheck(baseURL string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Get(baseURL + "/health")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Health check failed: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to read health response: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Status Code: %d\n", resp.StatusCode)
        
        // Parse and pretty-print JSON
        var healthData map[string]interface{}
        if err := json.Unmarshal(body, &amp;healthData); err == nil </span><span class="cov0" title="0">{
                prettyJSON, _ := json.MarshalIndent(healthData, "  ", "  ")
                fmt.Printf("Response:\n%s\n", string(prettyJSON))
                
                // Extract key information
                if status, ok := healthData["status"].(string); ok </span><span class="cov0" title="0">{
                        switch status </span>{
                        case "healthy":<span class="cov0" title="0">
                                fmt.Println("✅ System is healthy")</span>
                        case "degraded":<span class="cov0" title="0">
                                fmt.Println("⚠️  System is degraded")</span>
                        case "unhealthy":<span class="cov0" title="0">
                                fmt.Println("❌ System is unhealthy")</span>
                        }
                }
                
                <span class="cov0" title="0">if summary, ok := healthData["summary"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if total, ok := summary["total"].(float64); ok </span><span class="cov0" title="0">{
                                fmt.Printf("Total health checks: %.0f\n", total)
                        }</span>
                        <span class="cov0" title="0">if healthy, ok := summary["healthy"].(float64); ok </span><span class="cov0" title="0">{
                                fmt.Printf("Healthy checks: %.0f\n", healthy)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                fmt.Printf("Raw Response: %s\n", string(body))
        }</span>
}

func generateLoad(baseURL string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        
        fmt.Println("Generating sample requests to create metrics...")
        
        operations := []struct {
                method string
                path   string
                body   string
        }{
                {"PUT", "/api/v1/kv/demo-key-1", `{"value": "demo-value-1"}`},
                {"PUT", "/api/v1/kv/demo-key-2", `{"value": "demo-value-2"}`},
                {"GET", "/api/v1/kv/demo-key-1", ""},
                {"GET", "/api/v1/kv/demo-key-2", ""},
                {"GET", "/api/v1/kv/nonexistent", ""}, // This will generate a 404
                {"PUT", "/api/v1/kv/demo-key-3", `{"value": "demo-value-3"}`},
                {"DELETE", "/api/v1/kv/demo-key-1", ""},
                {"GET", "/api/v1/kv", ""}, // List keys
        }
        
        successCount := 0
        errorCount := 0
        
        for _, op := range operations </span><span class="cov0" title="0">{
                var req *http.Request
                var err error
                
                if op.body != "" </span><span class="cov0" title="0">{
                        req, err = http.NewRequest(op.method, baseURL+op.path, bytes.NewBufferString(op.body))
                        req.Header.Set("Content-Type", "application/json")
                }</span> else<span class="cov0" title="0"> {
                        req, err = http.NewRequest(op.method, baseURL+op.path, nil)
                }</span>
                
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to create request: %v\n", err)
                        continue</span>
                }
                
                <span class="cov0" title="0">resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Request failed: %v\n", err)
                        errorCount++
                        continue</span>
                }
                <span class="cov0" title="0">resp.Body.Close()
                
                if resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                        successCount++
                        fmt.Printf("✅ %s %s -&gt; %d\n", op.method, op.path, resp.StatusCode)
                }</span> else<span class="cov0" title="0"> {
                        errorCount++
                        fmt.Printf("⚠️  %s %s -&gt; %d\n", op.method, op.path, resp.StatusCode)
                }</span>
                
                // Small delay between requests
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }
        
        <span class="cov0" title="0">fmt.Printf("\nLoad generation completed: %d successful, %d errors\n", successCount, errorCount)</span>
}

func testPrometheusMetrics(baseURL string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Get(baseURL + "/api/v1/metrics")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Metrics endpoint failed: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to read metrics response: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Status Code: %d\n", resp.StatusCode)
        fmt.Printf("Content-Type: %s\n", resp.Header.Get("Content-Type"))
        
        // Parse and show some key metrics
        metrics := string(body)
        fmt.Println("\nSample Metrics (first 1000 characters):")
        if len(metrics) &gt; 1000 </span><span class="cov0" title="0">{
                fmt.Printf("%s...\n", metrics[:1000])
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%s\n", metrics)
        }</span>
        
        // Count metric types
        <span class="cov0" title="0">lines := strings.Split(metrics, "\n")
        helpCount := 0
        typeCount := 0
        metricCount := 0
        
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "# HELP") </span><span class="cov0" title="0">{
                        helpCount++
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "# TYPE") </span><span class="cov0" title="0">{
                        typeCount++
                }</span> else<span class="cov0" title="0"> if line != "" &amp;&amp; !strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        metricCount++
                }</span>
        }
        
        <span class="cov0" title="0">fmt.Printf("\nMetrics Summary:\n")
        fmt.Printf("- Help lines: %d\n", helpCount)
        fmt.Printf("- Type definitions: %d\n", typeCount)
        fmt.Printf("- Metric values: %d\n", metricCount)</span>
}

func testEnhancedHealthCheck(baseURL string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Get(baseURL + "/api/v1/health")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Enhanced health check failed: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to read health response: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">var healthData map[string]interface{}
        if err := json.Unmarshal(body, &amp;healthData); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to parse health JSON: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Overall Status: %s\n", healthData["status"])
        
        // Show individual health checks
        if checks, ok := healthData["checks"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                fmt.Println("\nIndividual Health Checks:")
                for name, checkData := range checks </span><span class="cov0" title="0">{
                        if check, ok := checkData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                status := check["status"].(string)
                                message := check["message"].(string)
                                
                                icon := "✅"
                                if status == "degraded" </span><span class="cov0" title="0">{
                                        icon = "⚠️"
                                }</span> else<span class="cov0" title="0"> if status == "unhealthy" </span><span class="cov0" title="0">{
                                        icon = "❌"
                                }</span>
                                
                                <span class="cov0" title="0">fmt.Printf("%s %s: %s - %s\n", icon, name, status, message)
                                
                                // Show details if available
                                if details, ok := check["details"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        for key, value := range details </span><span class="cov0" title="0">{
                                                fmt.Printf("    %s: %v\n", key, value)
                                        }</span>
                                }
                        }
                }
        }
        
        // Show system info
        <span class="cov0" title="0">if systemInfo, ok := healthData["system_info"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                fmt.Println("\nSystem Information:")
                if goVersion, ok := systemInfo["go_version"].(string); ok </span><span class="cov0" title="0">{
                        fmt.Printf("- Go Version: %s\n", goVersion)
                }</span>
                <span class="cov0" title="0">if os, ok := systemInfo["os"].(string); ok </span><span class="cov0" title="0">{
                        fmt.Printf("- OS: %s\n", os)
                }</span>
                <span class="cov0" title="0">if numCPU, ok := systemInfo["num_cpu"].(float64); ok </span><span class="cov0" title="0">{
                        fmt.Printf("- CPU Cores: %.0f\n", numCPU)
                }</span>
                <span class="cov0" title="0">if memoryMB, ok := systemInfo["memory_mb"].(float64); ok </span><span class="cov0" title="0">{
                        fmt.Printf("- Memory Usage: %.0f MB\n", memoryMB)
                }</span>
                <span class="cov0" title="0">if goroutines, ok := systemInfo["num_goroutine"].(float64); ok </span><span class="cov0" title="0">{
                        fmt.Printf("- Goroutines: %.0f\n", goroutines)
                }</span>
        }
}

func testMonitoringDashboard(baseURL string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Get(baseURL + "/dashboard")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Dashboard access failed: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        fmt.Printf("Dashboard Status Code: %d\n", resp.StatusCode)
        fmt.Printf("Content-Type: %s\n", resp.Header.Get("Content-Type"))
        
        if resp.StatusCode == 200 </span><span class="cov0" title="0">{
                fmt.Println("✅ Dashboard is accessible!")
                fmt.Printf("🌐 Open your browser to: %s/dashboard\n", baseURL)
                
                body, _ := io.ReadAll(resp.Body)
                fmt.Printf("Dashboard size: %d bytes\n", len(body))
                
                // Check if it contains expected HTML elements
                content := string(body)
                if strings.Contains(content, "KVStore Monitoring") </span><span class="cov0" title="0">{
                        fmt.Println("✅ Dashboard contains monitoring content")
                }</span>
                <span class="cov0" title="0">if strings.Contains(content, "Health Status") </span><span class="cov0" title="0">{
                        fmt.Println("✅ Dashboard contains health status section")
                }</span>
                <span class="cov0" title="0">if strings.Contains(content, "System Statistics") </span><span class="cov0" title="0">{
                        fmt.Println("✅ Dashboard contains system statistics")
                }</span>
        } else<span class="cov0" title="0"> {
                body, _ := io.ReadAll(resp.Body)
                fmt.Printf("❌ Dashboard not available: %s\n", string(body))
        }</span>
}

</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "distributed-kvstore/internal/logging"
        "distributed-kvstore/internal/monitoring"
        "distributed-kvstore/internal/storage"

        "github.com/gorilla/mux"
)

// RESTHandler handles HTTP REST API requests
type RESTHandler struct {
        storage    storage.StorageEngine
        logger     *logging.Logger
        monitoring *monitoring.MonitoringService
}

// NewRESTHandler creates a new REST API handler
func NewRESTHandler(storageEngine storage.StorageEngine, logger *logging.Logger, monitoringService *monitoring.MonitoringService) *RESTHandler <span class="cov8" title="1">{
        return &amp;RESTHandler{
                storage:    storageEngine,
                logger:     logger,
                monitoring: monitoringService,
        }
}</span>

// Request/Response types for JSON handling

// PutRequest represents a PUT request
type PutRequest struct {
        Value      string `json:"value"`
        TTLSeconds *int64 `json:"ttl_seconds,omitempty"`
}

// PutResponse represents a PUT response
type PutResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

// GetResponse represents a GET response
type GetResponse struct {
        Found     bool   `json:"found"`
        Value     string `json:"value,omitempty"`
        CreatedAt int64  `json:"created_at,omitempty"`
        ExpiresAt int64  `json:"expires_at,omitempty"`
        Error     string `json:"error,omitempty"`
}

// DeleteResponse represents a DELETE response
type DeleteResponse struct {
        Success bool   `json:"success"`
        Existed bool   `json:"existed"`
        Error   string `json:"error,omitempty"`
}

// ExistsResponse represents an EXISTS response
type ExistsResponse struct {
        Exists bool   `json:"exists"`
        Error  string `json:"error,omitempty"`
}

// KeyValue represents a key-value pair in responses
type KeyValue struct {
        Key       string `json:"key"`
        Value     string `json:"value"`
        CreatedAt int64  `json:"created_at"`
        ExpiresAt int64  `json:"expires_at,omitempty"`
}

// ListResponse represents a LIST response
type ListResponse struct {
        Items      []KeyValue `json:"items"`
        Count      int        `json:"count"`
        HasMore    bool       `json:"has_more"`
        NextCursor string     `json:"next_cursor,omitempty"`
        Error      string     `json:"error,omitempty"`
}

// ListKeysResponse represents a LIST KEYS response
type ListKeysResponse struct {
        Keys       []string `json:"keys"`
        Count      int      `json:"count"`
        HasMore    bool     `json:"has_more"`
        NextCursor string   `json:"next_cursor,omitempty"`
        Error      string   `json:"error,omitempty"`
}

// BatchPutRequest represents a batch PUT request
type BatchPutRequest struct {
        Items []BatchPutItem `json:"items"`
}

// BatchPutItem represents a single item in batch PUT
type BatchPutItem struct {
        Key        string `json:"key"`
        Value      string `json:"value"`
        TTLSeconds *int64 `json:"ttl_seconds,omitempty"`
}

// BatchGetRequest represents a batch GET request
type BatchGetRequest struct {
        Keys []string `json:"keys"`
}

// BatchDeleteRequest represents a batch DELETE request
type BatchDeleteRequest struct {
        Keys []string `json:"keys"`
}

// BatchResponse represents a batch operation response
type BatchResponse struct {
        SuccessCount int                `json:"success_count"`
        ErrorCount   int                `json:"error_count"`
        TotalCount   int                `json:"total_count"`
        SuccessRate  float64            `json:"success_rate"`
        Results      []BatchItemResult  `json:"results,omitempty"`
        Errors       []BatchItemError   `json:"errors,omitempty"`
}

// BatchItemResult represents a single result in batch GET
type BatchItemResult struct {
        Key       string `json:"key"`
        Found     bool   `json:"found"`
        Value     string `json:"value,omitempty"`
        CreatedAt int64  `json:"created_at,omitempty"`
        ExpiresAt int64  `json:"expires_at,omitempty"`
}

// BatchItemError represents an error in batch operations
type BatchItemError struct {
        Key   string `json:"key"`
        Error string `json:"error"`
}

// HealthResponse represents a health check response
type HealthResponse struct {
        Healthy       bool   `json:"healthy"`
        Status        string `json:"status"`
        UptimeSeconds int64  `json:"uptime_seconds"`
        Version       string `json:"version"`
        Timestamp     int64  `json:"timestamp"`
}

// StatsResponse represents a stats response
type StatsResponse struct {
        TotalKeys int64             `json:"total_keys"`
        TotalSize int64             `json:"total_size"`
        LSMSize   int64             `json:"lsm_size"`
        VLogSize  int64             `json:"vlog_size"`
        Details   map[string]string `json:"details,omitempty"`
        Error     string            `json:"error,omitempty"`
}

// ErrorResponse represents a generic error response
type ErrorResponse struct {
        Error   string `json:"error"`
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// PUT /api/v1/kv/{key}
func (h *RESTHandler) PutKey(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        start := time.Now()
        ctx := r.Context()
        vars := mux.Vars(r)
        key := vars["key"]

        if key == "" </span><span class="cov8" title="1">{
                h.logger.WarnContext(ctx, "PUT request with empty key")
                h.writeErrorResponse(w, http.StatusBadRequest, "Key cannot be empty")
                return
        }</span>

        <span class="cov8" title="1">var req PutRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.WarnContext(ctx, "PUT request with invalid JSON", "error", err.Error())
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(ctx, "Processing PUT request",
                "key", key,
                "value_length", len(req.Value),
                "ttl_seconds", req.TTLSeconds,
        )

        err := h.storage.Put([]byte(key), []byte(req.Value))
        duration := time.Since(start)
        
        if err != nil </span><span class="cov0" title="0">{
                h.logger.DatabaseOperation(ctx, "put", key, duration, err)
                h.writeJSONResponse(w, http.StatusInternalServerError, PutResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">h.logger.DatabaseOperation(ctx, "put", key, duration, nil)
        h.writeJSONResponse(w, http.StatusOK, PutResponse{
                Success: true,
        })</span>
}

// GET /api/v1/kv/{key}
func (h *RESTHandler) GetKey(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        key := vars["key"]

        if key == "" </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Key cannot be empty")
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(r.Context(), "Processing GET request",
                "method", "GET",
                "key", key,
        )

        value, err := h.storage.Get([]byte(key))
        if err != nil </span><span class="cov8" title="1">{
                if err == storage.ErrKeyNotFound </span><span class="cov8" title="1">{
                        h.writeJSONResponse(w, http.StatusNotFound, GetResponse{
                                Found: false,
                        })
                        return
                }</span>

                <span class="cov0" title="0">h.logger.WithError(err).WithField("key", key).Error("Failed to get key")
                h.writeJSONResponse(w, http.StatusInternalServerError, GetResponse{
                        Found: false,
                        Error: err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, GetResponse{
                Found:     true,
                Value:     string(value),
                CreatedAt: time.Now().Unix(),
        })</span>
}

// DELETE /api/v1/kv/{key}
func (h *RESTHandler) DeleteKey(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        key := vars["key"]

        if key == "" </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Key cannot be empty")
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(r.Context(), "Processing DELETE request",
                "method", "DELETE",
                "key", key,
        )

        existed, err := h.storage.Exists([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).WithField("key", key).Error("Failed to check key existence")
                h.writeJSONResponse(w, http.StatusInternalServerError, DeleteResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">err = h.storage.Delete([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).WithField("key", key).Error("Failed to delete key")
                h.writeJSONResponse(w, http.StatusInternalServerError, DeleteResponse{
                        Success: false,
                        Existed: existed,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, DeleteResponse{
                Success: true,
                Existed: existed,
        })</span>
}

// HEAD /api/v1/kv/{key}
func (h *RESTHandler) ExistsKey(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        key := vars["key"]

        if key == "" </span><span class="cov8" title="1">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Key cannot be empty")
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(r.Context(), "Processing EXISTS request",
                "method", "HEAD",
                "key", key,
        )

        exists, err := h.storage.Exists([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).WithField("key", key).Error("Failed to check key existence")
                h.writeJSONResponse(w, http.StatusInternalServerError, ExistsResponse{
                        Exists: false,
                        Error:  err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                h.writeJSONResponse(w, http.StatusOK, ExistsResponse{
                        Exists: true,
                })
        }</span> else<span class="cov8" title="1"> {
                h.writeJSONResponse(w, http.StatusNotFound, ExistsResponse{
                        Exists: false,
                })
        }</span>
}

// GET /api/v1/kv?prefix={prefix}&amp;limit={limit}&amp;cursor={cursor}
func (h *RESTHandler) ListKeys(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        prefix := query.Get("prefix")
        limitStr := query.Get("limit")
        cursor := query.Get("cursor")
        keysOnly := query.Get("keys_only") == "true"

        limit := 100 // default limit
        if limitStr != "" </span><span class="cov8" title="1">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }

        <span class="cov8" title="1">h.logger.DebugContext(r.Context(), "Processing LIST request",
                "method", "GET",
                "prefix", prefix,
                "limit", limit,
                "cursor", cursor,
                "keys_only", keysOnly,
        )

        data, err := h.storage.List([]byte(prefix))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).WithField("prefix", prefix).Error("Failed to list keys")
                if keysOnly </span><span class="cov0" title="0">{
                        h.writeJSONResponse(w, http.StatusInternalServerError, ListKeysResponse{
                                Error: err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        h.writeJSONResponse(w, http.StatusInternalServerError, ListResponse{
                                Error: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if keysOnly </span><span class="cov8" title="1">{
                h.handleListKeysResponse(w, data, limit)
        }</span> else<span class="cov8" title="1"> {
                h.handleListResponse(w, data, limit)
        }</span>
}

// POST /api/v1/kv/batch/put
func (h *RESTHandler) BatchPut(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req BatchPutRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(r.Context(), "Processing batch PUT request",
                "method", "BATCH_PUT",
                "count", len(req.Items),
        )

        successCount := 0
        errorCount := 0
        var errors []BatchItemError

        for _, item := range req.Items </span><span class="cov8" title="1">{
                if item.Key == "" </span><span class="cov8" title="1">{
                        errorCount++
                        errors = append(errors, BatchItemError{
                                Key:   item.Key,
                                Error: "key cannot be empty",
                        })
                        continue</span>
                }

                <span class="cov8" title="1">err := h.storage.Put([]byte(item.Key), []byte(item.Value))
                if err != nil </span><span class="cov0" title="0">{
                        errorCount++
                        errors = append(errors, BatchItemError{
                                Key:   item.Key,
                                Error: err.Error(),
                        })
                        h.logger.WithError(err).WithField("key", item.Key).Error("Failed to put key in batch")
                }</span> else<span class="cov8" title="1"> {
                        successCount++
                }</span>
        }

        <span class="cov8" title="1">totalCount := successCount + errorCount
        successRate := 0.0
        if totalCount &gt; 0 </span><span class="cov8" title="1">{
                successRate = float64(successCount) / float64(totalCount) * 100
        }</span>

        <span class="cov8" title="1">statusCode := http.StatusOK
        if errorCount &gt; 0 </span><span class="cov8" title="1">{
                if successCount == 0 </span><span class="cov0" title="0">{
                        statusCode = http.StatusBadRequest
                }</span> else<span class="cov8" title="1"> {
                        statusCode = http.StatusPartialContent
                }</span>
        }

        <span class="cov8" title="1">h.writeJSONResponse(w, statusCode, BatchResponse{
                SuccessCount: successCount,
                ErrorCount:   errorCount,
                TotalCount:   totalCount,
                SuccessRate:  successRate,
                Errors:       errors,
        })</span>
}

// POST /api/v1/kv/batch/get
func (h *RESTHandler) BatchGet(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req BatchGetRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(r.Context(), "Processing batch GET request",
                "method", "BATCH_GET",
                "count", len(req.Keys),
        )

        var results []BatchItemResult

        for _, key := range req.Keys </span><span class="cov8" title="1">{
                if key == "" </span><span class="cov0" title="0">{
                        results = append(results, BatchItemResult{
                                Key:   key,
                                Found: false,
                        })
                        continue</span>
                }

                <span class="cov8" title="1">value, err := h.storage.Get([]byte(key))
                if err != nil </span><span class="cov8" title="1">{
                        if err == storage.ErrKeyNotFound </span><span class="cov8" title="1">{
                                results = append(results, BatchItemResult{
                                        Key:   key,
                                        Found: false,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                h.logger.WithError(err).WithField("key", key).Error("Failed to get key in batch")
                                h.writeJSONResponse(w, http.StatusInternalServerError, BatchResponse{
                                        Errors: []BatchItemError{{Key: key, Error: err.Error()}},
                                })
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        results = append(results, BatchItemResult{
                                Key:       key,
                                Found:     true,
                                Value:     string(value),
                                CreatedAt: time.Now().Unix(),
                        })
                }</span>
        }

        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, BatchResponse{
                SuccessCount: len(req.Keys),
                ErrorCount:   0,
                TotalCount:   len(req.Keys),
                SuccessRate:  100.0,
                Results:      results,
        })</span>
}

// POST /api/v1/kv/batch/delete
func (h *RESTHandler) BatchDelete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req BatchDeleteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, "Invalid JSON request")
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(r.Context(), "Processing batch DELETE request",
                "method", "BATCH_DELETE",
                "count", len(req.Keys),
        )

        successCount := 0
        errorCount := 0
        var errors []BatchItemError

        for _, key := range req.Keys </span><span class="cov0" title="0">{
                if key == "" </span><span class="cov0" title="0">{
                        errorCount++
                        errors = append(errors, BatchItemError{
                                Key:   key,
                                Error: "key cannot be empty",
                        })
                        continue</span>
                }

                <span class="cov0" title="0">err := h.storage.Delete([]byte(key))
                if err != nil </span><span class="cov0" title="0">{
                        errorCount++
                        errors = append(errors, BatchItemError{
                                Key:   key,
                                Error: err.Error(),
                        })
                        h.logger.WithError(err).WithField("key", key).Error("Failed to delete key in batch")
                }</span> else<span class="cov0" title="0"> {
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">totalCount := successCount + errorCount
        successRate := 0.0
        if totalCount &gt; 0 </span><span class="cov0" title="0">{
                successRate = float64(successCount) / float64(totalCount) * 100
        }</span>

        <span class="cov0" title="0">statusCode := http.StatusOK
        if errorCount &gt; 0 </span><span class="cov0" title="0">{
                if successCount == 0 </span><span class="cov0" title="0">{
                        statusCode = http.StatusBadRequest
                }</span> else<span class="cov0" title="0"> {
                        statusCode = http.StatusPartialContent
                }</span>
        }

        <span class="cov0" title="0">h.writeJSONResponse(w, statusCode, BatchResponse{
                SuccessCount: successCount,
                ErrorCount:   errorCount,
                TotalCount:   totalCount,
                SuccessRate:  successRate,
                Errors:       errors,
        })</span>
}

// GET /api/v1/health
func (h *RESTHandler) Health(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.logger.Debug("Processing health check request")

        h.writeJSONResponse(w, http.StatusOK, HealthResponse{
                Healthy:       true,
                Status:        "healthy",
                UptimeSeconds: int64(time.Since(time.Now()).Seconds()),
                Version:       "1.0.0",
                Timestamp:     time.Now().Unix(),
        })
}</span>

// GET /api/v1/stats
func (h *RESTHandler) Stats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()
        includeDetails := query.Get("details") == "true"

        h.logger.WithField("include_details", includeDetails).Debug("Processing stats request")

        stats := h.storage.Stats()

        response := StatsResponse{
                TotalSize: int64(stats["total_size"].(int64)),
                LSMSize:   int64(stats["lsm_size"].(int64)),
                VLogSize:  int64(stats["vlog_size"].(int64)),
        }

        if includeDetails </span><span class="cov8" title="1">{
                details := make(map[string]string)
                for key, value := range stats </span><span class="cov8" title="1">{
                        details[key] = fmt.Sprintf("%v", value)
                }</span>
                <span class="cov8" title="1">response.Details = details</span>
        }

        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, response)</span>
}

// Helper methods

func (h *RESTHandler) handleListResponse(w http.ResponseWriter, data map[string][]byte, limit int) <span class="cov8" title="1">{
        var items []KeyValue
        count := 0

        for key, value := range data </span><span class="cov8" title="1">{
                if limit &gt; 0 &amp;&amp; count &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">items = append(items, KeyValue{
                        Key:       key,
                        Value:     string(value),
                        CreatedAt: time.Now().Unix(),
                })
                count++</span>
        }

        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, ListResponse{
                Items:   items,
                Count:   len(items),
                HasMore: limit &gt; 0 &amp;&amp; len(data) &gt; limit,
        })</span>
}

func (h *RESTHandler) handleListKeysResponse(w http.ResponseWriter, data map[string][]byte, limit int) <span class="cov8" title="1">{
        var keys []string
        count := 0

        for key := range data </span><span class="cov8" title="1">{
                if limit &gt; 0 &amp;&amp; count &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">keys = append(keys, key)
                count++</span>
        }

        <span class="cov8" title="1">h.writeJSONResponse(w, http.StatusOK, ListKeysResponse{
                Keys:    keys,
                Count:   len(keys),
                HasMore: limit &gt; 0 &amp;&amp; len(data) &gt; limit,
        })</span>
}

func (h *RESTHandler) writeJSONResponse(w http.ResponseWriter, statusCode int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).Error("Failed to encode JSON response")
        }</span>
}

func (h *RESTHandler) writeErrorResponse(w http.ResponseWriter, statusCode int, message string) <span class="cov8" title="1">{
        h.writeJSONResponse(w, statusCode, ErrorResponse{
                Error:   message,
                Code:    statusCode,
                Message: http.StatusText(statusCode),
        })
}</span>

// Note: Logging middleware is now handled by the logging package

// CORS middleware
func (h *RESTHandler) CORSMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, HEAD, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "net/http"

        "distributed-kvstore/internal/logging"

        "github.com/gorilla/mux"
)

// SetupRoutes configures all REST API routes
func (h *RESTHandler) SetupRoutes() *mux.Router <span class="cov8" title="1">{
        router := mux.NewRouter()

        // Apply middleware
        router.Use(logging.CorrelationIDMiddleware(h.logger))
        router.Use(logging.LoggingMiddleware(h.logger))
        if h.monitoring != nil </span><span class="cov0" title="0">{
                router.Use(h.monitoring.MonitoringMiddleware)
        }</span>
        <span class="cov8" title="1">router.Use(h.CORSMiddleware)

        // API version 1
        v1 := router.PathPrefix("/api/v1").Subrouter()

        // Key-value operations
        v1.HandleFunc("/kv/{key}", h.PutKey).Methods(http.MethodPut)
        v1.HandleFunc("/kv/{key}", h.GetKey).Methods(http.MethodGet)
        v1.HandleFunc("/kv/{key}", h.DeleteKey).Methods(http.MethodDelete)
        v1.HandleFunc("/kv/{key}", h.ExistsKey).Methods(http.MethodHead)

        // List operations
        v1.HandleFunc("/kv", h.ListKeys).Methods(http.MethodGet)

        // Batch operations
        v1.HandleFunc("/kv/batch/put", h.BatchPut).Methods(http.MethodPost)
        v1.HandleFunc("/kv/batch/get", h.BatchGet).Methods(http.MethodPost)
        v1.HandleFunc("/kv/batch/delete", h.BatchDelete).Methods(http.MethodPost)

        // Health and stats (enhanced)
        if h.monitoring != nil </span><span class="cov0" title="0">{
                v1.HandleFunc("/health", h.monitoring.GetHealthHandler()).Methods(http.MethodGet)
        }</span> else<span class="cov8" title="1"> {
                v1.HandleFunc("/health", h.Health).Methods(http.MethodGet)
        }</span>
        <span class="cov8" title="1">v1.HandleFunc("/stats", h.Stats).Methods(http.MethodGet)
        
        // Monitoring endpoints
        if h.monitoring != nil </span><span class="cov0" title="0">{
                v1.Handle("/metrics", h.monitoring.GetMetricsHandler()).Methods(http.MethodGet)
                router.Handle("/dashboard", h.monitoring.GetDashboardHandler()).Methods(http.MethodGet)
                router.Handle("/dashboard/", h.monitoring.GetDashboardHandler()).Methods(http.MethodGet)
        }</span>

        // Handle OPTIONS for all routes (CORS preflight)
        <span class="cov8" title="1">v1.Methods(http.MethodOptions).HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
        }</span>)

        // Root endpoints
        <span class="cov8" title="1">if h.monitoring != nil </span><span class="cov0" title="0">{
                router.HandleFunc("/health", h.monitoring.GetHealthHandler()).Methods(http.MethodGet)
        }</span> else<span class="cov8" title="1"> {
                router.HandleFunc("/health", h.Health).Methods(http.MethodGet)
        }</span>
        <span class="cov8" title="1">router.HandleFunc("/", h.RootHandler).Methods(http.MethodGet)

        return router</span>
}

// RootHandler handles requests to the root path
func (h *RESTHandler) RootHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        response := map[string]interface{}{
                "service": "Distributed Key-Value Store",
                "version": "1.0.0",
                "api_version": "v1",
                "endpoints": map[string]interface{}{
                        "health": "/health or /api/v1/health",
                        "stats":  "/api/v1/stats",
                        "kv_operations": map[string]string{
                                "put":    "PUT /api/v1/kv/{key}",
                                "get":    "GET /api/v1/kv/{key}",
                                "delete": "DELETE /api/v1/kv/{key}",
                                "exists": "HEAD /api/v1/kv/{key}",
                                "list":   "GET /api/v1/kv?prefix={prefix}&amp;limit={limit}&amp;keys_only={true|false}",
                        },
                        "batch_operations": map[string]string{
                                "batch_put":    "POST /api/v1/kv/batch/put",
                                "batch_get":    "POST /api/v1/kv/batch/get",
                                "batch_delete": "POST /api/v1/kv/batch/delete",
                        },
                },
                "documentation": "/api/v1/docs",
        }

        h.writeJSONResponse(w, http.StatusOK, response)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

type Config struct {
        Server   ServerConfig   `yaml:"server" json:"server"`
        Storage  StorageConfig  `yaml:"storage" json:"storage"`
        Cluster  ClusterConfig  `yaml:"cluster" json:"cluster"`
        Logging  LoggingConfig  `yaml:"logging" json:"logging"`
        Metrics  MetricsConfig  `yaml:"metrics" json:"metrics"`
        Security SecurityConfig `yaml:"security" json:"security"`
}

type ServerConfig struct {
        Host         string        `yaml:"host" json:"host"`
        Port         int           `yaml:"port" json:"port"`
        GRPCPort     int           `yaml:"grpc_port" json:"grpc_port"`
        ReadTimeout  time.Duration `yaml:"read_timeout" json:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout" json:"write_timeout"`
        IdleTimeout  time.Duration `yaml:"idle_timeout" json:"idle_timeout"`
        MaxBodySize  int64         `yaml:"max_body_size" json:"max_body_size"`
}

type StorageConfig struct {
        Engine      string        `yaml:"engine" json:"engine"`
        DataPath    string        `yaml:"data_path" json:"data_path"`
        InMemory    bool          `yaml:"in_memory" json:"in_memory"`
        SyncWrites  bool          `yaml:"sync_writes" json:"sync_writes"`
        ValueLogGC  bool          `yaml:"value_log_gc" json:"value_log_gc"`
        GCInterval  time.Duration `yaml:"gc_interval" json:"gc_interval"`
        BackupPath  string        `yaml:"backup_path" json:"backup_path"`
        MaxFileSize int64         `yaml:"max_file_size" json:"max_file_size"`
}

type ClusterConfig struct {
        NodeID        string        `yaml:"node_id" json:"node_id"`
        Peers         []string      `yaml:"peers" json:"peers"`
        RaftPort      int           `yaml:"raft_port" json:"raft_port"`
        RaftDir       string        `yaml:"raft_dir" json:"raft_dir"`
        SnapshotCount int           `yaml:"snapshot_count" json:"snapshot_count"`
        HeartbeatTick time.Duration `yaml:"heartbeat_tick" json:"heartbeat_tick"`
        ElectionTick  time.Duration `yaml:"election_tick" json:"election_tick"`
        MaxSnapshots  int           `yaml:"max_snapshots" json:"max_snapshots"`
        JoinTimeout   time.Duration `yaml:"join_timeout" json:"join_timeout"`
}

type LoggingConfig struct {
        Level                 string `yaml:"level" json:"level"`
        Format                string `yaml:"format" json:"format"`
        Output                string `yaml:"output" json:"output"`
        EnableRequestTracing  bool   `yaml:"enable_request_tracing" json:"enable_request_tracing"`
        EnableCorrelationIDs  bool   `yaml:"enable_correlation_ids" json:"enable_correlation_ids"`
        EnableDatabaseLogging bool   `yaml:"enable_database_logging" json:"enable_database_logging"`
        EnablePerformanceLog  bool   `yaml:"enable_performance_log" json:"enable_performance_log"`
        LogSampling           int    `yaml:"log_sampling" json:"log_sampling"` // 0 = no sampling, N = sample every Nth log
}

type MetricsConfig struct {
        Enabled bool `yaml:"enabled" json:"enabled"`
        Port    int  `yaml:"port" json:"port"`
        Path    string `yaml:"path" json:"path"`
}

type SecurityConfig struct {
        TLSEnabled  bool   `yaml:"tls_enabled" json:"tls_enabled"`
        CertFile    string `yaml:"cert_file" json:"cert_file"`
        KeyFile     string `yaml:"key_file" json:"key_file"`
        CAFile      string `yaml:"ca_file" json:"ca_file"`
        AuthEnabled bool   `yaml:"auth_enabled" json:"auth_enabled"`
        AuthToken   string `yaml:"auth_token" json:"auth_token"`
}

func Load(configPath string) (*Config, error) <span class="cov8" title="1">{
        config := DefaultConfig()
        
        if configPath != "" </span><span class="cov8" title="1">{
                if err := loadFromFile(config, configPath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load config from file: %w", err)
                }</span>
        }
        
        <span class="cov8" title="1">loadFromEnvironment(config)
        
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>
        
        <span class="cov8" title="1">return config, nil</span>
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:         "localhost",
                        Port:         8080,
                        GRPCPort:     9090,
                        ReadTimeout:  30 * time.Second,
                        WriteTimeout: 30 * time.Second,
                        IdleTimeout:  120 * time.Second,
                        MaxBodySize:  1024 * 1024, // 1MB
                },
                Storage: StorageConfig{
                        Engine:      "badger",
                        DataPath:    "./data/badger",
                        InMemory:    false,
                        SyncWrites:  false,
                        ValueLogGC:  true,
                        GCInterval:  5 * time.Minute,
                        BackupPath:  "./backups",
                        MaxFileSize: 64 * 1024 * 1024, // 64MB
                },
                Cluster: ClusterConfig{
                        NodeID:        "node1",
                        Peers:         []string{},
                        RaftPort:      7000,
                        RaftDir:       "./data/raft",
                        SnapshotCount: 10000,
                        HeartbeatTick: 1 * time.Second,
                        ElectionTick:  10 * time.Second,
                        MaxSnapshots:  5,
                        JoinTimeout:   10 * time.Second,
                },
                Logging: LoggingConfig{
                        Level:                 "info",
                        Format:                "json",
                        Output:                "stdout",
                        EnableRequestTracing:  true,
                        EnableCorrelationIDs:  true,
                        EnableDatabaseLogging: false,
                        EnablePerformanceLog:  false,
                        LogSampling:           0,
                },
                Metrics: MetricsConfig{
                        Enabled: true,
                        Port:    2112,
                        Path:    "/metrics",
                },
                Security: SecurityConfig{
                        TLSEnabled:  false,
                        CertFile:    "",
                        KeyFile:     "",
                        CAFile:      "",
                        AuthEnabled: false,
                        AuthToken:   "",
                },
        }
}</span>

func loadFromFile(config *Config, configPath string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>
        
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(configPath))
        
        switch ext </span>{
        case ".yaml", ".yml":<span class="cov8" title="1">
                if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal YAML config: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported config file format: %s", ext)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func loadFromEnvironment(config *Config) <span class="cov8" title="1">{
        // Server configuration
        if host := os.Getenv("KV_SERVER_HOST"); host != "" </span><span class="cov8" title="1">{
                config.Server.Host = host
        }</span>
        <span class="cov8" title="1">if port := os.Getenv("KV_SERVER_PORT"); port != "" </span><span class="cov8" title="1">{
                if p, err := strconv.Atoi(port); err == nil </span><span class="cov8" title="1">{
                        config.Server.Port = p
                }</span>
        }
        <span class="cov8" title="1">if grpcPort := os.Getenv("KV_SERVER_GRPC_PORT"); grpcPort != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(grpcPort); err == nil </span><span class="cov0" title="0">{
                        config.Server.GRPCPort = p
                }</span>
        }
        
        // Storage configuration
        <span class="cov8" title="1">if engine := os.Getenv("KV_STORAGE_ENGINE"); engine != "" </span><span class="cov8" title="1">{
                config.Storage.Engine = engine
        }</span>
        <span class="cov8" title="1">if dataPath := os.Getenv("KV_STORAGE_DATA_PATH"); dataPath != "" </span><span class="cov0" title="0">{
                config.Storage.DataPath = dataPath
        }</span>
        <span class="cov8" title="1">if inMemory := os.Getenv("KV_STORAGE_IN_MEMORY"); inMemory != "" </span><span class="cov0" title="0">{
                if b, err := strconv.ParseBool(inMemory); err == nil </span><span class="cov0" title="0">{
                        config.Storage.InMemory = b
                }</span>
        }
        <span class="cov8" title="1">if syncWrites := os.Getenv("KV_STORAGE_SYNC_WRITES"); syncWrites != "" </span><span class="cov0" title="0">{
                if b, err := strconv.ParseBool(syncWrites); err == nil </span><span class="cov0" title="0">{
                        config.Storage.SyncWrites = b
                }</span>
        }
        
        // Cluster configuration
        <span class="cov8" title="1">if nodeID := os.Getenv("KV_CLUSTER_NODE_ID"); nodeID != "" </span><span class="cov8" title="1">{
                config.Cluster.NodeID = nodeID
        }</span>
        <span class="cov8" title="1">if peers := os.Getenv("KV_CLUSTER_PEERS"); peers != "" </span><span class="cov0" title="0">{
                config.Cluster.Peers = strings.Split(peers, ",")
        }</span>
        <span class="cov8" title="1">if raftPort := os.Getenv("KV_CLUSTER_RAFT_PORT"); raftPort != "" </span><span class="cov8" title="1">{
                if p, err := strconv.Atoi(raftPort); err == nil </span><span class="cov8" title="1">{
                        config.Cluster.RaftPort = p
                }</span>
        }
        
        // Logging configuration
        <span class="cov8" title="1">if level := os.Getenv("KV_LOG_LEVEL"); level != "" </span><span class="cov8" title="1">{
                config.Logging.Level = level
        }</span>
        <span class="cov8" title="1">if format := os.Getenv("KV_LOG_FORMAT"); format != "" </span><span class="cov0" title="0">{
                config.Logging.Format = format
        }</span>
        
        // Metrics configuration
        <span class="cov8" title="1">if enabled := os.Getenv("KV_METRICS_ENABLED"); enabled != "" </span><span class="cov0" title="0">{
                if b, err := strconv.ParseBool(enabled); err == nil </span><span class="cov0" title="0">{
                        config.Metrics.Enabled = b
                }</span>
        }
        <span class="cov8" title="1">if port := os.Getenv("KV_METRICS_PORT"); port != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(port); err == nil </span><span class="cov0" title="0">{
                        config.Metrics.Port = p
                }</span>
        }
        
        // Security configuration
        <span class="cov8" title="1">if tlsEnabled := os.Getenv("KV_SECURITY_TLS_ENABLED"); tlsEnabled != "" </span><span class="cov0" title="0">{
                if b, err := strconv.ParseBool(tlsEnabled); err == nil </span><span class="cov0" title="0">{
                        config.Security.TLSEnabled = b
                }</span>
        }
        <span class="cov8" title="1">if certFile := os.Getenv("KV_SECURITY_CERT_FILE"); certFile != "" </span><span class="cov0" title="0">{
                config.Security.CertFile = certFile
        }</span>
        <span class="cov8" title="1">if keyFile := os.Getenv("KV_SECURITY_KEY_FILE"); keyFile != "" </span><span class="cov0" title="0">{
                config.Security.KeyFile = keyFile
        }</span>
        <span class="cov8" title="1">if authToken := os.Getenv("KV_SECURITY_AUTH_TOKEN"); authToken != "" </span><span class="cov0" title="0">{
                config.Security.AuthToken = authToken
        }</span>
}

func (c *Config) Validate() error <span class="cov8" title="1">{
        // Server validation
        if c.Server.Port &lt;= 0 || c.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server port: %d", c.Server.Port)
        }</span>
        <span class="cov8" title="1">if c.Server.GRPCPort &lt;= 0 || c.Server.GRPCPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid gRPC port: %d", c.Server.GRPCPort)
        }</span>
        <span class="cov8" title="1">if c.Server.Port == c.Server.GRPCPort </span><span class="cov8" title="1">{
                return fmt.Errorf("server port and gRPC port cannot be the same: %d", c.Server.Port)
        }</span>
        <span class="cov8" title="1">if c.Server.ReadTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("read timeout must be positive")
        }</span>
        <span class="cov8" title="1">if c.Server.WriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("write timeout must be positive")
        }</span>
        <span class="cov8" title="1">if c.Server.MaxBodySize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max body size must be positive")
        }</span>
        
        // Storage validation
        <span class="cov8" title="1">if c.Storage.Engine == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("storage engine cannot be empty")
        }</span>
        <span class="cov8" title="1">if !c.Storage.InMemory &amp;&amp; c.Storage.DataPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("data path cannot be empty when not using in-memory storage")
        }</span>
        <span class="cov8" title="1">if c.Storage.GCInterval &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("GC interval must be positive")
        }</span>
        <span class="cov8" title="1">if c.Storage.MaxFileSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max file size must be positive")
        }</span>
        
        // Cluster validation
        <span class="cov8" title="1">if c.Cluster.NodeID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("node ID cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.Cluster.RaftPort &lt;= 0 || c.Cluster.RaftPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid raft port: %d", c.Cluster.RaftPort)
        }</span>
        <span class="cov8" title="1">if c.Cluster.RaftPort == c.Server.Port || c.Cluster.RaftPort == c.Server.GRPCPort </span><span class="cov0" title="0">{
                return fmt.Errorf("raft port conflicts with server ports")
        }</span>
        <span class="cov8" title="1">if c.Cluster.SnapshotCount &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshot count must be positive")
        }</span>
        <span class="cov8" title="1">if c.Cluster.HeartbeatTick &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("heartbeat tick must be positive")
        }</span>
        <span class="cov8" title="1">if c.Cluster.ElectionTick &lt;= c.Cluster.HeartbeatTick </span><span class="cov8" title="1">{
                return fmt.Errorf("election tick must be greater than heartbeat tick")
        }</span>
        <span class="cov8" title="1">if c.Cluster.MaxSnapshots &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max snapshots must be positive")
        }</span>
        
        // Logging validation
        <span class="cov8" title="1">validLevels := map[string]bool{
                "debug": true, "info": true, "warn": true, "error": true, "fatal": true,
        }
        if !validLevels[strings.ToLower(c.Logging.Level)] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log level: %s", c.Logging.Level)
        }</span>
        <span class="cov8" title="1">validFormats := map[string]bool{
                "json": true, "text": true, "console": true,
        }
        if !validFormats[strings.ToLower(c.Logging.Format)] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log format: %s", c.Logging.Format)
        }</span>
        
        // Metrics validation
        <span class="cov8" title="1">if c.Metrics.Enabled </span><span class="cov8" title="1">{
                if c.Metrics.Port &lt;= 0 || c.Metrics.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid metrics port: %d", c.Metrics.Port)
                }</span>
                <span class="cov8" title="1">if c.Metrics.Port == c.Server.Port || c.Metrics.Port == c.Server.GRPCPort || c.Metrics.Port == c.Cluster.RaftPort </span><span class="cov0" title="0">{
                        return fmt.Errorf("metrics port conflicts with other ports")
                }</span>
                <span class="cov8" title="1">if c.Metrics.Path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("metrics path cannot be empty when metrics are enabled")
                }</span>
        }
        
        // Security validation
        <span class="cov8" title="1">if c.Security.TLSEnabled </span><span class="cov0" title="0">{
                if c.Security.CertFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("cert file cannot be empty when TLS is enabled")
                }</span>
                <span class="cov0" title="0">if c.Security.KeyFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("key file cannot be empty when TLS is enabled")
                }</span>
                <span class="cov0" title="0">if _, err := os.Stat(c.Security.CertFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("cert file does not exist: %s", c.Security.CertFile)
                }</span>
                <span class="cov0" title="0">if _, err := os.Stat(c.Security.KeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("key file does not exist: %s", c.Security.KeyFile)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (c *Config) GetStorageConfig() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "data_path":   c.Storage.DataPath,
                "in_memory":   c.Storage.InMemory,
                "sync_writes": c.Storage.SyncWrites,
                "value_log_gc": c.Storage.ValueLogGC,
                "gc_interval": c.Storage.GCInterval,
        }
}</span>

func (c *Config) String() string <span class="cov8" title="1">{
        data, _ := yaml.Marshal(c)
        return string(data)
}</pre>
		
		<pre class="file" id="file9" style="display: none">package logging

import (
        "distributed-kvstore/internal/config"
)

// DevelopmentLoggingConfig returns logging configuration optimized for development
func DevelopmentLoggingConfig() config.LoggingConfig <span class="cov8" title="1">{
        return config.LoggingConfig{
                Level:                 "debug",
                Format:                "console", // Human-readable format for development
                Output:                "stdout",
                EnableRequestTracing:  true,
                EnableCorrelationIDs:  true,
                EnableDatabaseLogging: true,  // Enable detailed database logging in dev
                EnablePerformanceLog:  true,  // Enable performance logging in dev
                LogSampling:           0,     // No sampling in development
        }
}</span>

// ProductionLoggingConfig returns logging configuration optimized for production
func ProductionLoggingConfig() config.LoggingConfig <span class="cov8" title="1">{
        return config.LoggingConfig{
                Level:                 "info",
                Format:                "json", // Machine-readable format for production
                Output:                "stdout",
                EnableRequestTracing:  true,
                EnableCorrelationIDs:  true,
                EnableDatabaseLogging: false, // Reduce noise in production
                EnablePerformanceLog:  false, // Reduce noise in production
                LogSampling:           0,     // No sampling by default, can be configured
        }
}</span>

// TestLoggingConfig returns logging configuration optimized for testing
func TestLoggingConfig() config.LoggingConfig <span class="cov8" title="1">{
        return config.LoggingConfig{
                Level:                 "error", // Minimal logging during tests
                Format:                "json",
                Output:                "stderr",
                EnableRequestTracing:  false,
                EnableCorrelationIDs:  false,
                EnableDatabaseLogging: false,
                EnablePerformanceLog:  false,
                LogSampling:           0,
        }
}</span>

// HighVolumeLoggingConfig returns logging configuration for high-volume environments
func HighVolumeLoggingConfig() config.LoggingConfig <span class="cov8" title="1">{
        return config.LoggingConfig{
                Level:                 "warn",
                Format:                "json",
                Output:                "stdout",
                EnableRequestTracing:  true,
                EnableCorrelationIDs:  true,
                EnableDatabaseLogging: false,
                EnablePerformanceLog:  false,
                LogSampling:           10, // Sample every 10th log to reduce volume
        }
}</span>

// SetupEnvironmentLogging configures logging based on environment
func SetupEnvironmentLogging(cfg *config.Config, environment string) <span class="cov0" title="0">{
        switch environment </span>{
        case "development", "dev":<span class="cov0" title="0">
                cfg.Logging = DevelopmentLoggingConfig()</span>
        case "production", "prod":<span class="cov0" title="0">
                cfg.Logging = ProductionLoggingConfig()</span>
        case "test", "testing":<span class="cov0" title="0">
                cfg.Logging = TestLoggingConfig()</span>
        case "staging", "stage":<span class="cov0" title="0">
                prodConfig := ProductionLoggingConfig()
                prodConfig.Level = "debug" // More verbose logging in staging
                cfg.Logging = prodConfig</span>
        case "high-volume":<span class="cov0" title="0">
                cfg.Logging = HighVolumeLoggingConfig()</span>
        }
}</pre>
		
		<pre class="file" id="file10" style="display: none">package logging

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "net/http"
        "strings"
        "time"
)

const (
        CorrelationIDHeader = "X-Correlation-ID"
        RequestIDHeader     = "X-Request-ID"
)

// GenerateCorrelationID generates a new correlation ID
func GenerateCorrelationID() string <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if random fails
                return fmt.Sprintf("cor_%d", time.Now().UnixNano())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("cor_%s", hex.EncodeToString(bytes))</span>
}

// GenerateRequestID generates a new request ID
func GenerateRequestID() string <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if random fails
                return fmt.Sprintf("req_%d", time.Now().UnixNano())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("req_%s", hex.EncodeToString(bytes))</span>
}

// CorrelationIDMiddleware is HTTP middleware that adds correlation ID to requests
func CorrelationIDMiddleware(logger *Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx := r.Context()
                        
                        // Get or generate correlation ID
                        correlationID := r.Header.Get(CorrelationIDHeader)
                        if correlationID == "" </span><span class="cov0" title="0">{
                                correlationID = GenerateCorrelationID()
                        }</span>
                        
                        // Get or generate request ID
                        <span class="cov0" title="0">requestID := r.Header.Get(RequestIDHeader)
                        if requestID == "" </span><span class="cov0" title="0">{
                                requestID = GenerateRequestID()
                        }</span>
                        
                        // Add IDs to context
                        <span class="cov0" title="0">ctx = context.WithValue(ctx, CorrelationIDKey, correlationID)
                        ctx = context.WithValue(ctx, RequestIDKey, requestID)
                        ctx = context.WithValue(ctx, ServiceKey, "kvstore-http")
                        
                        // Add IDs to response headers
                        w.Header().Set(CorrelationIDHeader, correlationID)
                        w.Header().Set(RequestIDHeader, requestID)
                        
                        // Create new request with updated context
                        r = r.WithContext(ctx)
                        
                        // Log request start
                        logger.RequestStart(ctx, r.Method, r.URL.Path, r.UserAgent())
                        
                        // Continue with the request
                        next.ServeHTTP(w, r)</span>
                })
        }
}

// LoggingMiddleware logs HTTP requests and responses
func LoggingMiddleware(logger *Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()
                        
                        // Wrap ResponseWriter to capture status code and size
                        wrapped := &amp;responseWriter{
                                ResponseWriter: w,
                                statusCode:     200,
                                size:          0,
                        }
                        
                        // Process request
                        next.ServeHTTP(wrapped, r)
                        
                        // Log request completion
                        duration := time.Since(start)
                        logger.RequestEnd(r.Context(), r.Method, r.URL.Path, wrapped.statusCode, duration, wrapped.size)
                }</span>)
        }
}

// responseWriter wraps http.ResponseWriter to capture response details
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int64
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        size, err := rw.ResponseWriter.Write(data)
        rw.size += int64(size)
        return size, err
}</span>

// ExtractCorrelationID extracts correlation ID from context
func ExtractCorrelationID(ctx context.Context) string <span class="cov8" title="1">{
        if id := ctx.Value(CorrelationIDKey); id != nil </span><span class="cov8" title="1">{
                if str, ok := id.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// ExtractRequestID extracts request ID from context
func ExtractRequestID(ctx context.Context) string <span class="cov8" title="1">{
        if id := ctx.Value(RequestIDKey); id != nil </span><span class="cov8" title="1">{
                if str, ok := id.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// PropagateCorrelationID propagates correlation ID to outgoing HTTP requests
func PropagateCorrelationID(ctx context.Context, req *http.Request) <span class="cov0" title="0">{
        if correlationID := ExtractCorrelationID(ctx); correlationID != "" </span><span class="cov0" title="0">{
                req.Header.Set(CorrelationIDHeader, correlationID)
        }</span>
        <span class="cov0" title="0">if requestID := ExtractRequestID(ctx); requestID != "" </span><span class="cov0" title="0">{
                req.Header.Set(RequestIDHeader, requestID)
        }</span>
}

// GRPCCorrelationIDFromContext extracts correlation ID for gRPC metadata
func GRPCCorrelationIDFromContext(ctx context.Context) map[string]string <span class="cov0" title="0">{
        metadata := make(map[string]string)
        
        if correlationID := ExtractCorrelationID(ctx); correlationID != "" </span><span class="cov0" title="0">{
                metadata["correlation-id"] = correlationID
        }</span>
        <span class="cov0" title="0">if requestID := ExtractRequestID(ctx); requestID != "" </span><span class="cov0" title="0">{
                metadata["request-id"] = requestID
        }</span>
        
        <span class="cov0" title="0">return metadata</span>
}

// CreateContextWithIDs creates a context with correlation and request IDs
func CreateContextWithIDs(ctx context.Context, correlationID, requestID string) context.Context <span class="cov8" title="1">{
        if correlationID != "" </span><span class="cov8" title="1">{
                ctx = context.WithValue(ctx, CorrelationIDKey, correlationID)
        }</span>
        <span class="cov8" title="1">if requestID != "" </span><span class="cov8" title="1">{
                ctx = context.WithValue(ctx, RequestIDKey, requestID)
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

// SanitizeCorrelationID sanitizes correlation ID to prevent log injection
func SanitizeCorrelationID(id string) string <span class="cov8" title="1">{
        // Remove any characters that could be used for log injection
        id = strings.ReplaceAll(id, "\n", "")
        id = strings.ReplaceAll(id, "\r", "")
        id = strings.ReplaceAll(id, "\t", "")
        
        // Limit length to prevent extremely long IDs
        if len(id) &gt; 64 </span><span class="cov8" title="1">{
                id = id[:64]
        }</span>
        
        <span class="cov8" title="1">return id</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package logging

import (
        "context"
        "io"
        "log/slog"
        "os"
        "time"

        "distributed-kvstore/internal/config"
)

type Logger struct {
        *slog.Logger
        config *config.LoggingConfig
}

type ContextKey string

const (
        CorrelationIDKey ContextKey = "correlation_id"
        RequestIDKey     ContextKey = "request_id"
        UserIDKey        ContextKey = "user_id"
        ServiceKey       ContextKey = "service"
)

// NewLogger creates a new structured logger using slog
func NewLogger(cfg *config.LoggingConfig) *Logger <span class="cov8" title="1">{
        var level slog.Level
        switch cfg.Level </span>{
        case "debug":<span class="cov8" title="1">
                level = slog.LevelDebug</span>
        case "info":<span class="cov8" title="1">
                level = slog.LevelInfo</span>
        case "warn", "warning":<span class="cov8" title="1">
                level = slog.LevelWarn</span>
        case "error":<span class="cov8" title="1">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        }

        <span class="cov8" title="1">var writer io.Writer
        switch cfg.Output </span>{
        case "stdout":<span class="cov8" title="1">
                writer = os.Stdout</span>
        case "stderr":<span class="cov8" title="1">
                writer = os.Stderr</span>
        default:<span class="cov0" title="0">
                if cfg.Output != "" </span><span class="cov0" title="0">{
                        file, err := os.OpenFile(cfg.Output, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                        if err == nil </span><span class="cov0" title="0">{
                                writer = file
                        }</span> else<span class="cov0" title="0"> {
                                writer = os.Stdout
                                slog.Warn("Failed to open log file, using stdout", "error", err, "file", cfg.Output)
                        }</span>
                } else<span class="cov0" title="0"> {
                        writer = os.Stdout
                }</span>
        }

        <span class="cov8" title="1">var handler slog.Handler
        opts := &amp;slog.HandlerOptions{
                Level: level,
                AddSource: level == slog.LevelDebug,
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov8" title="1">{
                        // Customize timestamp format
                        if a.Key == slog.TimeKey </span><span class="cov8" title="1">{
                                a.Value = slog.StringValue(a.Value.Time().Format(time.RFC3339))
                        }</span>
                        <span class="cov8" title="1">return a</span>
                },
        }

        <span class="cov8" title="1">switch cfg.Format </span>{
        case "json":<span class="cov8" title="1">
                handler = slog.NewJSONHandler(writer, opts)</span>
        case "text", "console":<span class="cov8" title="1">
                handler = slog.NewTextHandler(writer, opts)</span>
        default:<span class="cov0" title="0">
                // Default to JSON for production
                handler = slog.NewJSONHandler(writer, opts)</span>
        }

        <span class="cov8" title="1">logger := slog.New(handler)
        slog.SetDefault(logger)

        return &amp;Logger{
                Logger: logger,
                config: cfg,
        }</span>
}

// WithContext creates a new logger with context values
func (l *Logger) WithContext(ctx context.Context) *Logger <span class="cov8" title="1">{
        logger := l.Logger
        
        // Add correlation ID if present
        if correlationID := ctx.Value(CorrelationIDKey); correlationID != nil </span><span class="cov8" title="1">{
                logger = logger.With("correlation_id", correlationID)
        }</span>
        
        // Add request ID if present
        <span class="cov8" title="1">if requestID := ctx.Value(RequestIDKey); requestID != nil </span><span class="cov8" title="1">{
                logger = logger.With("request_id", requestID)
        }</span>
        
        // Add user ID if present
        <span class="cov8" title="1">if userID := ctx.Value(UserIDKey); userID != nil </span><span class="cov0" title="0">{
                logger = logger.With("user_id", userID)
        }</span>
        
        // Add service name if present
        <span class="cov8" title="1">if service := ctx.Value(ServiceKey); service != nil </span><span class="cov0" title="0">{
                logger = logger.With("service", service)
        }</span>

        <span class="cov8" title="1">return &amp;Logger{
                Logger: logger,
                config: l.config,
        }</span>
}

// WithFields creates a new logger with additional fields
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov8" title="1">{
        var args []interface{}
        for key, value := range fields </span><span class="cov8" title="1">{
                args = append(args, key, value)
        }</span>
        
        <span class="cov8" title="1">return &amp;Logger{
                Logger: l.Logger.With(args...),
                config: l.config,
        }</span>
}

// WithField creates a new logger with a single additional field
func (l *Logger) WithField(key string, value interface{}) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With(key, value),
                config: l.config,
        }
}</span>

// WithError creates a new logger with an error field
func (l *Logger) WithError(err error) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With("error", err.Error()),
                config: l.config,
        }
}</span>

// DebugContext logs a debug message with context
func (l *Logger) DebugContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.WithContext(ctx).Debug(msg, args...)
}</span>

// InfoContext logs an info message with context
func (l *Logger) InfoContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.WithContext(ctx).Info(msg, args...)
}</span>

// WarnContext logs a warning message with context
func (l *Logger) WarnContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.WithContext(ctx).Warn(msg, args...)
}</span>

// ErrorContext logs an error message with context
func (l *Logger) ErrorContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.WithContext(ctx).Error(msg, args...)
}</span>

// RequestStart logs the start of a request
func (l *Logger) RequestStart(ctx context.Context, method, path, userAgent string) <span class="cov0" title="0">{
        l.WithContext(ctx).Info("Request started",
                "method", method,
                "path", path,
                "user_agent", userAgent,
        )
}</span>

// RequestEnd logs the end of a request
func (l *Logger) RequestEnd(ctx context.Context, method, path string, statusCode int, duration time.Duration, size int64) <span class="cov0" title="0">{
        level := slog.LevelInfo
        if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov0" title="0">{
                level = slog.LevelWarn
        }</span> else<span class="cov0" title="0"> if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                level = slog.LevelError
        }</span>

        <span class="cov0" title="0">l.WithContext(ctx).Log(ctx, level, "Request completed",
                "method", method,
                "path", path,
                "status_code", statusCode,
                "duration_ms", duration.Milliseconds(),
                "response_size", size,
        )</span>
}

// DatabaseOperation logs database operations
func (l *Logger) DatabaseOperation(ctx context.Context, operation, key string, duration time.Duration, err error) <span class="cov8" title="1">{
        logger := l.WithContext(ctx).With(
                "operation", operation,
                "key", key,
                "duration_ms", duration.Milliseconds(),
        )

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Database operation failed", "error", err.Error())
        }</span> else<span class="cov8" title="1"> {
                logger.Debug("Database operation completed")
        }</span>
}

// ClusterEvent logs cluster-related events
func (l *Logger) ClusterEvent(ctx context.Context, event, nodeID string, details map[string]interface{}) <span class="cov8" title="1">{
        args := []interface{}{
                "event", event,
                "node_id", nodeID,
        }
        
        for key, value := range details </span><span class="cov8" title="1">{
                args = append(args, key, value)
        }</span>

        <span class="cov8" title="1">l.WithContext(ctx).Info("Cluster event", args...)</span>
}

// SecurityEvent logs security-related events
func (l *Logger) SecurityEvent(ctx context.Context, event, source string, severity string, details map[string]interface{}) <span class="cov8" title="1">{
        args := []interface{}{
                "event", event,
                "source", source,
                "severity", severity,
        }
        
        for key, value := range details </span><span class="cov8" title="1">{
                args = append(args, key, value)
        }</span>

        <span class="cov8" title="1">var level slog.Level
        switch severity </span>{
        case "low":<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        case "medium":<span class="cov0" title="0">
                level = slog.LevelWarn</span>
        case "high", "critical":<span class="cov8" title="1">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                level = slog.LevelWarn</span>
        }

        <span class="cov8" title="1">l.WithContext(ctx).Log(ctx, level, "Security event", args...)</span>
}

// Performance logs performance metrics
func (l *Logger) Performance(ctx context.Context, metric string, value float64, unit string, tags map[string]string) <span class="cov8" title="1">{
        args := []interface{}{
                "metric", metric,
                "value", value,
                "unit", unit,
        }
        
        for key, value := range tags </span><span class="cov8" title="1">{
                args = append(args, "tag_"+key, value)
        }</span>

        <span class="cov8" title="1">l.WithContext(ctx).Info("Performance metric", args...)</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package monitoring

import (
        "encoding/json"
        "fmt"
        "html/template"
        "net/http"
        "sort"
        "time"
)

// Dashboard represents the monitoring dashboard
type Dashboard struct {
        healthManager   *HealthManager
        metricsRegistry *MetricsRegistry
        kvMetrics       *KVStoreMetrics
}

// NewDashboard creates a new monitoring dashboard
func NewDashboard(healthManager *HealthManager, metricsRegistry *MetricsRegistry, kvMetrics *KVStoreMetrics) *Dashboard <span class="cov8" title="1">{
        return &amp;Dashboard{
                healthManager:   healthManager,
                metricsRegistry: metricsRegistry,
                kvMetrics:       kvMetrics,
        }
}</span>

// DashboardData contains data for the dashboard template
type DashboardData struct {
        Title        string
        RefreshTime  string
        Health       HealthResponse
        Metrics      map[string]*Metric
        SystemStats  SystemStats
        ChartData    ChartData
        Alerts       []Alert
        ServiceInfo  ServiceInfo
}

// SystemStats represents system statistics
type SystemStats struct {
        CPUUsage       float64 `json:"cpu_usage"`
        MemoryUsageMB  uint64  `json:"memory_usage_mb"`
        GoroutineCount int     `json:"goroutine_count"`
        GCPause        float64 `json:"gc_pause_ms"`
        Uptime         string  `json:"uptime"`
}

// ChartData contains data for dashboard charts
type ChartData struct {
        RequestsPerSecond []TimeValue `json:"requests_per_second"`
        ResponseTimes     []TimeValue `json:"response_times"`
        ErrorRates        []TimeValue `json:"error_rates"`
        StorageSize       []TimeValue `json:"storage_size"`
}

// TimeValue represents a time-series data point
type TimeValue struct {
        Time  string  `json:"time"`
        Value float64 `json:"value"`
}

// Alert represents a monitoring alert
type Alert struct {
        Level       string    `json:"level"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Timestamp   time.Time `json:"timestamp"`
        Source      string    `json:"source"`
}

// ServiceInfo contains service information
type ServiceInfo struct {
        Name      string `json:"name"`
        Version   string `json:"version"`
        BuildTime string `json:"build_time"`
        GitCommit string `json:"git_commit"`
}

// ServeHTTP implements the dashboard HTTP handler
func (d *Dashboard) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.URL.Path </span>{
        case "/dashboard":<span class="cov8" title="1">
                d.serveDashboardHTML(w, r)</span>
        case "/dashboard/api/health":<span class="cov8" title="1">
                d.serveHealthAPI(w, r)</span>
        case "/dashboard/api/metrics":<span class="cov8" title="1">
                d.serveMetricsAPI(w, r)</span>
        case "/dashboard/api/alerts":<span class="cov8" title="1">
                d.serveAlertsAPI(w, r)</span>
        case "/dashboard/api/charts":<span class="cov8" title="1">
                d.serveChartsAPI(w, r)</span>
        default:<span class="cov8" title="1">
                http.NotFound(w, r)</span>
        }
}

func (d *Dashboard) serveDashboardHTML(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        data := d.getDashboardData()
        
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        
        tmpl, err := template.New("dashboard").Parse(dashboardHTML)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Template error: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        <span class="cov8" title="1">if err := tmpl.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Template execution error: %v", err), http.StatusInternalServerError)
                return
        }</span>
}

func (d *Dashboard) serveHealthAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        health := d.healthManager.CheckHealth(r.Context())
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(health)
}</span>

func (d *Dashboard) serveMetricsAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        d.kvMetrics.UpdateSystemMetrics()
        metrics := d.metricsRegistry.GetAllMetrics()
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(metrics)
}</span>

func (d *Dashboard) serveAlertsAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        alerts := d.generateAlerts()
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(alerts)
}</span>

func (d *Dashboard) serveChartsAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        chartData := d.generateChartData()
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(chartData)
}</span>

func (d *Dashboard) getDashboardData() DashboardData <span class="cov8" title="1">{
        health := d.healthManager.CheckHealth(nil)
        d.kvMetrics.UpdateSystemMetrics()
        metrics := d.metricsRegistry.GetAllMetrics()
        
        return DashboardData{
                Title:       "KVStore Monitoring Dashboard",
                RefreshTime: time.Now().Format("15:04:05"),
                Health:      health,
                Metrics:     metrics,
                SystemStats: d.getSystemStats(),
                ChartData:   d.generateChartData(),
                Alerts:      d.generateAlerts(),
                ServiceInfo: ServiceInfo{
                        Name:      "Distributed Key-Value Store",
                        Version:   "1.0.0",
                        BuildTime: time.Now().Format("2006-01-02 15:04:05"),
                        GitCommit: "main",
                },
        }
}</span>

func (d *Dashboard) getSystemStats() SystemStats <span class="cov8" title="1">{
        memUsage := d.kvMetrics.MemoryUsage.Get()
        goroutineCount := int(d.kvMetrics.GoroutineCount.Get())
        
        return SystemStats{
                CPUUsage:       0.0, // Would be calculated from system metrics
                MemoryUsageMB:  uint64(memUsage / 1024 / 1024),
                GoroutineCount: goroutineCount,
                GCPause:        0.0, // Would be calculated from GC metrics
                Uptime:         "running",
        }
}</span>

func (d *Dashboard) generateChartData() ChartData <span class="cov8" title="1">{
        now := time.Now()
        
        // Generate sample time series data (in a real implementation, this would come from stored metrics)
        var requestsPerSecond, responseTimes, errorRates, storageSize []TimeValue
        
        for i := 0; i &lt; 20; i++ </span><span class="cov8" title="1">{
                t := now.Add(time.Duration(-i*30) * time.Second)
                timeStr := t.Format("15:04:05")
                
                requestsPerSecond = append(requestsPerSecond, TimeValue{
                        Time:  timeStr,
                        Value: float64(d.kvMetrics.RequestsTotal.Get()),
                })
                
                responseTimes = append(responseTimes, TimeValue{
                        Time:  timeStr,
                        Value: 0.1 + float64(i)*0.01, // Sample response time
                })
                
                errorRates = append(errorRates, TimeValue{
                        Time:  timeStr,
                        Value: float64(d.kvMetrics.RequestErrors.Get()),
                })
                
                storageSize = append(storageSize, TimeValue{
                        Time:  timeStr,
                        Value: d.kvMetrics.StorageSize.Get(),
                })
        }</span>
        
        <span class="cov8" title="1">return ChartData{
                RequestsPerSecond: requestsPerSecond,
                ResponseTimes:     responseTimes,
                ErrorRates:        errorRates,
                StorageSize:       storageSize,
        }</span>
}

func (d *Dashboard) generateAlerts() []Alert <span class="cov8" title="1">{
        var alerts []Alert
        
        health := d.healthManager.CheckHealth(nil)
        
        // Generate alerts based on health checks
        for name, check := range health.Checks </span><span class="cov8" title="1">{
                if check.Status != HealthStatusHealthy </span><span class="cov8" title="1">{
                        level := "warning"
                        if check.Status == HealthStatusUnhealthy </span><span class="cov0" title="0">{
                                level = "error"
                        }</span>
                        
                        <span class="cov8" title="1">alerts = append(alerts, Alert{
                                Level:       level,
                                Title:       fmt.Sprintf("%s Health Check Failed", name),
                                Description: check.Message,
                                Timestamp:   check.Timestamp,
                                Source:      "health_check",
                        })</span>
                }
        }
        
        // Generate alerts based on metrics
        <span class="cov8" title="1">memUsage := d.kvMetrics.MemoryUsage.Get() / 1024 / 1024 // Convert to MB
        if memUsage &gt; 500 </span><span class="cov8" title="1">{ // 500MB threshold
                alerts = append(alerts, Alert{
                        Level:       "warning",
                        Title:       "High Memory Usage",
                        Description: fmt.Sprintf("Memory usage is %.0f MB", memUsage),
                        Timestamp:   time.Now(),
                        Source:      "metrics",
                })
        }</span>
        
        <span class="cov8" title="1">goroutines := d.kvMetrics.GoroutineCount.Get()
        if goroutines &gt; 1000 </span><span class="cov0" title="0">{
                alerts = append(alerts, Alert{
                        Level:       "warning",
                        Title:       "High Goroutine Count",
                        Description: fmt.Sprintf("Goroutine count is %.0f", goroutines),
                        Timestamp:   time.Now(),
                        Source:      "metrics",
                })
        }</span>
        
        // Sort alerts by timestamp (newest first)
        <span class="cov8" title="1">sort.Slice(alerts, func(i, j int) bool </span><span class="cov8" title="1">{
                return alerts[i].Timestamp.After(alerts[j].Timestamp)
        }</span>)
        
        <span class="cov8" title="1">return alerts</span>
}

// HTML template for the dashboard
const dashboardHTML = `
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;{{.Title}}&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            font-size: 1.5rem;
        }
        
        .refresh-info {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .card h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5rem;
        }
        
        .health-status {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .health-healthy { background: #2ecc71; color: white; }
        .health-degraded { background: #f39c12; color: white; }
        .health-unhealthy { background: #e74c3c; color: white; }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .metric-item:last-child {
            border-bottom: none;
        }
        
        .metric-value {
            font-weight: bold;
            color: #2980b9;
        }
        
        .alert {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border-left: 4px solid;
        }
        
        .alert-error {
            background: #fdf2f2;
            border-color: #e74c3c;
            color: #721c24;
        }
        
        .alert-warning {
            background: #fefbf2;
            border-color: #f39c12;
            color: #8b5a2b;
        }
        
        .alert-info {
            background: #f2f8fd;
            border-color: #3498db;
            color: #2980b9;
        }
        
        .chart-container {
            height: 200px;
            background: #f8f9fa;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
        }
        
        .system-stat {
            text-align: center;
            padding: 1rem;
        }
        
        .system-stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2980b9;
        }
        
        .system-stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .refresh-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .refresh-button:hover {
            background: #2980b9;
        }
        
        .service-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.25rem;
        }
        
        .info-value {
            font-weight: bold;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;{{.Title}}&lt;/h1&gt;
        &lt;div class="refresh-info"&gt;
            Last updated: {{.RefreshTime}}
            &lt;button class="refresh-button" onclick="location.reload()"&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class="container"&gt;
        &lt;!-- Health Status --&gt;
        &lt;div class="grid"&gt;
            &lt;div class="card"&gt;
                &lt;h3&gt;Health Status&lt;/h3&gt;
                &lt;div&gt;
                    &lt;span class="health-status health-{{.Health.Status}}"&gt;{{.Health.Status}}&lt;/span&gt;
                    &lt;div style="margin-top: 1rem;"&gt;
                        &lt;div class="metric-item"&gt;
                            &lt;span&gt;Uptime&lt;/span&gt;
                            &lt;span class="metric-value"&gt;{{printf "%.2f" .Health.Uptime.Seconds}}s&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class="metric-item"&gt;
                            &lt;span&gt;Total Checks&lt;/span&gt;
                            &lt;span class="metric-value"&gt;{{.Health.Summary.Total}}&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class="metric-item"&gt;
                            &lt;span&gt;Healthy&lt;/span&gt;
                            &lt;span class="metric-value" style="color: #2ecc71;"&gt;{{.Health.Summary.Healthy}}&lt;/span&gt;
                        &lt;/div&gt;
                        {{if gt .Health.Summary.Degraded 0}}
                        &lt;div class="metric-item"&gt;
                            &lt;span&gt;Degraded&lt;/span&gt;
                            &lt;span class="metric-value" style="color: #f39c12;"&gt;{{.Health.Summary.Degraded}}&lt;/span&gt;
                        &lt;/div&gt;
                        {{end}}
                        {{if gt .Health.Summary.Unhealthy 0}}
                        &lt;div class="metric-item"&gt;
                            &lt;span&gt;Unhealthy&lt;/span&gt;
                            &lt;span class="metric-value" style="color: #e74c3c;"&gt;{{.Health.Summary.Unhealthy}}&lt;/span&gt;
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- System Stats --&gt;
            &lt;div class="card"&gt;
                &lt;h3&gt;System Statistics&lt;/h3&gt;
                &lt;div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;"&gt;
                    &lt;div class="system-stat"&gt;
                        &lt;div class="system-stat-value"&gt;{{.SystemStats.MemoryUsageMB}}&lt;/div&gt;
                        &lt;div class="system-stat-label"&gt;Memory (MB)&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="system-stat"&gt;
                        &lt;div class="system-stat-value"&gt;{{.SystemStats.GoroutineCount}}&lt;/div&gt;
                        &lt;div class="system-stat-label"&gt;Goroutines&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;!-- Service Information --&gt;
            &lt;div class="card"&gt;
                &lt;h3&gt;Service Information&lt;/h3&gt;
                &lt;div class="service-info"&gt;
                    &lt;div class="info-item"&gt;
                        &lt;span class="info-label"&gt;Name&lt;/span&gt;
                        &lt;span class="info-value"&gt;{{.ServiceInfo.Name}}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="info-item"&gt;
                        &lt;span class="info-label"&gt;Version&lt;/span&gt;
                        &lt;span class="info-value"&gt;{{.ServiceInfo.Version}}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="info-item"&gt;
                        &lt;span class="info-label"&gt;Build Time&lt;/span&gt;
                        &lt;span class="info-value"&gt;{{.ServiceInfo.BuildTime}}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="info-item"&gt;
                        &lt;span class="info-label"&gt;Git Commit&lt;/span&gt;
                        &lt;span class="info-value"&gt;{{.ServiceInfo.GitCommit}}&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!-- Metrics Overview --&gt;
        &lt;div class="grid"&gt;
            &lt;div class="card full-width"&gt;
                &lt;h3&gt;Key Metrics&lt;/h3&gt;
                &lt;div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;"&gt;
                    {{range $name, $metric := .Metrics}}
                    &lt;div class="metric-item"&gt;
                        &lt;span&gt;{{$name}}&lt;/span&gt;
                        &lt;span class="metric-value"&gt;{{printf "%.2f" $metric.Value}}&lt;/span&gt;
                    &lt;/div&gt;
                    {{end}}
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!-- Alerts --&gt;
        {{if .Alerts}}
        &lt;div class="card"&gt;
            &lt;h3&gt;Alerts ({{len .Alerts}})&lt;/h3&gt;
            {{range .Alerts}}
            &lt;div class="alert alert-{{.Level}}"&gt;
                &lt;strong&gt;{{.Title}}&lt;/strong&gt;&lt;br&gt;
                {{.Description}}&lt;br&gt;
                &lt;small&gt;{{.Timestamp.Format "15:04:05"}} - {{.Source}}&lt;/small&gt;
            &lt;/div&gt;
            {{end}}
        &lt;/div&gt;
        {{end}}
        
        &lt;!-- Charts (Placeholder) --&gt;
        &lt;div class="grid"&gt;
            &lt;div class="card"&gt;
                &lt;h3&gt;Request Rate&lt;/h3&gt;
                &lt;div class="chart-container"&gt;
                    Chart: Requests per second over time
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="card"&gt;
                &lt;h3&gt;Response Times&lt;/h3&gt;
                &lt;div class="chart-container"&gt;
                    Chart: Response time percentiles
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        // Auto-refresh every 30 seconds
        setTimeout(() =&gt; location.reload(), 30000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`</pre>
		
		<pre class="file" id="file13" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "net/http"
        "runtime"
        "time"

        "distributed-kvstore/internal/storage"
)

// HealthStatus represents the overall health status
type HealthStatus string

const (
        HealthStatusHealthy   HealthStatus = "healthy"
        HealthStatusDegraded  HealthStatus = "degraded"
        HealthStatusUnhealthy HealthStatus = "unhealthy"
)

// HealthCheck represents a single health check
type HealthCheck struct {
        Name        string                 `json:"name"`
        Status      HealthStatus           `json:"status"`
        Message     string                 `json:"message,omitempty"`
        Duration    time.Duration          `json:"duration_ms"`
        Timestamp   time.Time              `json:"timestamp"`
        Details     map[string]interface{} `json:"details,omitempty"`
        Critical    bool                   `json:"critical"`
        LastFailure *time.Time             `json:"last_failure,omitempty"`
}

// HealthResponse represents the complete health check response
type HealthResponse struct {
        Status       HealthStatus             `json:"status"`
        Version      string                   `json:"version"`
        Uptime       time.Duration            `json:"uptime_seconds"`
        Timestamp    time.Time                `json:"timestamp"`
        Checks       map[string]HealthCheck   `json:"checks"`
        Summary      HealthSummary            `json:"summary"`
        SystemInfo   SystemInfo               `json:"system_info"`
        Dependencies map[string]HealthCheck   `json:"dependencies,omitempty"`
}

// HealthSummary provides overall health metrics
type HealthSummary struct {
        Total      int `json:"total"`
        Healthy    int `json:"healthy"`
        Degraded   int `json:"degraded"`
        Unhealthy  int `json:"unhealthy"`
        Critical   int `json:"critical"`
}

// SystemInfo provides system-level information
type SystemInfo struct {
        GoVersion    string    `json:"go_version"`
        OS           string    `json:"os"`
        Arch         string    `json:"arch"`
        NumCPU       int       `json:"num_cpu"`
        NumGoroutine int       `json:"num_goroutine"`
        MemoryMB     uint64    `json:"memory_mb"`
        StartTime    time.Time `json:"start_time"`
}

// HealthChecker interface for implementing health checks
type HealthChecker interface {
        Name() string
        Check(ctx context.Context) HealthCheck
        IsCritical() bool
}

// HealthManager manages all health checks
type HealthManager struct {
        checkers     []HealthChecker
        startTime    time.Time
        version      string
        lastResults  map[string]HealthCheck
}

// NewHealthManager creates a new health manager
func NewHealthManager(version string) *HealthManager <span class="cov8" title="1">{
        return &amp;HealthManager{
                checkers:    make([]HealthChecker, 0),
                startTime:   time.Now(),
                version:     version,
                lastResults: make(map[string]HealthCheck),
        }
}</span>

// RegisterChecker adds a health checker
func (hm *HealthManager) RegisterChecker(checker HealthChecker) <span class="cov8" title="1">{
        hm.checkers = append(hm.checkers, checker)
}</span>

// CheckHealth performs all health checks
func (hm *HealthManager) CheckHealth(ctx context.Context) HealthResponse <span class="cov8" title="1">{
        checks := make(map[string]HealthCheck)
        summary := HealthSummary{}
        overallStatus := HealthStatusHealthy

        // Execute all health checks
        for _, checker := range hm.checkers </span><span class="cov8" title="1">{
                start := time.Now()
                check := checker.Check(ctx)
                check.Duration = time.Since(start)
                check.Timestamp = time.Now()
                check.Critical = checker.IsCritical()
                
                checks[checker.Name()] = check
                hm.lastResults[checker.Name()] = check

                // Update summary
                summary.Total++
                switch check.Status </span>{
                case HealthStatusHealthy:<span class="cov8" title="1">
                        summary.Healthy++</span>
                case HealthStatusDegraded:<span class="cov8" title="1">
                        summary.Degraded++
                        if overallStatus == HealthStatusHealthy </span><span class="cov8" title="1">{
                                overallStatus = HealthStatusDegraded
                        }</span>
                case HealthStatusUnhealthy:<span class="cov8" title="1">
                        summary.Unhealthy++
                        overallStatus = HealthStatusUnhealthy
                        if check.Critical </span><span class="cov8" title="1">{
                                summary.Critical++
                        }</span>
                }
        }

        // If any critical check fails, overall status is unhealthy
        <span class="cov8" title="1">if summary.Critical &gt; 0 </span><span class="cov8" title="1">{
                overallStatus = HealthStatusUnhealthy
        }</span>

        <span class="cov8" title="1">return HealthResponse{
                Status:     overallStatus,
                Version:    hm.version,
                Uptime:     time.Since(hm.startTime),
                Timestamp:  time.Now(),
                Checks:     checks,
                Summary:    summary,
                SystemInfo: hm.getSystemInfo(),
        }</span>
}

// GetLastResults returns the last health check results
func (hm *HealthManager) GetLastResults() map[string]HealthCheck <span class="cov0" title="0">{
        return hm.lastResults
}</span>

// getSystemInfo collects system information
func (hm *HealthManager) getSystemInfo() SystemInfo <span class="cov8" title="1">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        return SystemInfo{
                GoVersion:    runtime.Version(),
                OS:           runtime.GOOS,
                Arch:         runtime.GOARCH,
                NumCPU:       runtime.NumCPU(),
                NumGoroutine: runtime.NumGoroutine(),
                MemoryMB:     m.Alloc / 1024 / 1024,
                StartTime:    hm.startTime,
        }
}</span>

// Storage Health Checker
type StorageHealthChecker struct {
        storage storage.StorageEngine
}

func NewStorageHealthChecker(storage storage.StorageEngine) *StorageHealthChecker <span class="cov8" title="1">{
        return &amp;StorageHealthChecker{storage: storage}
}</span>

func (s *StorageHealthChecker) Name() string <span class="cov8" title="1">{
        return "storage"
}</span>

func (s *StorageHealthChecker) IsCritical() bool <span class="cov8" title="1">{
        return true
}</span>

func (s *StorageHealthChecker) Check(ctx context.Context) HealthCheck <span class="cov8" title="1">{
        start := time.Now()
        
        // Test basic operations
        testKey := []byte("__health_check__")
        testValue := []byte("ok")

        // Test write
        if err := s.storage.Put(testKey, testValue); err != nil </span><span class="cov8" title="1">{
                return HealthCheck{
                        Name:    s.Name(),
                        Status:  HealthStatusUnhealthy,
                        Message: fmt.Sprintf("Storage write failed: %v", err),
                        Details: map[string]interface{}{
                                "operation": "put",
                                "error":     err.Error(),
                        },
                }
        }</span>

        // Test read
        <span class="cov8" title="1">value, err := s.storage.Get(testKey)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Name:    s.Name(),
                        Status:  HealthStatusUnhealthy,
                        Message: fmt.Sprintf("Storage read failed: %v", err),
                        Details: map[string]interface{}{
                                "operation": "get",
                                "error":     err.Error(),
                        },
                }
        }</span>

        <span class="cov8" title="1">if string(value) != string(testValue) </span><span class="cov0" title="0">{
                return HealthCheck{
                        Name:    s.Name(),
                        Status:  HealthStatusUnhealthy,
                        Message: "Storage data integrity check failed",
                        Details: map[string]interface{}{
                                "expected": string(testValue),
                                "actual":   string(value),
                        },
                }
        }</span>

        // Test delete
        <span class="cov8" title="1">if err := s.storage.Delete(testKey); err != nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Name:    s.Name(),
                        Status:  HealthStatusDegraded,
                        Message: fmt.Sprintf("Storage delete failed: %v", err),
                        Details: map[string]interface{}{
                                "operation": "delete",
                                "error":     err.Error(),
                        },
                }
        }</span>

        // Get storage stats
        <span class="cov8" title="1">stats := s.storage.Stats()
        duration := time.Since(start)

        status := HealthStatusHealthy
        if duration &gt; 100*time.Millisecond </span><span class="cov0" title="0">{
                status = HealthStatusDegraded
        }</span>

        // Extract stats - stats is already map[string]interface{}
        <span class="cov8" title="1">totalSize := stats["total_size"]
        entries := stats["entries"]

        return HealthCheck{
                Name:    s.Name(),
                Status:  status,
                Message: "Storage is operational",
                Details: map[string]interface{}{
                        "operation_time_ms": duration.Milliseconds(),
                        "total_size":        totalSize,
                        "entries":           entries,
                },
        }</span>
}

// Memory Health Checker
type MemoryHealthChecker struct {
        maxMemoryMB uint64
}

func NewMemoryHealthChecker(maxMemoryMB uint64) *MemoryHealthChecker <span class="cov8" title="1">{
        return &amp;MemoryHealthChecker{maxMemoryMB: maxMemoryMB}
}</span>

func (m *MemoryHealthChecker) Name() string <span class="cov8" title="1">{
        return "memory"
}</span>

func (m *MemoryHealthChecker) IsCritical() bool <span class="cov8" title="1">{
        return false
}</span>

func (m *MemoryHealthChecker) Check(ctx context.Context) HealthCheck <span class="cov8" title="1">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        allocMB := memStats.Alloc / 1024 / 1024
        sysMB := memStats.Sys / 1024 / 1024

        status := HealthStatusHealthy
        message := "Memory usage is normal"

        if m.maxMemoryMB &gt; 0 </span><span class="cov8" title="1">{
                if allocMB &gt; m.maxMemoryMB </span><span class="cov0" title="0">{
                        status = HealthStatusUnhealthy
                        message = fmt.Sprintf("Memory usage exceeds limit (%dMB &gt; %dMB)", allocMB, m.maxMemoryMB)
                }</span> else<span class="cov8" title="1"> if allocMB &gt; m.maxMemoryMB*80/100 </span><span class="cov0" title="0">{
                        status = HealthStatusDegraded
                        message = fmt.Sprintf("Memory usage is high (%dMB)", allocMB)
                }</span>
        }

        <span class="cov8" title="1">return HealthCheck{
                Name:    m.Name(),
                Status:  status,
                Message: message,
                Details: map[string]interface{}{
                        "alloc_mb":      allocMB,
                        "sys_mb":        sysMB,
                        "num_gc":        memStats.NumGC,
                        "gc_pause_ns":   memStats.PauseNs[(memStats.NumGC+255)%256],
                        "num_goroutine": runtime.NumGoroutine(),
                },
        }</span>
}

// Goroutine Health Checker
type GoroutineHealthChecker struct {
        maxGoroutines int
}

func NewGoroutineHealthChecker(maxGoroutines int) *GoroutineHealthChecker <span class="cov8" title="1">{
        return &amp;GoroutineHealthChecker{maxGoroutines: maxGoroutines}
}</span>

func (g *GoroutineHealthChecker) Name() string <span class="cov8" title="1">{
        return "goroutines"
}</span>

func (g *GoroutineHealthChecker) IsCritical() bool <span class="cov8" title="1">{
        return false
}</span>

func (g *GoroutineHealthChecker) Check(ctx context.Context) HealthCheck <span class="cov8" title="1">{
        numGoroutines := runtime.NumGoroutine()
        
        status := HealthStatusHealthy
        message := "Goroutine count is normal"

        if g.maxGoroutines &gt; 0 </span><span class="cov8" title="1">{
                if numGoroutines &gt; g.maxGoroutines </span><span class="cov0" title="0">{
                        status = HealthStatusUnhealthy
                        message = fmt.Sprintf("Too many goroutines (%d &gt; %d)", numGoroutines, g.maxGoroutines)
                }</span> else<span class="cov8" title="1"> if numGoroutines &gt; g.maxGoroutines*80/100 </span><span class="cov8" title="1">{
                        status = HealthStatusDegraded
                        message = fmt.Sprintf("High goroutine count (%d)", numGoroutines)
                }</span>
        }

        <span class="cov8" title="1">return HealthCheck{
                Name:    g.Name(),
                Status:  status,
                Message: message,
                Details: map[string]interface{}{
                        "count": numGoroutines,
                        "limit": g.maxGoroutines,
                },
        }</span>
}

// HTTP Dependency Health Checker
type HTTPDependencyChecker struct {
        name     string
        url      string
        timeout  time.Duration
        critical bool
        client   *http.Client
}

func NewHTTPDependencyChecker(name, url string, timeout time.Duration, critical bool) *HTTPDependencyChecker <span class="cov8" title="1">{
        return &amp;HTTPDependencyChecker{
                name:     name,
                url:      url,
                timeout:  timeout,
                critical: critical,
                client: &amp;http.Client{
                        Timeout: timeout,
                },
        }
}</span>

func (h *HTTPDependencyChecker) Name() string <span class="cov8" title="1">{
        return h.name
}</span>

func (h *HTTPDependencyChecker) IsCritical() bool <span class="cov8" title="1">{
        return h.critical
}</span>

func (h *HTTPDependencyChecker) Check(ctx context.Context) HealthCheck <span class="cov8" title="1">{
        start := time.Now()
        
        req, err := http.NewRequestWithContext(ctx, "GET", h.url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return HealthCheck{
                        Name:    h.Name(),
                        Status:  HealthStatusUnhealthy,
                        Message: fmt.Sprintf("Failed to create request: %v", err),
                }
        }</span>

        <span class="cov8" title="1">resp, err := h.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return HealthCheck{
                        Name:    h.Name(),
                        Status:  HealthStatusUnhealthy,
                        Message: fmt.Sprintf("HTTP request failed: %v", err),
                        Details: map[string]interface{}{
                                "url":   h.url,
                                "error": err.Error(),
                        },
                }
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        duration := time.Since(start)
        status := HealthStatusHealthy

        if resp.StatusCode &gt;= 500 </span><span class="cov8" title="1">{
                status = HealthStatusUnhealthy
        }</span> else<span class="cov8" title="1"> if resp.StatusCode &gt;= 400 || duration &gt; h.timeout/2 </span><span class="cov0" title="0">{
                status = HealthStatusDegraded
        }</span>

        <span class="cov8" title="1">return HealthCheck{
                Name:    h.Name(),
                Status:  status,
                Message: fmt.Sprintf("HTTP %d", resp.StatusCode),
                Details: map[string]interface{}{
                        "url":              h.url,
                        "status_code":      resp.StatusCode,
                        "response_time_ms": duration.Milliseconds(),
                },
        }</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package monitoring

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "distributed-kvstore/internal/storage"
)

// MonitoringService integrates all monitoring components
type MonitoringService struct {
        HealthManager   *HealthManager
        MetricsRegistry *MetricsRegistry
        KVMetrics       *KVStoreMetrics
        Dashboard       *Dashboard
        Collector       *MetricsCollector
        PrometheusExporter *PrometheusExporter
}

// NewMonitoringService creates a new monitoring service
func NewMonitoringService(storageEngine storage.StorageEngine) *MonitoringService <span class="cov8" title="1">{
        // Initialize metrics
        kvMetrics := NewKVStoreMetrics()
        
        // Initialize health manager
        healthManager := NewHealthManager("1.0.0")
        
        // Register health checkers
        healthManager.RegisterChecker(NewStorageHealthChecker(storageEngine))
        healthManager.RegisterChecker(NewMemoryHealthChecker(1024)) // 1GB limit
        healthManager.RegisterChecker(NewGoroutineHealthChecker(10000)) // 10k goroutines limit
        
        // Initialize dashboard
        dashboard := NewDashboard(healthManager, kvMetrics.GetRegistry(), kvMetrics)
        
        // Initialize metrics collector
        collector := NewMetricsCollector(kvMetrics, 15*time.Second)
        
        // Initialize Prometheus exporter
        prometheusExporter := NewPrometheusExporter(kvMetrics.GetRegistry(), kvMetrics)
        
        return &amp;MonitoringService{
                HealthManager:      healthManager,
                MetricsRegistry:    kvMetrics.GetRegistry(),
                KVMetrics:          kvMetrics,
                Dashboard:          dashboard,
                Collector:          collector,
                PrometheusExporter: prometheusExporter,
        }
}</span>

// Start starts the monitoring service
func (ms *MonitoringService) Start() <span class="cov8" title="1">{
        ms.Collector.Start()
}</span>

// Stop stops the monitoring service
func (ms *MonitoringService) Stop() <span class="cov8" title="1">{
        ms.Collector.Stop()
}</span>

// GetHealthHandler returns HTTP handler for health checks
func (ms *MonitoringService) GetHealthHandler() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
                defer cancel()
                
                health := ms.HealthManager.CheckHealth(ctx)
                
                // Set appropriate HTTP status code
                statusCode := http.StatusOK
                if health.Status == HealthStatusUnhealthy </span><span class="cov8" title="1">{
                        statusCode = http.StatusServiceUnavailable
                }</span> else<span class="cov8" title="1"> if health.Status == HealthStatusDegraded </span><span class="cov0" title="0">{
                        statusCode = http.StatusPartialContent
                }</span>
                
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(statusCode)
                
                if err := json.NewEncoder(w).Encode(health); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode health response", http.StatusInternalServerError)
                }</span>
        }
}

// GetMetricsHandler returns HTTP handler for Prometheus metrics
func (ms *MonitoringService) GetMetricsHandler() http.Handler <span class="cov8" title="1">{
        return ms.PrometheusExporter
}</span>

// GetDashboardHandler returns HTTP handler for the monitoring dashboard
func (ms *MonitoringService) GetDashboardHandler() http.Handler <span class="cov8" title="1">{
        return ms.Dashboard
}</span>

// RecordHTTPRequest records HTTP request metrics
func (ms *MonitoringService) RecordHTTPRequest(method, path string, statusCode int, duration time.Duration, responseSize int64) <span class="cov8" title="1">{
        ms.KVMetrics.HTTPRequests.Inc()
        ms.KVMetrics.HTTPDuration.Observe(duration.Seconds())
        if responseSize &gt; 0 </span><span class="cov8" title="1">{
                ms.KVMetrics.HTTPResponseSize.Observe(float64(responseSize))
        }</span>
        
        // Record errors
        <span class="cov8" title="1">if statusCode &gt;= 400 </span><span class="cov8" title="1">{
                ms.KVMetrics.RequestErrors.Inc()
        }</span>
}

// RecordStorageOperation records storage operation metrics
func (ms *MonitoringService) RecordStorageOperation(operation string, success bool, duration time.Duration) <span class="cov8" title="1">{
        ms.KVMetrics.StorageOperations.Inc()
        
        if !success </span><span class="cov8" title="1">{
                ms.KVMetrics.StorageErrors.Inc()
        }</span>
        
        // Update request metrics
        <span class="cov8" title="1">ms.KVMetrics.RequestDuration.Observe(duration.Seconds())</span>
}

// UpdateStorageMetrics updates storage-related metrics
func (ms *MonitoringService) UpdateStorageMetrics(stats map[string]interface{}) <span class="cov8" title="1">{
        if totalSize, ok := stats["total_size"].(float64); ok </span><span class="cov8" title="1">{
                ms.KVMetrics.StorageSize.Set(totalSize)
        }</span>
        <span class="cov8" title="1">if entries, ok := stats["entries"].(float64); ok </span><span class="cov8" title="1">{
                ms.KVMetrics.StorageEntries.Set(entries)
        }</span>
}

// MonitoringMiddleware provides HTTP middleware for automatic metrics collection
func (ms *MonitoringService) MonitoringMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                
                // Wrap response writer to capture metrics
                wrapped := &amp;monitoringResponseWriter{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                        size:          0,
                }
                
                // Process request
                next.ServeHTTP(wrapped, r)
                
                // Record metrics
                duration := time.Since(start)
                ms.RecordHTTPRequest(r.Method, r.URL.Path, wrapped.statusCode, duration, wrapped.size)
        }</span>)
}

// monitoringResponseWriter wraps http.ResponseWriter to capture metrics
type monitoringResponseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int64
}

func (mrw *monitoringResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        mrw.statusCode = code
        mrw.ResponseWriter.WriteHeader(code)
}</span>

func (mrw *monitoringResponseWriter) Write(data []byte) (int, error) <span class="cov8" title="1">{
        size, err := mrw.ResponseWriter.Write(data)
        mrw.size += int64(size)
        return size, err
}</span>

// Enhanced health check with storage operation test
type EnhancedHealthResponse struct {
        HealthResponse
        LastCheck    time.Time `json:"last_check"`
        CheckHistory []HealthCheckHistory `json:"check_history,omitempty"`
}

type HealthCheckHistory struct {
        Timestamp time.Time    `json:"timestamp"`
        Status    HealthStatus `json:"status"`
        Duration  time.Duration `json:"duration"`
}

// AlertManager handles monitoring alerts
type AlertManager struct {
        alerts        []Alert
        rules         []AlertRule
        notifications chan Alert
}

type AlertRule struct {
        Name        string
        Condition   func(metrics map[string]*Metric, health HealthResponse) bool
        Severity    string
        Description string
}

// NewAlertManager creates a new alert manager
func NewAlertManager() *AlertManager <span class="cov8" title="1">{
        am := &amp;AlertManager{
                alerts:        make([]Alert, 0),
                rules:         make([]AlertRule, 0),
                notifications: make(chan Alert, 100),
        }
        
        // Add default alert rules
        am.AddDefaultRules()
        
        return am
}</span>

// AddDefaultRules adds default monitoring alert rules
func (am *AlertManager) AddDefaultRules() <span class="cov8" title="1">{
        // High memory usage
        am.rules = append(am.rules, AlertRule{
                Name:        "HighMemoryUsage",
                Severity:    "warning",
                Description: "Memory usage is above 80%",
                Condition: func(metrics map[string]*Metric, health HealthResponse) bool </span><span class="cov8" title="1">{
                        if memMetric, exists := metrics["kvstore_memory_usage_bytes"]; exists </span><span class="cov8" title="1">{
                                memUsageMB := memMetric.Value / 1024 / 1024
                                return memUsageMB &gt; 800 // 800MB threshold
                        }</span>
                        <span class="cov8" title="1">return false</span>
                },
        })
        
        // High error rate
        <span class="cov8" title="1">am.rules = append(am.rules, AlertRule{
                Name:        "HighErrorRate",
                Severity:    "critical",
                Description: "Error rate is above 5%",
                Condition: func(metrics map[string]*Metric, health HealthResponse) bool </span><span class="cov8" title="1">{
                        var totalRequests, totalErrors float64
                        if requestsMetric, exists := metrics["kvstore_requests_total"]; exists </span><span class="cov8" title="1">{
                                totalRequests = requestsMetric.Value
                        }</span>
                        <span class="cov8" title="1">if errorsMetric, exists := metrics["kvstore_request_errors_total"]; exists </span><span class="cov8" title="1">{
                                totalErrors = errorsMetric.Value
                        }</span>
                        
                        <span class="cov8" title="1">if totalRequests &gt; 0 </span><span class="cov8" title="1">{
                                errorRate := (totalErrors / totalRequests) * 100
                                return errorRate &gt; 5.0
                        }</span>
                        <span class="cov8" title="1">return false</span>
                },
        })
        
        // Storage health failure
        <span class="cov8" title="1">am.rules = append(am.rules, AlertRule{
                Name:        "StorageUnhealthy",
                Severity:    "critical",
                Description: "Storage health check is failing",
                Condition: func(metrics map[string]*Metric, health HealthResponse) bool </span><span class="cov8" title="1">{
                        if storageCheck, exists := health.Checks["storage"]; exists </span><span class="cov8" title="1">{
                                return storageCheck.Status == HealthStatusUnhealthy
                        }</span>
                        <span class="cov8" title="1">return false</span>
                },
        })
}

// CheckAlerts evaluates alert rules and generates alerts
func (am *AlertManager) CheckAlerts(metrics map[string]*Metric, health HealthResponse) <span class="cov8" title="1">{
        for _, rule := range am.rules </span><span class="cov8" title="1">{
                if rule.Condition(metrics, health) </span><span class="cov8" title="1">{
                        alert := Alert{
                                Level:       rule.Severity,
                                Title:       rule.Name,
                                Description: rule.Description,
                                Timestamp:   time.Now(),
                                Source:      "alert_manager",
                        }
                        
                        // Send notification
                        select </span>{
                        case am.notifications &lt;- alert:<span class="cov8" title="1"></span>
                        default:<span class="cov8" title="1"></span>
                                // Channel full, skip notification
                        }
                        
                        <span class="cov8" title="1">am.alerts = append(am.alerts, alert)</span>
                }
        }
}

// GetAlerts returns current alerts
func (am *AlertManager) GetAlerts() []Alert <span class="cov8" title="1">{
        return am.alerts
}</span>

// GetNotifications returns the alerts notification channel
func (am *AlertManager) GetNotifications() &lt;-chan Alert <span class="cov8" title="1">{
        return am.notifications
}</pre>
		
		<pre class="file" id="file15" style="display: none">package monitoring

import (
        "fmt"
        "runtime"
        "sync"
        "sync/atomic"
        "time"
)

// MetricType represents different types of metrics
type MetricType string

const (
        MetricTypeCounter   MetricType = "counter"
        MetricTypeGauge     MetricType = "gauge"
        MetricTypeHistogram MetricType = "histogram"
        MetricTypeSummary   MetricType = "summary"
)

// Metric represents a single metric
type Metric struct {
        Name        string                 `json:"name"`
        Type        MetricType             `json:"type"`
        Value       float64                `json:"value"`
        Labels      map[string]string      `json:"labels,omitempty"`
        Help        string                 `json:"help"`
        Timestamp   time.Time              `json:"timestamp"`
        Unit        string                 `json:"unit,omitempty"`
        Additional  map[string]interface{} `json:"additional,omitempty"`
}

// MetricsRegistry manages all metrics
type MetricsRegistry struct {
        mu      sync.RWMutex
        metrics map[string]*Metric
        counters map[string]*Counter
        gauges   map[string]*Gauge
        histograms map[string]*Histogram
        summaries  map[string]*Summary
}

// NewMetricsRegistry creates a new metrics registry
func NewMetricsRegistry() *MetricsRegistry <span class="cov8" title="1">{
        return &amp;MetricsRegistry{
                metrics:    make(map[string]*Metric),
                counters:   make(map[string]*Counter),
                gauges:     make(map[string]*Gauge),
                histograms: make(map[string]*Histogram),
                summaries:  make(map[string]*Summary),
        }
}</span>

// Counter represents a monotonically increasing counter
type Counter struct {
        name   string
        help   string
        value  int64
        labels map[string]string
}

func (mr *MetricsRegistry) NewCounter(name, help string, labels map[string]string) *Counter <span class="cov8" title="1">{
        mr.mu.Lock()
        defer mr.mu.Unlock()
        
        counter := &amp;Counter{
                name:   name,
                help:   help,
                labels: labels,
                value:  0,
        }
        
        mr.counters[name] = counter
        return counter
}</span>

func (c *Counter) Inc() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.value, 1)
}</span>

func (c *Counter) Add(delta float64) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.value, int64(delta))
}</span>

func (c *Counter) Get() float64 <span class="cov8" title="1">{
        return float64(atomic.LoadInt64(&amp;c.value))
}</span>

// Gauge represents a value that can go up and down
type Gauge struct {
        name   string
        help   string
        value  int64
        labels map[string]string
}

func (mr *MetricsRegistry) NewGauge(name, help string, labels map[string]string) *Gauge <span class="cov8" title="1">{
        mr.mu.Lock()
        defer mr.mu.Unlock()
        
        gauge := &amp;Gauge{
                name:   name,
                help:   help,
                labels: labels,
        }
        
        mr.gauges[name] = gauge
        return gauge
}</span>

func (g *Gauge) Set(value float64) <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;g.value, int64(value))
}</span>

func (g *Gauge) Inc() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;g.value, 1)
}</span>

func (g *Gauge) Dec() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;g.value, -1)
}</span>

func (g *Gauge) Add(delta float64) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;g.value, int64(delta))
}</span>

func (g *Gauge) Sub(delta float64) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;g.value, -int64(delta))
}</span>

func (g *Gauge) Get() float64 <span class="cov8" title="1">{
        return float64(atomic.LoadInt64(&amp;g.value))
}</span>

// Histogram tracks the distribution of values
type Histogram struct {
        name    string
        help    string
        buckets []float64
        counts  []int64
        sum     int64
        count   int64
        labels  map[string]string
        mu      sync.RWMutex
}

func (mr *MetricsRegistry) NewHistogram(name, help string, buckets []float64, labels map[string]string) *Histogram <span class="cov8" title="1">{
        mr.mu.Lock()
        defer mr.mu.Unlock()
        
        if buckets == nil </span><span class="cov8" title="1">{
                buckets = []float64{0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10}
        }</span>
        
        <span class="cov8" title="1">histogram := &amp;Histogram{
                name:    name,
                help:    help,
                buckets: buckets,
                counts:  make([]int64, len(buckets)+1), // +1 for +Inf bucket
                labels:  labels,
        }
        
        mr.histograms[name] = histogram
        return histogram</span>
}

func (h *Histogram) Observe(value float64) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()
        
        atomic.AddInt64(&amp;h.count, 1)
        atomic.AddInt64(&amp;h.sum, int64(value*1000)) // Store in milliseconds for precision
        
        for i, bucket := range h.buckets </span><span class="cov8" title="1">{
                if value &lt;= bucket </span><span class="cov8" title="1">{
                        atomic.AddInt64(&amp;h.counts[i], 1)
                        return
                }</span>
        }
        // +Inf bucket
        <span class="cov8" title="1">atomic.AddInt64(&amp;h.counts[len(h.buckets)], 1)</span>
}

func (h *Histogram) Get() map[string]interface{} <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        
        bucketCounts := make(map[string]int64)
        for i, bucket := range h.buckets </span><span class="cov8" title="1">{
                bucketCounts[fmt.Sprintf("le_%g", bucket)] = atomic.LoadInt64(&amp;h.counts[i])
        }</span>
        <span class="cov8" title="1">bucketCounts["le_+Inf"] = atomic.LoadInt64(&amp;h.counts[len(h.buckets)])
        
        return map[string]interface{}{
                "buckets": bucketCounts,
                "sum":     float64(atomic.LoadInt64(&amp;h.sum)) / 1000.0,
                "count":   atomic.LoadInt64(&amp;h.count),
        }</span>
}

// Summary tracks quantiles of observations
type Summary struct {
        name      string
        help      string
        count     int64
        sum       int64
        quantiles []float64
        labels    map[string]string
        values    []float64
        mu        sync.RWMutex
}

func (mr *MetricsRegistry) NewSummary(name, help string, quantiles []float64, labels map[string]string) *Summary <span class="cov8" title="1">{
        mr.mu.Lock()
        defer mr.mu.Unlock()
        
        if quantiles == nil </span><span class="cov8" title="1">{
                quantiles = []float64{0.5, 0.9, 0.95, 0.99}
        }</span>
        
        <span class="cov8" title="1">summary := &amp;Summary{
                name:      name,
                help:      help,
                quantiles: quantiles,
                labels:    labels,
                values:    make([]float64, 0, 1000), // Buffer for recent values
        }
        
        mr.summaries[name] = summary
        return summary</span>
}

func (s *Summary) Observe(value float64) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        
        atomic.AddInt64(&amp;s.count, 1)
        atomic.AddInt64(&amp;s.sum, int64(value*1000))
        
        // Keep only recent values for quantile calculation
        s.values = append(s.values, value)
        if len(s.values) &gt; 1000 </span><span class="cov0" title="0">{
                s.values = s.values[len(s.values)-1000:]
        }</span>
}

func (s *Summary) Get() map[string]interface{} <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        
        // Calculate quantiles (simplified implementation)
        quantileValues := make(map[string]float64)
        if len(s.values) &gt; 0 </span><span class="cov8" title="1">{
                for _, q := range s.quantiles </span><span class="cov8" title="1">{
                        idx := int(float64(len(s.values)-1) * q)
                        if idx &lt; len(s.values) </span><span class="cov8" title="1">{
                                quantileValues[fmt.Sprintf("quantile_%g", q)] = s.values[idx]
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return map[string]interface{}{
                "quantiles": quantileValues,
                "sum":       float64(atomic.LoadInt64(&amp;s.sum)) / 1000.0,
                "count":     atomic.LoadInt64(&amp;s.count),
        }</span>
}

// GetAllMetrics returns all metrics as a snapshot
func (mr *MetricsRegistry) GetAllMetrics() map[string]*Metric <span class="cov8" title="1">{
        mr.mu.RLock()
        defer mr.mu.RUnlock()
        
        result := make(map[string]*Metric)
        now := time.Now()
        
        // Add counters
        for name, counter := range mr.counters </span><span class="cov8" title="1">{
                result[name] = &amp;Metric{
                        Name:      name,
                        Type:      MetricTypeCounter,
                        Value:     counter.Get(),
                        Labels:    counter.labels,
                        Help:      counter.help,
                        Timestamp: now,
                        Unit:      "total",
                }
        }</span>
        
        // Add gauges
        <span class="cov8" title="1">for name, gauge := range mr.gauges </span><span class="cov8" title="1">{
                result[name] = &amp;Metric{
                        Name:      name,
                        Type:      MetricTypeGauge,
                        Value:     gauge.Get(),
                        Labels:    gauge.labels,
                        Help:      gauge.help,
                        Timestamp: now,
                }
        }</span>
        
        // Add histograms
        <span class="cov8" title="1">for name, histogram := range mr.histograms </span><span class="cov8" title="1">{
                result[name] = &amp;Metric{
                        Name:       name,
                        Type:       MetricTypeHistogram,
                        Labels:     histogram.labels,
                        Help:       histogram.help,
                        Timestamp:  now,
                        Unit:       "seconds",
                        Additional: histogram.Get(),
                }
        }</span>
        
        // Add summaries
        <span class="cov8" title="1">for name, summary := range mr.summaries </span><span class="cov8" title="1">{
                result[name] = &amp;Metric{
                        Name:       name,
                        Type:       MetricTypeSummary,
                        Labels:     summary.labels,
                        Help:       summary.help,
                        Timestamp:  now,
                        Unit:       "seconds",
                        Additional: summary.Get(),
                }
        }</span>
        
        <span class="cov8" title="1">return result</span>
}

// KVStoreMetrics contains application-specific metrics
type KVStoreMetrics struct {
        registry *MetricsRegistry
        
        // Request metrics
        RequestsTotal     *Counter
        RequestDuration   *Histogram
        RequestErrors     *Counter
        
        // Storage metrics
        StorageOperations *Counter
        StorageErrors     *Counter
        StorageSize       *Gauge
        StorageEntries    *Gauge
        
        // System metrics
        MemoryUsage       *Gauge
        GoroutineCount    *Gauge
        GCDuration        *Histogram
        
        // HTTP metrics
        HTTPRequests      *Counter
        HTTPDuration      *Histogram
        HTTPResponseSize  *Histogram
        
        // gRPC metrics (when implemented)
        GRPCRequests      *Counter
        GRPCDuration      *Histogram
        GRPCErrors        *Counter
}

// NewKVStoreMetrics creates application-specific metrics
func NewKVStoreMetrics() *KVStoreMetrics <span class="cov8" title="1">{
        registry := NewMetricsRegistry()
        
        return &amp;KVStoreMetrics{
                registry: registry,
                
                // Request metrics
                RequestsTotal: registry.NewCounter("kvstore_requests_total", "Total number of requests", map[string]string{"method": ""}),
                RequestDuration: registry.NewHistogram("kvstore_request_duration_seconds", "Request duration in seconds", nil, nil),
                RequestErrors: registry.NewCounter("kvstore_request_errors_total", "Total number of request errors", map[string]string{"type": ""}),
                
                // Storage metrics
                StorageOperations: registry.NewCounter("kvstore_storage_operations_total", "Total storage operations", map[string]string{"operation": ""}),
                StorageErrors: registry.NewCounter("kvstore_storage_errors_total", "Total storage errors", map[string]string{"operation": ""}),
                StorageSize: registry.NewGauge("kvstore_storage_size_bytes", "Current storage size in bytes", nil),
                StorageEntries: registry.NewGauge("kvstore_storage_entries", "Current number of stored entries", nil),
                
                // System metrics
                MemoryUsage: registry.NewGauge("kvstore_memory_usage_bytes", "Current memory usage in bytes", nil),
                GoroutineCount: registry.NewGauge("kvstore_goroutines", "Current number of goroutines", nil),
                GCDuration: registry.NewHistogram("kvstore_gc_duration_seconds", "Garbage collection duration", nil, nil),
                
                // HTTP metrics
                HTTPRequests: registry.NewCounter("kvstore_http_requests_total", "Total HTTP requests", map[string]string{"method": "", "path": "", "status": ""}),
                HTTPDuration: registry.NewHistogram("kvstore_http_request_duration_seconds", "HTTP request duration", nil, nil),
                HTTPResponseSize: registry.NewHistogram("kvstore_http_response_size_bytes", "HTTP response size in bytes", nil, nil),
                
                // gRPC metrics
                GRPCRequests: registry.NewCounter("kvstore_grpc_requests_total", "Total gRPC requests", map[string]string{"method": "", "status": ""}),
                GRPCDuration: registry.NewHistogram("kvstore_grpc_request_duration_seconds", "gRPC request duration", nil, nil),
                GRPCErrors: registry.NewCounter("kvstore_grpc_errors_total", "Total gRPC errors", map[string]string{"method": "", "code": ""}),
        }
}</span>

// UpdateSystemMetrics updates system-level metrics
func (m *KVStoreMetrics) UpdateSystemMetrics() <span class="cov8" title="1">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)
        
        m.MemoryUsage.Set(float64(memStats.Alloc))
        m.GoroutineCount.Set(float64(runtime.NumGoroutine()))
        
        // GC metrics
        if memStats.NumGC &gt; 0 </span><span class="cov0" title="0">{
                gcPause := float64(memStats.PauseNs[(memStats.NumGC+255)%256]) / 1e9
                m.GCDuration.Observe(gcPause)
        }</span>
}

// GetRegistry returns the metrics registry
func (m *KVStoreMetrics) GetRegistry() *MetricsRegistry <span class="cov8" title="1">{
        return m.registry
}</span>

// MetricsCollector periodically updates system metrics
type MetricsCollector struct {
        metrics  *KVStoreMetrics
        interval time.Duration
        stopChan chan struct{}
}

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector(metrics *KVStoreMetrics, interval time.Duration) *MetricsCollector <span class="cov8" title="1">{
        return &amp;MetricsCollector{
                metrics:  metrics,
                interval: interval,
                stopChan: make(chan struct{}),
        }
}</span>

// Start begins collecting metrics
func (mc *MetricsCollector) Start() <span class="cov8" title="1">{
        ticker := time.NewTicker(mc.interval)
        go func() </span><span class="cov8" title="1">{
                defer ticker.Stop()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                mc.metrics.UpdateSystemMetrics()</span>
                        case &lt;-mc.stopChan:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

// Stop stops collecting metrics
func (mc *MetricsCollector) Stop() <span class="cov8" title="1">{
        close(mc.stopChan)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package monitoring

import (
        "fmt"
        "net/http"
        "sort"
        "strings"
        "time"
)

// PrometheusExporter exports metrics in Prometheus format
type PrometheusExporter struct {
        registry *MetricsRegistry
        kvMetrics *KVStoreMetrics
}

// NewPrometheusExporter creates a new Prometheus exporter
func NewPrometheusExporter(registry *MetricsRegistry, kvMetrics *KVStoreMetrics) *PrometheusExporter <span class="cov8" title="1">{
        return &amp;PrometheusExporter{
                registry:  registry,
                kvMetrics: kvMetrics,
        }
}</span>

// ServeHTTP implements the http.Handler interface for Prometheus metrics endpoint
func (pe *PrometheusExporter) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        
        // Update system metrics before export
        pe.kvMetrics.UpdateSystemMetrics()
        
        metrics := pe.registry.GetAllMetrics()
        
        // Sort metrics by name for consistent output
        var names []string
        for name := range metrics </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">sort.Strings(names)
        
        // Write metrics in Prometheus format
        for _, name := range names </span><span class="cov8" title="1">{
                metric := metrics[name]
                pe.writePrometheusMetric(w, metric)
        }</span>
        
        // Add custom system metrics
        <span class="cov8" title="1">pe.writeSystemMetrics(w)</span>
}

func (pe *PrometheusExporter) writePrometheusMetric(w http.ResponseWriter, metric *Metric) <span class="cov8" title="1">{
        // Write HELP line
        if metric.Help != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "# HELP %s %s\n", metric.Name, metric.Help)
        }</span>
        
        // Write TYPE line
        <span class="cov8" title="1">fmt.Fprintf(w, "# TYPE %s %s\n", metric.Name, string(metric.Type))
        
        // Write metric value
        switch metric.Type </span>{
        case MetricTypeCounter, MetricTypeGauge:<span class="cov8" title="1">
                pe.writeSimpleMetric(w, metric)</span>
        case MetricTypeHistogram:<span class="cov8" title="1">
                pe.writeHistogramMetric(w, metric)</span>
        case MetricTypeSummary:<span class="cov0" title="0">
                pe.writeSummaryMetric(w, metric)</span>
        }
        
        <span class="cov8" title="1">fmt.Fprintf(w, "\n")</span>
}

func (pe *PrometheusExporter) writeSimpleMetric(w http.ResponseWriter, metric *Metric) <span class="cov8" title="1">{
        labelStr := pe.formatLabels(metric.Labels)
        fmt.Fprintf(w, "%s%s %.6f %d\n", 
                metric.Name, labelStr, metric.Value, metric.Timestamp.Unix())
}</span>

func (pe *PrometheusExporter) writeHistogramMetric(w http.ResponseWriter, metric *Metric) <span class="cov8" title="1">{
        baseName := metric.Name
        labelStr := pe.formatLabels(metric.Labels)
        timestamp := metric.Timestamp.Unix()
        
        if metric.Additional != nil </span><span class="cov8" title="1">{
                if buckets, ok := metric.Additional["buckets"].(map[string]int64); ok </span><span class="cov8" title="1">{
                        // Write bucket counts
                        for bucket, count := range buckets </span><span class="cov8" title="1">{
                                if strings.HasPrefix(bucket, "le_") </span><span class="cov8" title="1">{
                                        le := strings.TrimPrefix(bucket, "le_")
                                        bucketLabels := pe.addLabel(metric.Labels, "le", le)
                                        bucketLabelStr := pe.formatLabels(bucketLabels)
                                        fmt.Fprintf(w, "%s_bucket%s %d %d\n", 
                                                baseName, bucketLabelStr, count, timestamp)
                                }</span>
                        }
                }
                
                // Write sum and count
                <span class="cov8" title="1">if sum, ok := metric.Additional["sum"].(float64); ok </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "%s_sum%s %.6f %d\n", 
                                baseName, labelStr, sum, timestamp)
                }</span>
                <span class="cov8" title="1">if count, ok := metric.Additional["count"].(int64); ok </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "%s_count%s %d %d\n", 
                                baseName, labelStr, count, timestamp)
                }</span>
        }
}

func (pe *PrometheusExporter) writeSummaryMetric(w http.ResponseWriter, metric *Metric) <span class="cov0" title="0">{
        baseName := metric.Name
        labelStr := pe.formatLabels(metric.Labels)
        timestamp := metric.Timestamp.Unix()
        
        if metric.Additional != nil </span><span class="cov0" title="0">{
                if quantiles, ok := metric.Additional["quantiles"].(map[string]float64); ok </span><span class="cov0" title="0">{
                        // Write quantiles
                        for quantile, value := range quantiles </span><span class="cov0" title="0">{
                                if strings.HasPrefix(quantile, "quantile_") </span><span class="cov0" title="0">{
                                        q := strings.TrimPrefix(quantile, "quantile_")
                                        quantileLabels := pe.addLabel(metric.Labels, "quantile", q)
                                        quantileLabelStr := pe.formatLabels(quantileLabels)
                                        fmt.Fprintf(w, "%s%s %.6f %d\n", 
                                                baseName, quantileLabelStr, value, timestamp)
                                }</span>
                        }
                }
                
                // Write sum and count
                <span class="cov0" title="0">if sum, ok := metric.Additional["sum"].(float64); ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "%s_sum%s %.6f %d\n", 
                                baseName, labelStr, sum, timestamp)
                }</span>
                <span class="cov0" title="0">if count, ok := metric.Additional["count"].(int64); ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "%s_count%s %d %d\n", 
                                baseName, labelStr, count, timestamp)
                }</span>
        }
}

func (pe *PrometheusExporter) writeSystemMetrics(w http.ResponseWriter) <span class="cov8" title="1">{
        timestamp := time.Now().Unix()
        
        // Write build info
        fmt.Fprintf(w, "# HELP kvstore_build_info Build information\n")
        fmt.Fprintf(w, "# TYPE kvstore_build_info gauge\n")
        fmt.Fprintf(w, "kvstore_build_info{version=\"1.0.0\",go_version=\"%s\"} 1 %d\n", 
                getGoVersion(), timestamp)
        fmt.Fprintf(w, "\n")
        
        // Write uptime
        uptime := time.Since(time.Now()).Seconds() // This would be actual uptime in real implementation
        fmt.Fprintf(w, "# HELP kvstore_uptime_seconds Uptime in seconds\n")
        fmt.Fprintf(w, "# TYPE kvstore_uptime_seconds counter\n")
        fmt.Fprintf(w, "kvstore_uptime_seconds %.6f %d\n", uptime, timestamp)
        fmt.Fprintf(w, "\n")
}</span>

func (pe *PrometheusExporter) formatLabels(labels map[string]string) string <span class="cov8" title="1">{
        if len(labels) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">var labelPairs []string
        for key, value := range labels </span><span class="cov8" title="1">{
                if value != "" </span><span class="cov8" title="1">{
                        labelPairs = append(labelPairs, fmt.Sprintf("%s=\"%s\"", key, escapePrometheusValue(value)))
                }</span>
        }
        
        <span class="cov8" title="1">if len(labelPairs) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">sort.Strings(labelPairs)
        return "{" + strings.Join(labelPairs, ",") + "}"</span>
}

func (pe *PrometheusExporter) addLabel(labels map[string]string, key, value string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        for k, v := range labels </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">result[key] = value
        return result</span>
}

func escapePrometheusValue(value string) string <span class="cov8" title="1">{
        // Escape special characters for Prometheus labels
        value = strings.ReplaceAll(value, "\\", "\\\\")
        value = strings.ReplaceAll(value, "\"", "\\\"")
        value = strings.ReplaceAll(value, "\n", "\\n")
        return value
}</span>

func getGoVersion() string <span class="cov8" title="1">{
        // In a real implementation, this would use runtime.Version()
        return "go1.21.0"
}</span>

// PrometheusConfig holds Prometheus-specific configuration
type PrometheusConfig struct {
        Enabled    bool   `yaml:"enabled" json:"enabled"`
        Path       string `yaml:"path" json:"path"`
        Port       int    `yaml:"port" json:"port"`
        Namespace  string `yaml:"namespace" json:"namespace"`
        Subsystem  string `yaml:"subsystem" json:"subsystem"`
}

// DefaultPrometheusConfig returns default Prometheus configuration
func DefaultPrometheusConfig() PrometheusConfig <span class="cov0" title="0">{
        return PrometheusConfig{
                Enabled:   true,
                Path:      "/metrics",
                Port:      2112,
                Namespace: "kvstore",
                Subsystem: "",
        }
}</span>

// MetricsMiddleware is HTTP middleware that collects request metrics
func (pe *PrometheusExporter) MetricsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                
                // Wrap response writer to capture status code and size
                wrapped := &amp;metricsResponseWriter{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                        size:          0,
                }
                
                // Process request
                next.ServeHTTP(wrapped, r)
                
                // Record metrics
                duration := time.Since(start)
                pe.kvMetrics.HTTPRequests.Inc()
                pe.kvMetrics.HTTPDuration.Observe(duration.Seconds())
                pe.kvMetrics.HTTPResponseSize.Observe(float64(wrapped.size))
                
                // Update labels for more specific metrics
                labels := map[string]string{
                        "method": r.Method,
                        "path":   r.URL.Path,
                        "status": fmt.Sprintf("%d", wrapped.statusCode),
                }
                
                httpRequestsWithLabels := pe.kvMetrics.registry.NewCounter(
                        "kvstore_http_requests_with_labels_total", 
                        "Total HTTP requests with labels", 
                        labels,
                )
                httpRequestsWithLabels.Inc()
        }</span>)
}

type metricsResponseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int64
}

func (mrw *metricsResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        mrw.statusCode = code
        mrw.ResponseWriter.WriteHeader(code)
}</span>

func (mrw *metricsResponseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        size, err := mrw.ResponseWriter.Write(data)
        mrw.size += int64(size)
        return size, err
}</span>

// PrometheusMetricsHandler creates a simple metrics handler
func PrometheusMetricsHandler(kvMetrics *KVStoreMetrics) http.HandlerFunc <span class="cov0" title="0">{
        exporter := NewPrometheusExporter(kvMetrics.GetRegistry(), kvMetrics)
        return exporter.ServeHTTP
}</span>

// Sample Prometheus configuration for docker-compose or Kubernetes
const PrometheusConfigYAML = `
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'kvstore'
    static_configs:
      - targets: ['localhost:2112']
    scrape_interval: 5s
    metrics_path: /metrics
    
  - job_name: 'kvstore-health'
    static_configs:
      - targets: ['localhost:8080']
    scrape_interval: 10s
    metrics_path: /api/v1/health
    
rule_files:
  - "kvstore_alerts.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
`

// Sample Grafana dashboard JSON (simplified)
const GrafanaDashboardJSON = `{
  "dashboard": {
    "id": null,
    "title": "KVStore Monitoring",
    "tags": ["kvstore", "monitoring"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(kvstore_http_requests_total[5m])",
            "legendFormat": "{{method}} {{path}}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Response Time",
        "type": "graph", 
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(kvstore_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.50, rate(kvstore_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "50th percentile"
          }
        ]
      },
      {
        "id": 3,
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "kvstore_memory_usage_bytes / 1024 / 1024",
            "legendFormat": "Memory (MB)"
          }
        ]
      },
      {
        "id": 4,
        "title": "Storage Metrics",
        "type": "graph",
        "targets": [
          {
            "expr": "kvstore_storage_size_bytes",
            "legendFormat": "Storage Size"
          },
          {
            "expr": "kvstore_storage_entries",
            "legendFormat": "Entry Count"
          }
        ]
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}`</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "context"
        "fmt"
        "net"
        "time"

        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/logging"
        "distributed-kvstore/internal/storage"
        "distributed-kvstore/proto/kvstore"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// GRPCServer implements the KVStore gRPC service
type GRPCServer struct {
        kvstore.UnimplementedKVStoreServer
        
        config   *config.Config
        storage  storage.StorageEngine
        logger   *logging.Logger
        server   *grpc.Server
        listener net.Listener
}

// NewGRPCServer creates a new gRPC server
func NewGRPCServer(cfg *config.Config, storageEngine storage.StorageEngine, logger *logging.Logger) *GRPCServer <span class="cov8" title="1">{
        return &amp;GRPCServer{
                config:  cfg,
                storage: storageEngine,
                logger:  logger,
        }
}</span>

// Start starts the gRPC server
func (s *GRPCServer) Start() error <span class="cov0" title="0">{
        address := fmt.Sprintf("%s:%d", s.config.Server.Host, s.config.Server.GRPCPort)
        
        listener, err := net.Listen("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %w", address, err)
        }</span>
        <span class="cov0" title="0">s.listener = listener
        
        // Create gRPC server with options
        opts := []grpc.ServerOption{
                grpc.UnaryInterceptor(s.loggingInterceptor),
        }
        
        s.server = grpc.NewServer(opts...)
        kvstore.RegisterKVStoreServer(s.server, s)
        
        s.logger.Info("Starting gRPC server", "address", address)
        
        go func() </span><span class="cov0" title="0">{
                if err := s.server.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("gRPC server failed", "error", err)
                }</span>
        }()
        
        <span class="cov0" title="0">return nil</span>
}

// Stop stops the gRPC server
func (s *GRPCServer) Stop() <span class="cov0" title="0">{
        s.logger.Info("Stopping gRPC server")
        
        if s.server != nil </span><span class="cov0" title="0">{
                s.server.GracefulStop()
        }</span>
        
        <span class="cov0" title="0">if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>
}

// Put implements the Put RPC
func (s *GRPCServer) Put(ctx context.Context, req *kvstore.PutRequest) (*kvstore.PutResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "Put request", "key", req.Key)
        
        if req.Key == "" </span><span class="cov8" title="1">{
                return &amp;kvstore.PutResponse{
                        Success: false,
                        Error:   "key cannot be empty",
                }, nil
        }</span>
        
        <span class="cov8" title="1">err := s.storage.Put([]byte(req.Key), req.Value)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Put failed", "key", req.Key, "error", err)
                return &amp;kvstore.PutResponse{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>
        
        <span class="cov8" title="1">return &amp;kvstore.PutResponse{
                Success: true,
        }, nil</span>
}

// Get implements the Get RPC
func (s *GRPCServer) Get(ctx context.Context, req *kvstore.GetRequest) (*kvstore.GetResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "Get request", "key", req.Key)
        
        if req.Key == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "key cannot be empty")
        }</span>
        
        <span class="cov8" title="1">value, err := s.storage.Get([]byte(req.Key))
        if err != nil </span><span class="cov8" title="1">{
                // Check if it's a "key not found" error
                if err.Error() == "Key not found" </span><span class="cov0" title="0">{ // This should match your storage engine's error
                        return &amp;kvstore.GetResponse{
                                Found: false,
                        }, nil
                }</span>
                
                <span class="cov8" title="1">s.logger.ErrorContext(ctx, "Get failed", "key", req.Key, "error", err)
                return &amp;kvstore.GetResponse{
                        Found: false,
                        Error: err.Error(),
                }, nil</span>
        }
        
        <span class="cov8" title="1">return &amp;kvstore.GetResponse{
                Found:     true,
                Value:     value,
                CreatedAt: time.Now().Unix(), // In a real implementation, this would come from storage
        }, nil</span>
}

// Delete implements the Delete RPC
func (s *GRPCServer) Delete(ctx context.Context, req *kvstore.DeleteRequest) (*kvstore.DeleteResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "Delete request", "key", req.Key)
        
        if req.Key == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "key cannot be empty")
        }</span>
        
        // Check if key exists before deletion
        <span class="cov8" title="1">existed, err := s.storage.Exists([]byte(req.Key))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Exists check failed", "key", req.Key, "error", err)
                return &amp;kvstore.DeleteResponse{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>
        
        <span class="cov8" title="1">err = s.storage.Delete([]byte(req.Key))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Delete failed", "key", req.Key, "error", err)
                return &amp;kvstore.DeleteResponse{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>
        
        <span class="cov8" title="1">return &amp;kvstore.DeleteResponse{
                Success: true,
                Existed: existed,
        }, nil</span>
}

// Exists implements the Exists RPC
func (s *GRPCServer) Exists(ctx context.Context, req *kvstore.ExistsRequest) (*kvstore.ExistsResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "Exists request", "key", req.Key)
        
        if req.Key == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "key cannot be empty")
        }</span>
        
        <span class="cov8" title="1">exists, err := s.storage.Exists([]byte(req.Key))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Exists failed", "key", req.Key, "error", err)
                return &amp;kvstore.ExistsResponse{
                        Exists: false,
                        Error:  err.Error(),
                }, nil
        }</span>
        
        <span class="cov8" title="1">return &amp;kvstore.ExistsResponse{
                Exists: exists,
        }, nil</span>
}

// List implements the List RPC
func (s *GRPCServer) List(ctx context.Context, req *kvstore.ListRequest) (*kvstore.ListResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "List request", "prefix", req.Prefix, "limit", req.Limit)
        
        items, err := s.storage.List([]byte(req.Prefix))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "List failed", "prefix", req.Prefix, "error", err)
                return &amp;kvstore.ListResponse{
                        Error: err.Error(),
                }, nil
        }</span>
        
        // Convert map to protobuf KeyValue slice
        <span class="cov8" title="1">var kvItems []*kvstore.KeyValue
        count := 0
        limit := int(req.Limit)
        
        for key, value := range items </span><span class="cov8" title="1">{
                if limit &gt; 0 &amp;&amp; count &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov8" title="1">kvItems = append(kvItems, &amp;kvstore.KeyValue{
                        Key:       key,
                        Value:     value,
                        CreatedAt: time.Now().Unix(), // In a real implementation, this would come from storage
                })
                count++</span>
        }
        
        <span class="cov8" title="1">return &amp;kvstore.ListResponse{
                Items:   kvItems,
                HasMore: limit &gt; 0 &amp;&amp; len(items) &gt; limit,
        }, nil</span>
}

// ListKeys implements the ListKeys RPC
func (s *GRPCServer) ListKeys(ctx context.Context, req *kvstore.ListKeysRequest) (*kvstore.ListKeysResponse, error) <span class="cov0" title="0">{
        s.logger.DebugContext(ctx, "ListKeys request", "prefix", req.Prefix, "limit", req.Limit)
        
        items, err := s.storage.List([]byte(req.Prefix))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "ListKeys failed", "prefix", req.Prefix, "error", err)
                return &amp;kvstore.ListKeysResponse{
                        Error: err.Error(),
                }, nil
        }</span>
        
        // Extract keys only
        <span class="cov0" title="0">var keys []string
        count := 0
        limit := int(req.Limit)
        
        for key := range items </span><span class="cov0" title="0">{
                if limit &gt; 0 &amp;&amp; count &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">keys = append(keys, key)
                count++</span>
        }
        
        <span class="cov0" title="0">return &amp;kvstore.ListKeysResponse{
                Keys:    keys,
                HasMore: limit &gt; 0 &amp;&amp; len(items) &gt; limit,
        }, nil</span>
}

// BatchPut implements the BatchPut RPC
func (s *GRPCServer) BatchPut(ctx context.Context, req *kvstore.BatchPutRequest) (*kvstore.BatchPutResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "BatchPut request", "items", len(req.Items))
        
        var successCount int32
        var errors []*kvstore.BatchError
        
        for _, item := range req.Items </span><span class="cov8" title="1">{
                if item.Key == "" </span><span class="cov0" title="0">{
                        errors = append(errors, &amp;kvstore.BatchError{
                                Key:   item.Key,
                                Error: "key cannot be empty",
                        })
                        continue</span>
                }
                
                <span class="cov8" title="1">err := s.storage.Put([]byte(item.Key), item.Value)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, &amp;kvstore.BatchError{
                                Key:   item.Key,
                                Error: err.Error(),
                        })
                }</span> else<span class="cov8" title="1"> {
                        successCount++
                }</span>
        }
        
        <span class="cov8" title="1">return &amp;kvstore.BatchPutResponse{
                SuccessCount: successCount,
                ErrorCount:   int32(len(errors)),
                Errors:       errors,
        }, nil</span>
}

// BatchGet implements the BatchGet RPC
func (s *GRPCServer) BatchGet(ctx context.Context, req *kvstore.BatchGetRequest) (*kvstore.BatchGetResponse, error) <span class="cov8" title="1">{
        s.logger.DebugContext(ctx, "BatchGet request", "keys", len(req.Keys))
        
        var results []*kvstore.GetResult
        
        for _, key := range req.Keys </span><span class="cov8" title="1">{
                if key == "" </span><span class="cov0" title="0">{
                        results = append(results, &amp;kvstore.GetResult{
                                Key:   key,
                                Found: false,
                        })
                        continue</span>
                }
                
                <span class="cov8" title="1">value, err := s.storage.Get([]byte(key))
                if err != nil </span><span class="cov8" title="1">{
                        results = append(results, &amp;kvstore.GetResult{
                                Key:   key,
                                Found: false,
                        })
                }</span> else<span class="cov8" title="1"> {
                        results = append(results, &amp;kvstore.GetResult{
                                Key:       key,
                                Found:     true,
                                Value:     value,
                                CreatedAt: time.Now().Unix(),
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return &amp;kvstore.BatchGetResponse{
                Results: results,
        }, nil</span>
}

// BatchDelete implements the BatchDelete RPC
func (s *GRPCServer) BatchDelete(ctx context.Context, req *kvstore.BatchDeleteRequest) (*kvstore.BatchDeleteResponse, error) <span class="cov0" title="0">{
        s.logger.DebugContext(ctx, "BatchDelete request", "keys", len(req.Keys))
        
        var successCount int32
        var errors []*kvstore.BatchError
        
        for _, key := range req.Keys </span><span class="cov0" title="0">{
                if key == "" </span><span class="cov0" title="0">{
                        errors = append(errors, &amp;kvstore.BatchError{
                                Key:   key,
                                Error: "key cannot be empty",
                        })
                        continue</span>
                }
                
                <span class="cov0" title="0">err := s.storage.Delete([]byte(key))
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, &amp;kvstore.BatchError{
                                Key:   key,
                                Error: err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        successCount++
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;kvstore.BatchDeleteResponse{
                SuccessCount: successCount,
                ErrorCount:   int32(len(errors)),
                Errors:       errors,
        }, nil</span>
}

// Health implements the Health RPC
func (s *GRPCServer) Health(ctx context.Context, req *kvstore.HealthRequest) (*kvstore.HealthResponse, error) <span class="cov8" title="1">{
        return &amp;kvstore.HealthResponse{
                Healthy:       true,
                Status:        "healthy",
                UptimeSeconds: int64(time.Since(time.Now()).Seconds()), // This should track actual uptime
                Version:       "1.0.0",
        }, nil
}</span>

// Stats implements the Stats RPC
func (s *GRPCServer) Stats(ctx context.Context, req *kvstore.StatsRequest) (*kvstore.StatsResponse, error) <span class="cov8" title="1">{
        stats := s.storage.Stats()
        
        // Convert storage stats to protobuf format
        details := make(map[string]string)
        if req.IncludeDetails </span><span class="cov8" title="1">{
                for key, value := range stats </span><span class="cov8" title="1">{
                        details[key] = fmt.Sprintf("%v", value)
                }</span>
        }
        
        <span class="cov8" title="1">return &amp;kvstore.StatsResponse{
                TotalKeys: 0,    // This should be extracted from stats
                TotalSize: 0,    // This should be extracted from stats  
                LsmSize:   0,    // This should be extracted from stats
                VlogSize:  0,    // This should be extracted from stats
                Details:   details,
        }, nil</span>
}

// Backup implements the Backup RPC
func (s *GRPCServer) Backup(ctx context.Context, req *kvstore.BackupRequest) (*kvstore.BackupResponse, error) <span class="cov0" title="0">{
        s.logger.InfoContext(ctx, "Backup request", "path", req.Path)
        
        err := s.storage.Backup(req.Path)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Backup failed", "path", req.Path, "error", err)
                return &amp;kvstore.BackupResponse{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>
        
        <span class="cov0" title="0">return &amp;kvstore.BackupResponse{
                Success: true,
                Path:    req.Path,
        }, nil</span>
}

// Restore implements the Restore RPC
func (s *GRPCServer) Restore(ctx context.Context, req *kvstore.RestoreRequest) (*kvstore.RestoreResponse, error) <span class="cov0" title="0">{
        s.logger.InfoContext(ctx, "Restore request", "path", req.Path)
        
        err := s.storage.Restore(req.Path)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "Restore failed", "path", req.Path, "error", err)
                return &amp;kvstore.RestoreResponse{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>
        
        <span class="cov0" title="0">return &amp;kvstore.RestoreResponse{
                Success: true,
        }, nil</span>
}

// Status implements the Status RPC (placeholder for cluster functionality)
func (s *GRPCServer) Status(ctx context.Context, req *kvstore.StatusRequest) (*kvstore.StatusResponse, error) <span class="cov0" title="0">{
        return &amp;kvstore.StatusResponse{
                NodeId: s.config.Cluster.NodeID,
                Role:   "standalone", // In a real cluster implementation, this would be dynamic
                State:  "running",
        }, nil
}</span>

// loggingInterceptor is a gRPC unary interceptor for logging
func (s *GRPCServer) loggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{
        start := time.Now()
        
        resp, err := handler(ctx, req)
        
        duration := time.Since(start)
        
        if err != nil </span><span class="cov0" title="0">{
                s.logger.ErrorContext(ctx, "gRPC request failed",
                        "method", info.FullMethod,
                        "duration", duration,
                        "error", err,
                )
        }</span> else<span class="cov0" title="0"> {
                s.logger.DebugContext(ctx, "gRPC request completed",
                        "method", info.FullMethod,
                        "duration", duration,
                )
        }</span>
        
        <span class="cov0" title="0">return resp, err</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/logging"
        "distributed-kvstore/internal/storage"
)

// SimpleGRPCServer represents a simplified gRPC server for demo purposes
type SimpleGRPCServer struct {
        config  *config.Config
        storage storage.StorageEngine
        logger  *logging.Logger
}

// NewSimpleGRPCServer creates a new simple gRPC server
func NewSimpleGRPCServer(cfg *config.Config, storageEngine storage.StorageEngine, logger *logging.Logger) *SimpleGRPCServer <span class="cov0" title="0">{
        return &amp;SimpleGRPCServer{
                config:  cfg,
                storage: storageEngine,
                logger:  logger,
        }
}</span>

// Start starts the simple gRPC server
func (s *SimpleGRPCServer) Start() error <span class="cov0" title="0">{
        s.logger.Info("Simple gRPC server would start here",
                "address", s.config.Server.Host+":"+string(rune(s.config.Server.GRPCPort)),
                "service", "grpc",
        )
        // For demo purposes, we'll just log that it would start
        return nil
}</span>

// Stop stops the simple gRPC server
func (s *SimpleGRPCServer) Stop() <span class="cov0" title="0">{
        s.logger.Info("Simple gRPC server stopped")
}</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"

        "distributed-kvstore/internal/api"
        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/logging"
        "distributed-kvstore/internal/monitoring"
        "distributed-kvstore/internal/storage"
)

// HTTPServer represents the HTTP REST API server
type HTTPServer struct {
        config      *config.Config
        storage     storage.StorageEngine
        logger      *logging.Logger
        monitoring  *monitoring.MonitoringService
        server      *http.Server
        restHandler *api.RESTHandler
}

// NewHTTPServer creates a new HTTP server
func NewHTTPServer(cfg *config.Config, storageEngine storage.StorageEngine, logger *logging.Logger) *HTTPServer <span class="cov0" title="0">{
        // Initialize monitoring service
        monitoringService := monitoring.NewMonitoringService(storageEngine)
        
        // Create REST handler with monitoring
        restHandler := api.NewRESTHandler(storageEngine, logger, monitoringService)
        
        return &amp;HTTPServer{
                config:      cfg,
                storage:     storageEngine,
                logger:      logger,
                monitoring:  monitoringService,
                restHandler: restHandler,
        }
}</span>

// Start starts the HTTP server
func (s *HTTPServer) Start() error <span class="cov0" title="0">{
        addr := fmt.Sprintf("%s:%d", s.config.Server.Host, s.config.Server.Port)
        
        // Start monitoring service
        if s.monitoring != nil </span><span class="cov0" title="0">{
                s.monitoring.Start()
        }</span>
        
        <span class="cov0" title="0">router := s.restHandler.SetupRoutes()
        
        s.server = &amp;http.Server{
                Addr:         addr,
                Handler:      router,
                ReadTimeout:  s.config.Server.ReadTimeout,
                WriteTimeout: s.config.Server.WriteTimeout,
                IdleTimeout:  s.config.Server.IdleTimeout,
        }

        s.logger.Info("Starting HTTP server",
                "address", addr,
                "service", "http",
        )

        return s.server.ListenAndServe()</span>
}

// Stop stops the HTTP server gracefully
func (s *HTTPServer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        // Stop monitoring service
        if s.monitoring != nil </span><span class="cov0" title="0">{
                s.monitoring.Stop()
        }</span>
        
        <span class="cov0" title="0">if s.server != nil </span><span class="cov0" title="0">{
                s.logger.Info("Stopping HTTP server")
                return s.server.Shutdown(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/logging"
        "distributed-kvstore/internal/storage"
)

type Server struct {
        config      *config.Config
        logger      *logging.Logger
        storage     storage.StorageEngine
        grpcServer  *GRPCServer
        httpServer  *HTTPServer
        startTime   time.Time
}

func NewServer(cfg *config.Config) (*Server, error) <span class="cov0" title="0">{
        logger := logging.NewLogger(&amp;cfg.Logging)
        
        logger.Info("Initializing server",
                "node_id", cfg.Cluster.NodeID,
                "version", "1.0.0",
        )

        storageConfig := storage.Config{
                DataPath:   cfg.Storage.DataPath,
                InMemory:   cfg.Storage.InMemory,
                SyncWrites: cfg.Storage.SyncWrites,
                ValueLogGC: cfg.Storage.ValueLogGC,
                GCInterval: cfg.Storage.GCInterval,
        }

        storageEngine, err := storage.NewEngine(storageConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create storage engine: %w", err)
        }</span>

        <span class="cov0" title="0">grpcServer := NewGRPCServer(cfg, storageEngine, logger)
        httpServer := NewHTTPServer(cfg, storageEngine, logger)

        return &amp;Server{
                config:     cfg,
                logger:     logger,
                storage:    storageEngine,
                grpcServer: grpcServer,
                httpServer: httpServer,
                startTime:  time.Now(),
        }, nil</span>
}

func (s *Server) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting distributed key-value store server")

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        errChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                if err := s.grpcServer.Start(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("gRPC server failed: %w", err)
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := s.httpServer.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("HTTP server failed: %w", err)
                }</span>
        }()

        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        s.logger.Info("Server started successfully",
                "http_port", s.config.Server.Port,
                "grpc_port", s.config.Server.GRPCPort,
                "node_id", s.config.Cluster.NodeID,
        )

        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                s.logger.Error("Server encountered an error", "error", err.Error())
                return err</span>
        case sig := &lt;-sigChan:<span class="cov0" title="0">
                s.logger.Info("Received shutdown signal", "signal", sig)
                return s.Shutdown(ctx)</span>
        }
}

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Shutting down server")

        shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        done := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                s.grpcServer.Stop()
                
                if err := s.httpServer.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to stop HTTP server", "error", err.Error())
                }</span>

                <span class="cov0" title="0">if err := s.storage.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to close storage engine", "error", err.Error())
                        done &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">done &lt;- nil</span>
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Error during shutdown", "error", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">s.logger.Info("Server shutdown completed")
                return nil</span>
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                s.logger.Error("Shutdown timeout exceeded")
                return fmt.Errorf("shutdown timeout exceeded")</span>
        }
}

func (s *Server) GetUptime() time.Duration <span class="cov0" title="0">{
        return time.Since(s.startTime)
}</span>

// Note: Logger setup is now handled by the logging package</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "fmt"
        "log"
        "os"
        "time"

        "github.com/dgraph-io/badger/v4"
)

type Engine struct {
        db *badger.DB
}

var _ StorageEngine = (*Engine)(nil)

type Config struct {
        DataPath    string
        InMemory    bool
        SyncWrites  bool
        ValueLogGC  bool
        GCInterval  time.Duration
}

var _ StorageConfig = (*Config)(nil)

func (c *Config) GetDataPath() string <span class="cov8" title="1">{
        return c.DataPath
}</span>

func (c *Config) IsInMemory() bool <span class="cov8" title="1">{
        return c.InMemory
}</span>

func (c *Config) IsSyncWrites() bool <span class="cov8" title="1">{
        return c.SyncWrites
}</span>

func (c *Config) IsValueLogGC() bool <span class="cov8" title="1">{
        return c.ValueLogGC
}</span>

func (c *Config) GetGCInterval() time.Duration <span class="cov8" title="1">{
        return c.GCInterval
}</span>

func NewEngine(config Config) (*Engine, error) <span class="cov8" title="1">{
        opts := badger.DefaultOptions(config.DataPath)
        
        if config.InMemory </span><span class="cov8" title="1">{
                opts = opts.WithInMemory(true)
        }</span>
        
        <span class="cov8" title="1">opts = opts.WithSyncWrites(config.SyncWrites)
        opts = opts.WithLogger(nil) // Disable badger's default logger
        
        db, err := badger.Open(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open badger database: %w", err)
        }</span>

        <span class="cov8" title="1">engine := &amp;Engine{db: db}
        
        if config.ValueLogGC &amp;&amp; !config.InMemory </span><span class="cov8" title="1">{
                go engine.runGC(config.GCInterval)
        }</span>
        
        <span class="cov8" title="1">return engine, nil</span>
}

func (e *Engine) Put(key, value []byte) error <span class="cov8" title="1">{
        return e.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                return txn.Set(key, value)
        }</span>)
}

func (e *Engine) Get(key []byte) ([]byte, error) <span class="cov8" title="1">{
        var value []byte
        err := e.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                item, err := txn.Get(key)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                
                <span class="cov8" title="1">value, err = item.ValueCopy(nil)
                return err</span>
        })
        
        <span class="cov8" title="1">if err == badger.ErrKeyNotFound </span><span class="cov8" title="1">{
                return nil, ErrKeyNotFound
        }</span>
        
        <span class="cov8" title="1">return value, err</span>
}

func (e *Engine) Delete(key []byte) error <span class="cov8" title="1">{
        return e.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                return txn.Delete(key)
        }</span>)
}

func (e *Engine) Exists(key []byte) (bool, error) <span class="cov8" title="1">{
        err := e.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                _, err := txn.Get(key)
                return err
        }</span>)
        
        <span class="cov8" title="1">if err == badger.ErrKeyNotFound </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        
        <span class="cov8" title="1">return err == nil, err</span>
}

func (e *Engine) List(prefix []byte) (map[string][]byte, error) <span class="cov8" title="1">{
        result := make(map[string][]byte)
        
        err := e.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchSize = 10
                it := txn.NewIterator(opts)
                defer it.Close()
                
                for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() </span><span class="cov8" title="1">{
                        item := it.Item()
                        key := item.Key()
                        
                        value, err := item.ValueCopy(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        
                        <span class="cov8" title="1">result[string(key)] = value</span>
                }
                
                <span class="cov8" title="1">return nil</span>
        })
        
        <span class="cov8" title="1">return result, err</span>
}

func (e *Engine) Close() error <span class="cov8" title="1">{
        return e.db.Close()
}</span>

func (e *Engine) Backup(path string) error <span class="cov0" title="0">{
        file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        _, err = e.db.Backup(file, 0)
        return err</span>
}

func (e *Engine) Restore(path string) error <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open backup file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        return e.db.Load(file, 256)</span>
}

func (e *Engine) Stats() map[string]interface{} <span class="cov8" title="1">{
        lsm := e.db.LevelsToString()
        tables := e.db.Tables()
        lsmSize, vlogSize := e.db.Size()
        
        return map[string]interface{}{
                "lsm_structure": lsm,
                "tables":        tables,
                "lsm_size":      lsmSize,
                "vlog_size":     vlogSize,
                "total_size":    lsmSize + vlogSize,
        }
}</span>

func (e *Engine) runGC(interval time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov0" title="0">{
                again := true
                for again </span><span class="cov0" title="0">{
                        err := e.db.RunValueLogGC(0.7)
                        again = err == nil
                }</span>
                
                <span class="cov0" title="0">log.Printf("BadgerDB garbage collection completed")</span>
        }
}

var ErrKeyNotFound = fmt.Errorf("key not found")</pre>
		
		<pre class="file" id="file22" style="display: none">package testutil

import (
        "distributed-kvstore/internal/config"
        "distributed-kvstore/internal/logging"
        "distributed-kvstore/internal/storage"
        "fmt"
        "math/rand"
        "net/http"
        "net/http/httptest"
        "os"
        "strings"
        "testing"
        "time"
)

// TestStorageEngine creates a test storage engine with in-memory configuration
func TestStorageEngine(t *testing.T) *storage.Engine <span class="cov8" title="1">{
        t.Helper()
        
        config := storage.Config{
                DataPath:   "",
                InMemory:   true,
                SyncWrites: false,
                ValueLogGC: false,
        }
        
        engine, err := storage.NewEngine(config)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test storage engine: %v", err)
        }</span>
        
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                engine.Close()
        }</span>)
        
        <span class="cov8" title="1">return engine</span>
}

// TestConfig creates a test configuration
func TestConfig() *config.Config <span class="cov8" title="1">{
        cfg := config.DefaultConfig()
        cfg.Storage.InMemory = true
        cfg.Server.Port = 0 // Let the OS choose a free port for testing
        cfg.Metrics.Port = 0
        return cfg
}</span>

// TestLogger creates a test logger with minimal configuration
func TestLogger() *logging.Logger <span class="cov8" title="1">{
        testLogConfig := logging.TestLoggingConfig()
        return logging.NewLogger(&amp;testLogConfig)
}</span>

// GenerateRandomString generates a random string of given length
func GenerateRandomString(length int) string <span class="cov8" title="1">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        result := make([]byte, length)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov8" title="1">return string(result)</span>
}

// GenerateRandomKey generates a random key for testing
func GenerateRandomKey() string <span class="cov8" title="1">{
        return fmt.Sprintf("test-key-%s", GenerateRandomString(8))
}</span>

// GenerateRandomValue generates a random value for testing
func GenerateRandomValue() string <span class="cov8" title="1">{
        return fmt.Sprintf("test-value-%s", GenerateRandomString(16))
}</span>

// PopulateTestData populates storage with test data and returns the data map
func PopulateTestData(t *testing.T, engine storage.StorageEngine, count int) map[string]string <span class="cov8" title="1">{
        t.Helper()
        
        data := make(map[string]string)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                key := fmt.Sprintf("test-key-%d", i)
                value := fmt.Sprintf("test-value-%d", i)
                
                err := engine.Put([]byte(key), []byte(value))
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to put test data: %v", err)
                }</span>
                
                <span class="cov8" title="1">data[key] = value</span>
        }
        
        <span class="cov8" title="1">return data</span>
}

// PopulateTestDataWithPrefix populates storage with test data using a prefix
func PopulateTestDataWithPrefix(t *testing.T, engine storage.StorageEngine, prefix string, count int) map[string]string <span class="cov8" title="1">{
        t.Helper()
        
        data := make(map[string]string)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s-key-%d", prefix, i)
                value := fmt.Sprintf("%s-value-%d", prefix, i)
                
                err := engine.Put([]byte(key), []byte(value))
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to put test data: %v", err)
                }</span>
                
                <span class="cov8" title="1">data[key] = value</span>
        }
        
        <span class="cov8" title="1">return data</span>
}

// AssertKeyExists verifies that a key exists in storage
func AssertKeyExists(t *testing.T, engine storage.StorageEngine, key string) <span class="cov8" title="1">{
        t.Helper()
        
        exists, err := engine.Exists([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to check key existence: %v", err)
        }</span>
        
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                t.Errorf("Expected key %s to exist, but it doesn't", key)
        }</span>
}

// AssertKeyNotExists verifies that a key does not exist in storage
func AssertKeyNotExists(t *testing.T, engine storage.StorageEngine, key string) <span class="cov8" title="1">{
        t.Helper()
        
        exists, err := engine.Exists([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to check key existence: %v", err)
        }</span>
        
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                t.Errorf("Expected key %s to not exist, but it does", key)
        }</span>
}

// AssertKeyValue verifies that a key has the expected value
func AssertKeyValue(t *testing.T, engine storage.StorageEngine, key, expectedValue string) <span class="cov8" title="1">{
        t.Helper()
        
        value, err := engine.Get([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get key %s: %v", key, err)
        }</span>
        
        <span class="cov8" title="1">if string(value) != expectedValue </span><span class="cov0" title="0">{
                t.Errorf("Expected key %s to have value %s, got %s", key, expectedValue, string(value))
        }</span>
}

// HTTPTestRecorder creates a new httptest.ResponseRecorder for testing
func HTTPTestRecorder() *httptest.ResponseRecorder <span class="cov8" title="1">{
        return httptest.NewRecorder()
}</span>

// AssertHTTPStatus verifies that the HTTP response has the expected status code
func AssertHTTPStatus(t *testing.T, recorder *httptest.ResponseRecorder, expectedStatus int) <span class="cov8" title="1">{
        t.Helper()
        
        if recorder.Code != expectedStatus </span><span class="cov0" title="0">{
                t.Errorf("Expected HTTP status %d, got %d", expectedStatus, recorder.Code)
        }</span>
}

// AssertHTTPHeader verifies that the HTTP response has the expected header value
func AssertHTTPHeader(t *testing.T, recorder *httptest.ResponseRecorder, header, expectedValue string) <span class="cov8" title="1">{
        t.Helper()
        
        actualValue := recorder.Header().Get(header)
        if actualValue != expectedValue </span><span class="cov0" title="0">{
                t.Errorf("Expected header %s to be %s, got %s", header, expectedValue, actualValue)
        }</span>
}

// AssertContains verifies that a string contains a substring
func AssertContains(t *testing.T, str, substr string) <span class="cov8" title="1">{
        t.Helper()
        
        if !strings.Contains(str, substr) </span><span class="cov0" title="0">{
                t.Errorf("Expected string to contain %s, but it doesn't: %s", substr, str)
        }</span>
}

// AssertNotContains verifies that a string does not contain a substring
func AssertNotContains(t *testing.T, str, substr string) <span class="cov8" title="1">{
        t.Helper()
        
        if strings.Contains(str, substr) </span><span class="cov0" title="0">{
                t.Errorf("Expected string to not contain %s, but it does: %s", substr, str)
        }</span>
}

// WithTimeout runs a test function with a timeout
func WithTimeout(t *testing.T, timeout time.Duration, fn func()) <span class="cov8" title="1">{
        t.Helper()
        
        done := make(chan bool, 1)
        
        go func() </span><span class="cov8" title="1">{
                fn()
                done &lt;- true
        }</span>()
        
        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1"></span>
                // Test completed within timeout
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                t.Fatalf("Test timed out after %v", timeout)</span>
        }
}

// TempDir creates a temporary directory for testing
func TempDir(t *testing.T, prefix string) string <span class="cov8" title="1">{
        t.Helper()
        
        dir, err := os.MkdirTemp("", prefix)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp directory: %v", err)
        }</span>
        
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                os.RemoveAll(dir)
        }</span>)
        
        <span class="cov8" title="1">return dir</span>
}

// SetupTestEnvironment sets up a complete test environment
func SetupTestEnvironment(t *testing.T) (*storage.Engine, *logging.Logger, *config.Config) <span class="cov8" title="1">{
        t.Helper()
        
        cfg := TestConfig()
        logger := TestLogger()
        engine := TestStorageEngine(t)
        
        return engine, logger, cfg
}</span>

// MockHTTPRequest creates a mock HTTP request for testing
func MockHTTPRequest(method, url string, body string) *http.Request <span class="cov8" title="1">{
        var bodyReader *strings.Reader
        if body != "" </span><span class="cov8" title="1">{
                bodyReader = strings.NewReader(body)
                return httptest.NewRequest(method, url, bodyReader)
        }</span>
        <span class="cov8" title="1">return httptest.NewRequest(method, url, nil)</span>
}

// WaitForCondition waits for a condition to become true with timeout
func WaitForCondition(t *testing.T, condition func() bool, timeout time.Duration, checkInterval time.Duration) <span class="cov8" title="1">{
        t.Helper()
        
        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov8" title="1">{
                if condition() </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">time.Sleep(checkInterval)</span>
        }
        
        <span class="cov0" title="0">t.Fatalf("Condition not met within timeout %v", timeout)</span>
}

// ConcurrentTest runs multiple test functions concurrently
func ConcurrentTest(t *testing.T, concurrency int, testFunc func(int)) <span class="cov8" title="1">{
        t.Helper()
        
        done := make(chan bool, concurrency)
        errors := make(chan error, concurrency)
        
        for i := 0; i &lt; concurrency; i++ </span><span class="cov8" title="1">{
                go func(index int) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        errors &lt;- fmt.Errorf("goroutine %d panicked: %v", index, r)
                                }</span>
                                <span class="cov8" title="1">done &lt;- true</span>
                        }()
                        
                        <span class="cov8" title="1">testFunc(index)</span>
                }(i)
        }
        
        // Wait for all goroutines to complete
        <span class="cov8" title="1">for i := 0; i &lt; concurrency; i++ </span><span class="cov8" title="1">{
                &lt;-done
        }</span>
        
        // Check for errors
        <span class="cov8" title="1">select </span>{
        case err := &lt;-errors:<span class="cov0" title="0">
                t.Fatalf("Concurrent test failed: %v", err)</span>
        default:<span class="cov8" title="1"></span>
                // No errors
        }
}

// MemoryUsage returns current memory usage stats for testing
func MemoryUsage() (heapAlloc, heapSys, numGC uint64) <span class="cov0" title="0">{
        // Implementation would use runtime.ReadMemStats but keeping simple for now
        return 0, 0, 0
}</span>

// BenchmarkHelper provides utilities for benchmark tests
type BenchmarkHelper struct {
        StartTime time.Time
        EndTime   time.Time
}

// NewBenchmarkHelper creates a new benchmark helper
func NewBenchmarkHelper() *BenchmarkHelper <span class="cov8" title="1">{
        return &amp;BenchmarkHelper{
                StartTime: time.Now(),
        }
}</span>

// End marks the end of the benchmark
func (bh *BenchmarkHelper) End() <span class="cov8" title="1">{
        bh.EndTime = time.Now()
}</span>

// Duration returns the duration of the benchmark
func (bh *BenchmarkHelper) Duration() time.Duration <span class="cov8" title="1">{
        if bh.EndTime.IsZero() </span><span class="cov0" title="0">{
                return time.Since(bh.StartTime)
        }</span>
        <span class="cov8" title="1">return bh.EndTime.Sub(bh.StartTime)</span>
}

// OperationsPerSecond calculates operations per second for given operation count
func (bh *BenchmarkHelper) OperationsPerSecond(operations int) float64 <span class="cov8" title="1">{
        duration := bh.Duration()
        if duration == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(operations) / duration.Seconds()</span>
}

// TestDataGenerator generates test data for various scenarios
type TestDataGenerator struct {
        rand *rand.Rand
}

// NewTestDataGenerator creates a new test data generator
func NewTestDataGenerator(seed int64) *TestDataGenerator <span class="cov8" title="1">{
        return &amp;TestDataGenerator{
                rand: rand.New(rand.NewSource(seed)),
        }
}</span>

// GenerateKeyValuePairs generates n key-value pairs
func (tdg *TestDataGenerator) GenerateKeyValuePairs(n int) map[string]string <span class="cov8" title="1">{
        data := make(map[string]string)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                key := fmt.Sprintf("key-%d-%s", i, tdg.randomString(8))
                value := fmt.Sprintf("value-%d-%s", i, tdg.randomString(16))
                data[key] = value
        }</span>
        <span class="cov8" title="1">return data</span>
}

// GenerateKeysWithPrefix generates n keys with the given prefix
func (tdg *TestDataGenerator) GenerateKeysWithPrefix(prefix string, n int) []string <span class="cov8" title="1">{
        keys := make([]string, n)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                keys[i] = fmt.Sprintf("%s-%d-%s", prefix, i, tdg.randomString(8))
        }</span>
        <span class="cov8" title="1">return keys</span>
}

// randomString generates a random string of given length
func (tdg *TestDataGenerator) randomString(length int) string <span class="cov8" title="1">{
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        result := make([]byte, length)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = charset[tdg.rand.Intn(len(charset))]
        }</span>
        <span class="cov8" title="1">return string(result)</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package client

import (
        "context"
        "fmt"
        "sync"
        "time"

        "distributed-kvstore/proto/kvstore"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// Client represents a distributed key-value store client
type Client struct {
        config  *Config
        pool    *ConnectionPool
        mu      sync.RWMutex
        closed  bool
}

// Config holds client configuration
type Config struct {
        // Server addresses
        Addresses []string
        
        // Connection settings
        MaxConnections    int
        MaxIdleTime       time.Duration
        ConnectionTimeout time.Duration
        RequestTimeout    time.Duration
        
        // Retry settings
        MaxRetries     int
        RetryDelay     time.Duration
        RetryBackoff   float64
        RetryableErrors []codes.Code
        
        // TLS settings
        TLSEnabled bool
        CertFile   string
        KeyFile    string
        CAFile     string
}

// DefaultConfig returns a default client configuration
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Addresses:         []string{"localhost:9090"},
                MaxConnections:    10,
                MaxIdleTime:       5 * time.Minute,
                ConnectionTimeout: 10 * time.Second,
                RequestTimeout:    30 * time.Second,
                MaxRetries:        3,
                RetryDelay:        100 * time.Millisecond,
                RetryBackoff:      2.0,
                RetryableErrors: []codes.Code{
                        codes.Unavailable,
                        codes.DeadlineExceeded,
                        codes.ResourceExhausted,
                },
                TLSEnabled: false,
        }
}</span>

// NewClient creates a new distributed key-value store client
func NewClient(config *Config) (*Client, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultConfig()
        }</span>
        
        <span class="cov8" title="1">if len(config.Addresses) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("at least one server address must be provided")
        }</span>
        
        <span class="cov8" title="1">pool, err := NewConnectionPool(config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;Client{
                config: config,
                pool:   pool,
        }, nil</span>
}

// Close closes the client and all its connections
func (c *Client) Close() error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        
        if c.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">c.closed = true
        return c.pool.Close()</span>
}

// Put stores a key-value pair
func (c *Client) Put(ctx context.Context, key string, value []byte, opts ...PutOption) error <span class="cov8" title="1">{
        req := &amp;kvstore.PutRequest{
                Key:   key,
                Value: value,
        }
        
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(req)
        }</span>
        
        <span class="cov8" title="1">return c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov8" title="1">{
                resp, err := client.Put(ctx, req)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if !resp.Success </span><span class="cov0" title="0">{
                        return fmt.Errorf("put failed: %s", resp.Error)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
}

// Get retrieves a value by key
func (c *Client) Get(ctx context.Context, key string) (*GetResult, error) <span class="cov8" title="1">{
        req := &amp;kvstore.GetRequest{Key: key}
        
        var result *GetResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov8" title="1">{
                resp, err := client.Get(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("get failed: %s", resp.Error)
                }</span>
                
                <span class="cov8" title="1">result = &amp;GetResult{
                        Found:     resp.Found,
                        Value:     resp.Value,
                        CreatedAt: time.Unix(resp.CreatedAt, 0),
                        ExpiresAt: time.Unix(resp.ExpiresAt, 0),
                }
                return nil</span>
        })
        
        <span class="cov8" title="1">return result, err</span>
}

// Delete removes a key-value pair
func (c *Client) Delete(ctx context.Context, key string) (*DeleteResult, error) <span class="cov0" title="0">{
        req := &amp;kvstore.DeleteRequest{Key: key}
        
        var result *DeleteResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov0" title="0">{
                resp, err := client.Delete(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">result = &amp;DeleteResult{
                        Existed: resp.Existed,
                }
                return nil</span>
        })
        
        <span class="cov0" title="0">return result, err</span>
}

// Exists checks if a key exists
func (c *Client) Exists(ctx context.Context, key string) (bool, error) <span class="cov8" title="1">{
        req := &amp;kvstore.ExistsRequest{Key: key}
        
        var exists bool
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov8" title="1">{
                resp, err := client.Exists(ctx, req)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("exists failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">exists = resp.Exists
                return nil</span>
        })
        
        <span class="cov8" title="1">return exists, err</span>
}

// List retrieves key-value pairs with a prefix
func (c *Client) List(ctx context.Context, prefix string, opts ...ListOption) (*ListResult, error) <span class="cov0" title="0">{
        req := &amp;kvstore.ListRequest{Prefix: prefix}
        
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(req)
        }</span>
        
        <span class="cov0" title="0">var result *ListResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov0" title="0">{
                resp, err := client.List(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("list failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">items := make([]*KeyValue, len(resp.Items))
                for i, item := range resp.Items </span><span class="cov0" title="0">{
                        items[i] = &amp;KeyValue{
                                Key:       item.Key,
                                Value:     item.Value,
                                CreatedAt: time.Unix(item.CreatedAt, 0),
                                ExpiresAt: time.Unix(item.ExpiresAt, 0),
                        }
                }</span>
                
                <span class="cov0" title="0">result = &amp;ListResult{
                        Items:      items,
                        NextCursor: resp.NextCursor,
                        HasMore:    resp.HasMore,
                }
                return nil</span>
        })
        
        <span class="cov0" title="0">return result, err</span>
}

// ListKeys retrieves keys with a prefix
func (c *Client) ListKeys(ctx context.Context, prefix string, opts ...ListOption) (*ListKeysResult, error) <span class="cov0" title="0">{
        req := &amp;kvstore.ListKeysRequest{Prefix: prefix}
        
        for _, opt := range opts </span><span class="cov0" title="0">{
                if opt != nil </span><span class="cov0" title="0">{
                        // Convert ListOption to appropriate fields for ListKeysRequest
                        tempReq := &amp;kvstore.ListRequest{}
                        opt(tempReq)
                        req.Limit = tempReq.Limit
                        req.Cursor = tempReq.Cursor
                }</span>
        }
        
        <span class="cov0" title="0">var result *ListKeysResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov0" title="0">{
                resp, err := client.ListKeys(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("list keys failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">result = &amp;ListKeysResult{
                        Keys:       resp.Keys,
                        NextCursor: resp.NextCursor,
                        HasMore:    resp.HasMore,
                }
                return nil</span>
        })
        
        <span class="cov0" title="0">return result, err</span>
}

// BatchPut stores multiple key-value pairs
func (c *Client) BatchPut(ctx context.Context, items []*PutItem) (*BatchResult, error) <span class="cov8" title="1">{
        reqItems := make([]*kvstore.PutItem, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                reqItems[i] = &amp;kvstore.PutItem{
                        Key:        item.Key,
                        Value:      item.Value,
                        TtlSeconds: item.TTLSeconds,
                }
        }</span>
        
        <span class="cov8" title="1">req := &amp;kvstore.BatchPutRequest{Items: reqItems}
        
        var result *BatchResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov8" title="1">{
                resp, err := client.BatchPut(ctx, req)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                
                <span class="cov0" title="0">errors := make([]*BatchError, len(resp.Errors))
                for i, batchErr := range resp.Errors </span><span class="cov0" title="0">{
                        errors[i] = &amp;BatchError{
                                Key:   batchErr.Key,
                                Error: batchErr.Error,
                        }
                }</span>
                
                <span class="cov0" title="0">result = &amp;BatchResult{
                        SuccessCount: int(resp.SuccessCount),
                        ErrorCount:   int(resp.ErrorCount),
                        Errors:       errors,
                }
                return nil</span>
        })
        
        <span class="cov8" title="1">return result, err</span>
}

// BatchGet retrieves multiple values
func (c *Client) BatchGet(ctx context.Context, keys []string) ([]*GetResult, error) <span class="cov0" title="0">{
        req := &amp;kvstore.BatchGetRequest{Keys: keys}
        
        var results []*GetResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov0" title="0">{
                resp, err := client.BatchGet(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("batch get failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">results = make([]*GetResult, len(resp.Results))
                for i, result := range resp.Results </span><span class="cov0" title="0">{
                        results[i] = &amp;GetResult{
                                Key:       result.Key,
                                Found:     result.Found,
                                Value:     result.Value,
                                CreatedAt: time.Unix(result.CreatedAt, 0),
                                ExpiresAt: time.Unix(result.ExpiresAt, 0),
                        }
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">return results, err</span>
}

// BatchDelete removes multiple keys
func (c *Client) BatchDelete(ctx context.Context, keys []string) (*BatchResult, error) <span class="cov0" title="0">{
        req := &amp;kvstore.BatchDeleteRequest{Keys: keys}
        
        var result *BatchResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov0" title="0">{
                resp, err := client.BatchDelete(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">errors := make([]*BatchError, len(resp.Errors))
                for i, batchErr := range resp.Errors </span><span class="cov0" title="0">{
                        errors[i] = &amp;BatchError{
                                Key:   batchErr.Key,
                                Error: batchErr.Error,
                        }
                }</span>
                
                <span class="cov0" title="0">result = &amp;BatchResult{
                        SuccessCount: int(resp.SuccessCount),
                        ErrorCount:   int(resp.ErrorCount),
                        Errors:       errors,
                }
                return nil</span>
        })
        
        <span class="cov0" title="0">return result, err</span>
}

// Health checks server health
func (c *Client) Health(ctx context.Context) (*HealthResult, error) <span class="cov8" title="1">{
        req := &amp;kvstore.HealthRequest{}
        
        var result *HealthResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov8" title="1">{
                resp, err := client.Health(ctx, req)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                
                <span class="cov0" title="0">result = &amp;HealthResult{
                        Healthy:       resp.Healthy,
                        Status:        resp.Status,
                        UptimeSeconds: int(resp.UptimeSeconds),
                        Version:       resp.Version,
                }
                return nil</span>
        })
        
        <span class="cov8" title="1">return result, err</span>
}

// Stats retrieves server statistics
func (c *Client) Stats(ctx context.Context, includeDetails bool) (*StatsResult, error) <span class="cov0" title="0">{
        req := &amp;kvstore.StatsRequest{IncludeDetails: includeDetails}
        
        var result *StatsResult
        err := c.executeWithRetry(ctx, func(client kvstore.KVStoreClient) error </span><span class="cov0" title="0">{
                resp, err := client.Stats(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("stats failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">result = &amp;StatsResult{
                        TotalKeys: int(resp.TotalKeys),
                        TotalSize: int(resp.TotalSize),
                        LSMSize:   int(resp.LsmSize),
                        VLogSize:  int(resp.VlogSize),
                        Details:   resp.Details,
                }
                return nil</span>
        })
        
        <span class="cov0" title="0">return result, err</span>
}

// executeWithRetry executes a function with retry logic
func (c *Client) executeWithRetry(ctx context.Context, fn func(kvstore.KVStoreClient) error) error <span class="cov8" title="1">{
        c.mu.RLock()
        if c.closed </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return fmt.Errorf("client is closed")
        }</span>
        <span class="cov8" title="1">c.mu.RUnlock()
        
        var lastErr error
        
        for attempt := 0; attempt &lt;= c.config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        backoffMultiplier := 1 &lt;&lt; (attempt - 1)
                        delay := time.Duration(float64(c.config.RetryDelay) * float64(backoffMultiplier))
                        if c.config.RetryBackoff &gt; 1 </span><span class="cov0" title="0">{
                                delay = time.Duration(float64(delay) * c.config.RetryBackoff)
                        }</span>
                        
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        }
                }
                
                <span class="cov8" title="1">conn, err := c.pool.GetConnection(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        lastErr = fmt.Errorf("failed to get connection: %w", err)
                        if c.shouldRetry(err) &amp;&amp; attempt &lt; c.config.MaxRetries </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">return lastErr</span>
                }
                
                <span class="cov8" title="1">client := kvstore.NewKVStoreClient(conn.conn)
                err = fn(client)
                
                c.pool.PutConnection(conn)
                
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                
                <span class="cov8" title="1">lastErr = err
                if !c.shouldRetry(err) || attempt &gt;= c.config.MaxRetries </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        
        <span class="cov8" title="1">return lastErr</span>
}

// shouldRetry determines if an error should trigger a retry
func (c *Client) shouldRetry(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">st, ok := status.FromError(err)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">for _, code := range c.config.RetryableErrors </span><span class="cov0" title="0">{
                if st.Code() == code </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov8" title="1">return false</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package client

import (
        "context"
        "fmt"
        "math/rand"
        "sync"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/connectivity"
        "google.golang.org/grpc/credentials/insecure"
)

// Connection represents a gRPC connection with metadata
type Connection struct {
        conn       *grpc.ClientConn
        address    string
        lastUsed   time.Time
        inUse      bool
        created    time.Time
}

// ConnectionPool manages a pool of gRPC connections
type ConnectionPool struct {
        config      *Config
        connections []*Connection
        mu          sync.RWMutex
        closed      bool
        closeCh     chan struct{}
}

// NewConnectionPool creates a new connection pool
func NewConnectionPool(config *Config) (*ConnectionPool, error) <span class="cov8" title="1">{
        pool := &amp;ConnectionPool{
                config:      config,
                connections: make([]*Connection, 0),
                closeCh:     make(chan struct{}),
        }

        // Create initial connections
        for i := 0; i &lt; min(config.MaxConnections, len(config.Addresses)); i++ </span><span class="cov8" title="1">{
                address := config.Addresses[i%len(config.Addresses)]
                conn, err := pool.createConnection(address)
                if err != nil </span><span class="cov8" title="1">{
                        // Log error but don't fail pool creation
                        continue</span>
                }
                <span class="cov0" title="0">pool.connections = append(pool.connections, conn)</span>
        }

        <span class="cov8" title="1">if len(pool.connections) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create any connections")
        }</span>

        // Start background cleanup routine
        <span class="cov0" title="0">go pool.cleanup()

        return pool, nil</span>
}

// GetConnection retrieves a connection from the pool
func (p *ConnectionPool) GetConnection(ctx context.Context) (*Connection, error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection pool is closed")
        }</span>

        // Try to find an available connection
        <span class="cov8" title="1">for _, conn := range p.connections </span><span class="cov8" title="1">{
                if !conn.inUse &amp;&amp; p.isConnectionHealthy(conn) </span><span class="cov8" title="1">{
                        conn.inUse = true
                        conn.lastUsed = time.Now()
                        return conn, nil
                }</span>
        }

        // If no available connection and we haven't reached max, create a new one
        <span class="cov8" title="1">if len(p.connections) &lt; p.config.MaxConnections </span><span class="cov8" title="1">{
                address := p.selectAddress()
                conn, err := p.createConnection(address)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to create new connection: %w", err)
                }</span>
                <span class="cov0" title="0">conn.inUse = true
                conn.lastUsed = time.Now()
                p.connections = append(p.connections, conn)
                return conn, nil</span>
        }

        // Wait for a connection to become available
        <span class="cov0" title="0">return p.waitForConnection(ctx)</span>
}

// PutConnection returns a connection to the pool
func (p *ConnectionPool) PutConnection(conn *Connection) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                p.closeConnection(conn)
                return
        }</span>

        <span class="cov8" title="1">conn.inUse = false
        conn.lastUsed = time.Now()</span>
}

// Close closes all connections in the pool
func (p *ConnectionPool) Close() error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">p.closed = true
        close(p.closeCh)

        var lastErr error
        for _, conn := range p.connections </span><span class="cov8" title="1">{
                if err := p.closeConnection(conn); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                }</span>
        }

        <span class="cov8" title="1">p.connections = nil
        return lastErr</span>
}

// createConnection creates a new gRPC connection
func (p *ConnectionPool) createConnection(address string) (*Connection, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), p.config.ConnectionTimeout)
        defer cancel()

        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithBlock(),
        }

        if p.config.TLSEnabled </span><span class="cov0" title="0">{
                // TODO: Add TLS credentials
                return nil, fmt.Errorf("TLS support not implemented yet")
        }</span>

        <span class="cov8" title="1">grpcConn, err := grpc.DialContext(ctx, address, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to dial %s: %w", address, err)
        }</span>

        <span class="cov0" title="0">return &amp;Connection{
                conn:     grpcConn,
                address:  address,
                lastUsed: time.Now(),
                created:  time.Now(),
                inUse:    false,
        }, nil</span>
}

// closeConnection closes a single connection
func (p *ConnectionPool) closeConnection(conn *Connection) error <span class="cov8" title="1">{
        if conn.conn != nil </span><span class="cov8" title="1">{
                return conn.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// isConnectionHealthy checks if a connection is healthy
func (p *ConnectionPool) isConnectionHealthy(conn *Connection) bool <span class="cov8" title="1">{
        if conn.conn == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">state := conn.conn.GetState()
        switch state </span>{
        case connectivity.Ready, connectivity.Idle:<span class="cov8" title="1">
                return true</span>
        case connectivity.Connecting:<span class="cov8" title="1">
                // Give connecting connections a chance
                return time.Since(conn.created) &lt; p.config.ConnectionTimeout</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// waitForConnection waits for a connection to become available
func (p *ConnectionPool) waitForConnection(ctx context.Context) (*Connection, error) <span class="cov0" title="0">{
        ticker := time.NewTicker(50 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-p.closeCh:<span class="cov0" title="0">
                        return nil, fmt.Errorf("connection pool is closed")</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check again for available connections
                        for _, conn := range p.connections </span><span class="cov0" title="0">{
                                if !conn.inUse &amp;&amp; p.isConnectionHealthy(conn) </span><span class="cov0" title="0">{
                                        conn.inUse = true
                                        conn.lastUsed = time.Now()
                                        return conn, nil
                                }</span>
                        }
                }
        }
}

// selectAddress selects an address using round-robin with randomization
func (p *ConnectionPool) selectAddress() string <span class="cov8" title="1">{
        if len(p.config.Addresses) == 1 </span><span class="cov8" title="1">{
                return p.config.Addresses[0]
        }</span>

        // Simple load balancing: random selection
        <span class="cov0" title="0">index := rand.Intn(len(p.config.Addresses))
        return p.config.Addresses[index]</span>
}

// cleanup runs background cleanup tasks
func (p *ConnectionPool) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-p.closeCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        p.cleanupIdleConnections()</span>
                }
        }
}

// cleanupIdleConnections removes idle connections that exceed MaxIdleTime
func (p *ConnectionPool) cleanupIdleConnections() <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var activeConnections []*Connection
        now := time.Now()

        for _, conn := range p.connections </span><span class="cov0" title="0">{
                if conn.inUse </span><span class="cov0" title="0">{
                        activeConnections = append(activeConnections, conn)
                        continue</span>
                }

                <span class="cov0" title="0">if now.Sub(conn.lastUsed) &gt; p.config.MaxIdleTime </span><span class="cov0" title="0">{
                        // Close idle connection
                        p.closeConnection(conn)
                }</span> else<span class="cov0" title="0"> {
                        activeConnections = append(activeConnections, conn)
                }</span>
        }

        <span class="cov0" title="0">p.connections = activeConnections</span>
}

// Stats returns connection pool statistics
func (p *ConnectionPool) Stats() *PoolStats <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        stats := &amp;PoolStats{
                TotalConnections: len(p.connections),
                MaxConnections:   p.config.MaxConnections,
        }

        for _, conn := range p.connections </span><span class="cov0" title="0">{
                if conn.inUse </span><span class="cov0" title="0">{
                        stats.ActiveConnections++
                }</span> else<span class="cov0" title="0"> {
                        stats.IdleConnections++
                }</span>

                <span class="cov0" title="0">if p.isConnectionHealthy(conn) </span><span class="cov0" title="0">{
                        stats.HealthyConnections++
                }</span>
        }

        <span class="cov0" title="0">return stats</span>
}

// PoolStats represents connection pool statistics
type PoolStats struct {
        TotalConnections   int
        ActiveConnections  int
        IdleConnections    int
        HealthyConnections int
        MaxConnections     int
}

// String returns a string representation of the pool stats
func (s *PoolStats) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Pool Stats: Total=%d, Active=%d, Idle=%d, Healthy=%d, Max=%d",
                s.TotalConnections, s.ActiveConnections, s.IdleConnections,
                s.HealthyConnections, s.MaxConnections)
}</span>

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package client

import (
        "time"

        "distributed-kvstore/proto/kvstore"
)

// GetResult represents the result of a Get operation
type GetResult struct {
        Key       string
        Found     bool
        Value     []byte
        CreatedAt time.Time
        ExpiresAt time.Time
}

// DeleteResult represents the result of a Delete operation
type DeleteResult struct {
        Existed bool
}

// KeyValue represents a key-value pair with metadata
type KeyValue struct {
        Key       string
        Value     []byte
        CreatedAt time.Time
        ExpiresAt time.Time
}

// ListResult represents the result of a List operation
type ListResult struct {
        Items      []*KeyValue
        NextCursor string
        HasMore    bool
}

// ListKeysResult represents the result of a ListKeys operation
type ListKeysResult struct {
        Keys       []string
        NextCursor string
        HasMore    bool
}

// PutItem represents an item for batch put operations
type PutItem struct {
        Key        string
        Value      []byte
        TTLSeconds int64
}

// BatchError represents an error in batch operations
type BatchError struct {
        Key   string
        Error string
}

// BatchResult represents the result of batch operations
type BatchResult struct {
        SuccessCount int
        ErrorCount   int
        Errors       []*BatchError
}

// HealthResult represents the result of a health check
type HealthResult struct {
        Healthy       bool
        Status        string
        UptimeSeconds int
        Version       string
}

// StatsResult represents the result of a stats operation
type StatsResult struct {
        TotalKeys int
        TotalSize int
        LSMSize   int
        VLogSize  int
        Details   map[string]string
}

// PutOption is a function that modifies a PutRequest
type PutOption func(*kvstore.PutRequest)

// WithTTL sets the TTL for a put operation
func WithTTL(seconds int64) PutOption <span class="cov8" title="1">{
        return func(req *kvstore.PutRequest) </span><span class="cov8" title="1">{
                req.TtlSeconds = seconds
        }</span>
}

// ListOption is a function that modifies a ListRequest
type ListOption func(*kvstore.ListRequest)

// WithLimit sets the limit for list operations
func WithLimit(limit int32) ListOption <span class="cov8" title="1">{
        return func(req *kvstore.ListRequest) </span><span class="cov8" title="1">{
                req.Limit = limit
        }</span>
}

// WithCursor sets the cursor for list operations (pagination)
func WithCursor(cursor string) ListOption <span class="cov8" title="1">{
        return func(req *kvstore.ListRequest) </span><span class="cov8" title="1">{
                req.Cursor = cursor
        }</span>
}

// String returns a string representation of the GetResult
func (r *GetResult) String() string <span class="cov8" title="1">{
        if !r.Found </span><span class="cov8" title="1">{
                return "(nil)"
        }</span>
        <span class="cov8" title="1">return string(r.Value)</span>
}

// IsExpired checks if the key has expired
func (r *GetResult) IsExpired() bool <span class="cov8" title="1">{
        if r.ExpiresAt.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return time.Now().After(r.ExpiresAt)</span>
}

// HasTTL checks if the key has a TTL set
func (r *GetResult) HasTTL() bool <span class="cov8" title="1">{
        return !r.ExpiresAt.IsZero()
}</span>

// TTL returns the time until expiration
func (r *GetResult) TTL() time.Duration <span class="cov8" title="1">{
        if r.ExpiresAt.IsZero() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return time.Until(r.ExpiresAt)</span>
}

// IsEmpty checks if the list result is empty
func (r *ListResult) IsEmpty() bool <span class="cov8" title="1">{
        return len(r.Items) == 0
}</span>

// Count returns the number of items in the list result
func (r *ListResult) Count() int <span class="cov8" title="1">{
        return len(r.Items)
}</span>

// Keys returns all keys from the list result
func (r *ListResult) Keys() []string <span class="cov8" title="1">{
        keys := make([]string, len(r.Items))
        for i, item := range r.Items </span><span class="cov8" title="1">{
                keys[i] = item.Key
        }</span>
        <span class="cov8" title="1">return keys</span>
}

// Values returns all values from the list result
func (r *ListResult) Values() [][]byte <span class="cov8" title="1">{
        values := make([][]byte, len(r.Items))
        for i, item := range r.Items </span><span class="cov8" title="1">{
                values[i] = item.Value
        }</span>
        <span class="cov8" title="1">return values</span>
}

// IsEmpty checks if the list keys result is empty
func (r *ListKeysResult) IsEmpty() bool <span class="cov8" title="1">{
        return len(r.Keys) == 0
}</span>

// Count returns the number of keys in the result
func (r *ListKeysResult) Count() int <span class="cov8" title="1">{
        return len(r.Keys)
}</span>

// HasErrors checks if the batch result has any errors
func (r *BatchResult) HasErrors() bool <span class="cov8" title="1">{
        return r.ErrorCount &gt; 0
}</span>

// IsFullSuccess checks if all operations in the batch succeeded
func (r *BatchResult) IsFullSuccess() bool <span class="cov8" title="1">{
        return r.ErrorCount == 0
}</span>

// TotalOperations returns the total number of operations
func (r *BatchResult) TotalOperations() int <span class="cov8" title="1">{
        return r.SuccessCount + r.ErrorCount
}</span>

// SuccessRate returns the success rate as a percentage
func (r *BatchResult) SuccessRate() float64 <span class="cov8" title="1">{
        total := r.TotalOperations()
        if total == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(r.SuccessCount) / float64(total) * 100</span>
}

// GetErrorsForKey returns all errors for a specific key
func (r *BatchResult) GetErrorsForKey(key string) []string <span class="cov8" title="1">{
        var errors []string
        for _, err := range r.Errors </span><span class="cov8" title="1">{
                if err.Key == key </span><span class="cov8" title="1">{
                        errors = append(errors, err.Error)
                }</span>
        }
        <span class="cov8" title="1">return errors</span>
}

// IsHealthy checks if the server is healthy
func (r *HealthResult) IsHealthy() bool <span class="cov8" title="1">{
        return r.Healthy
}</span>

// UptimeDuration returns the uptime as a time.Duration
func (r *HealthResult) UptimeDuration() time.Duration <span class="cov8" title="1">{
        return time.Duration(r.UptimeSeconds) * time.Second
}</span>

// TotalSizeBytes returns the total size in bytes
func (r *StatsResult) TotalSizeBytes() int <span class="cov8" title="1">{
        return r.TotalSize
}</span>

// TotalSizeMB returns the total size in megabytes
func (r *StatsResult) TotalSizeMB() float64 <span class="cov8" title="1">{
        return float64(r.TotalSize) / (1024 * 1024)
}</span>

// LSMSizeBytes returns the LSM size in bytes
func (r *StatsResult) LSMSizeBytes() int <span class="cov8" title="1">{
        return r.LSMSize
}</span>

// VLogSizeBytes returns the value log size in bytes
func (r *StatsResult) VLogSizeBytes() int <span class="cov8" title="1">{
        return r.VLogSize
}</span>

// GetDetail returns a specific detail value
func (r *StatsResult) GetDetail(key string) (string, bool) <span class="cov8" title="1">{
        value, exists := r.Details[key]
        return value, exists
}</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.7
//         protoc        v6.31.1
// source: proto/cluster/cluster.proto

package cluster

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Node management messages
type JoinRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        Address       string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`                                                                             // Node's network address
        RaftPort      int32                  `protobuf:"varint,3,opt,name=raft_port,json=raftPort,proto3" json:"raft_port,omitempty"`                                                          // Node's Raft port
        GrpcPort      int32                  `protobuf:"varint,4,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`                                                          // Node's gRPC port
        Metadata      map[string]string      `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Additional node metadata
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JoinRequest) Reset() <span class="cov0" title="0">{
        *x = JoinRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JoinRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JoinRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JoinRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JoinRequest.ProtoReflect.Descriptor instead.
func (*JoinRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{0}
}</span>

func (x *JoinRequest) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JoinRequest) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JoinRequest) GetRaftPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RaftPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JoinRequest) GetGrpcPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GrpcPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JoinRequest) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type JoinResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        LeaderId      string                 `protobuf:"bytes,2,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
        Nodes         []*NodeInfo            `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"` // Current cluster nodes
        Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JoinResponse) Reset() <span class="cov0" title="0">{
        *x = JoinResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JoinResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JoinResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JoinResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JoinResponse.ProtoReflect.Descriptor instead.
func (*JoinResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{1}
}</span>

func (x *JoinResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JoinResponse) GetLeaderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JoinResponse) GetNodes() []*NodeInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Nodes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JoinResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LeaveRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        Force         bool                   `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"` // Force removal even if node is unreachable
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LeaveRequest) Reset() <span class="cov0" title="0">{
        *x = LeaveRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LeaveRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LeaveRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LeaveRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LeaveRequest.ProtoReflect.Descriptor instead.
func (*LeaveRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LeaveRequest) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LeaveRequest) GetForce() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Force
        }</span>
        <span class="cov0" title="0">return false</span>
}

type LeaveResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LeaveResponse) Reset() <span class="cov0" title="0">{
        *x = LeaveResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LeaveResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LeaveResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LeaveResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LeaveResponse.ProtoReflect.Descriptor instead.
func (*LeaveResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LeaveResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LeaveResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetNodesRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetNodesRequest) Reset() <span class="cov0" title="0">{
        *x = GetNodesRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNodesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNodesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNodesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNodesRequest.ProtoReflect.Descriptor instead.
func (*GetNodesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{4}
}</span>

type GetNodesResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Nodes         []*NodeInfo            `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetNodesResponse) Reset() <span class="cov0" title="0">{
        *x = GetNodesResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNodesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNodesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNodesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNodesResponse.ProtoReflect.Descriptor instead.
func (*GetNodesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetNodesResponse) GetNodes() []*NodeInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Nodes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetNodesResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type NodeInfo struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        Address       string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
        RaftPort      int32                  `protobuf:"varint,3,opt,name=raft_port,json=raftPort,proto3" json:"raft_port,omitempty"`
        GrpcPort      int32                  `protobuf:"varint,4,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`
        State         string                 `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`                        // active, inactive, failed
        Role          string                 `protobuf:"bytes,6,opt,name=role,proto3" json:"role,omitempty"`                          // leader, follower, candidate
        LastSeen      int64                  `protobuf:"varint,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"` // Unix timestamp
        Metadata      map[string]string      `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NodeInfo) Reset() <span class="cov0" title="0">{
        *x = NodeInfo{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NodeInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NodeInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NodeInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{6}
}</span>

func (x *NodeInfo) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NodeInfo) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NodeInfo) GetRaftPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RaftPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NodeInfo) GetGrpcPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GrpcPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NodeInfo) GetState() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.State
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NodeInfo) GetRole() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NodeInfo) GetLastSeen() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastSeen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NodeInfo) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Raft consensus messages
type VoteRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Term          int64                  `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
        CandidateId   string                 `protobuf:"bytes,2,opt,name=candidate_id,json=candidateId,proto3" json:"candidate_id,omitempty"`
        LastLogIndex  int64                  `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"`
        LastLogTerm   int64                  `protobuf:"varint,4,opt,name=last_log_term,json=lastLogTerm,proto3" json:"last_log_term,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *VoteRequest) Reset() <span class="cov0" title="0">{
        *x = VoteRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *VoteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VoteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VoteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VoteRequest.ProtoReflect.Descriptor instead.
func (*VoteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{7}
}</span>

func (x *VoteRequest) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *VoteRequest) GetCandidateId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CandidateId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VoteRequest) GetLastLogIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastLogIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *VoteRequest) GetLastLogTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastLogTerm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type VoteResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Term          int64                  `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
        VoteGranted   bool                   `protobuf:"varint,2,opt,name=vote_granted,json=voteGranted,proto3" json:"vote_granted,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *VoteResponse) Reset() <span class="cov0" title="0">{
        *x = VoteResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *VoteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VoteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VoteResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VoteResponse.ProtoReflect.Descriptor instead.
func (*VoteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{8}
}</span>

func (x *VoteResponse) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *VoteResponse) GetVoteGranted() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VoteGranted
        }</span>
        <span class="cov0" title="0">return false</span>
}

type AppendRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Term          int64                  `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
        LeaderId      string                 `protobuf:"bytes,2,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
        PrevLogIndex  int64                  `protobuf:"varint,3,opt,name=prev_log_index,json=prevLogIndex,proto3" json:"prev_log_index,omitempty"`
        PrevLogTerm   int64                  `protobuf:"varint,4,opt,name=prev_log_term,json=prevLogTerm,proto3" json:"prev_log_term,omitempty"`
        Entries       []*LogEntry            `protobuf:"bytes,5,rep,name=entries,proto3" json:"entries,omitempty"`
        LeaderCommit  int64                  `protobuf:"varint,6,opt,name=leader_commit,json=leaderCommit,proto3" json:"leader_commit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AppendRequest) Reset() <span class="cov0" title="0">{
        *x = AppendRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AppendRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AppendRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AppendRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AppendRequest.ProtoReflect.Descriptor instead.
func (*AppendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{9}
}</span>

func (x *AppendRequest) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AppendRequest) GetLeaderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AppendRequest) GetPrevLogIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PrevLogIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AppendRequest) GetPrevLogTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PrevLogTerm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AppendRequest) GetEntries() []*LogEntry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entries
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AppendRequest) GetLeaderCommit() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderCommit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type AppendResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Term          int64                  `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        LastLogIndex  int64                  `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"` // For leader to update nextIndex
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AppendResponse) Reset() <span class="cov0" title="0">{
        *x = AppendResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AppendResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AppendResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AppendResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AppendResponse.ProtoReflect.Descriptor instead.
func (*AppendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{10}
}</span>

func (x *AppendResponse) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AppendResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AppendResponse) GetLastLogIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastLogIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LogEntry struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Index         int64                  `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
        Term          int64                  `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
        Type          string                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`            // PUT, DELETE, NOOP
        Data          []byte                 `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`            // Serialized operation data
        Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Unix timestamp
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogEntry) Reset() <span class="cov0" title="0">{
        *x = LogEntry{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogEntry) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogEntry) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogEntry) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogEntry.ProtoReflect.Descriptor instead.
func (*LogEntry) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{11}
}</span>

func (x *LogEntry) GetIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Index
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LogEntry) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LogEntry) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogEntry) GetData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LogEntry) GetTimestamp() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SnapshotRequest struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Term              int64                  `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
        LeaderId          string                 `protobuf:"bytes,2,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
        LastIncludedIndex int64                  `protobuf:"varint,3,opt,name=last_included_index,json=lastIncludedIndex,proto3" json:"last_included_index,omitempty"`
        LastIncludedTerm  int64                  `protobuf:"varint,4,opt,name=last_included_term,json=lastIncludedTerm,proto3" json:"last_included_term,omitempty"`
        Data              []byte                 `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`      // Snapshot data
        Done              bool                   `protobuf:"varint,6,opt,name=done,proto3" json:"done,omitempty"`     // Whether this is the last chunk
        Offset            int64                  `protobuf:"varint,7,opt,name=offset,proto3" json:"offset,omitempty"` // Offset for chunked transfer
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *SnapshotRequest) Reset() <span class="cov0" title="0">{
        *x = SnapshotRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SnapshotRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SnapshotRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SnapshotRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SnapshotRequest.ProtoReflect.Descriptor instead.
func (*SnapshotRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{12}
}</span>

func (x *SnapshotRequest) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SnapshotRequest) GetLeaderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SnapshotRequest) GetLastIncludedIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastIncludedIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SnapshotRequest) GetLastIncludedTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastIncludedTerm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SnapshotRequest) GetData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SnapshotRequest) GetDone() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Done
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *SnapshotRequest) GetOffset() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SnapshotResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Term          int64                  `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SnapshotResponse) Reset() <span class="cov0" title="0">{
        *x = SnapshotResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SnapshotResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SnapshotResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SnapshotResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SnapshotResponse.ProtoReflect.Descriptor instead.
func (*SnapshotResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{13}
}</span>

func (x *SnapshotResponse) GetTerm() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Term
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SnapshotResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Data replication messages
type ReplicationRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Operations    []*Operation           `protobuf:"bytes,1,rep,name=operations,proto3" json:"operations,omitempty"`
        LogIndex      int64                  `protobuf:"varint,2,opt,name=log_index,json=logIndex,proto3" json:"log_index,omitempty"`
        LeaderId      string                 `protobuf:"bytes,3,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReplicationRequest) Reset() <span class="cov0" title="0">{
        *x = ReplicationRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReplicationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReplicationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReplicationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReplicationRequest.ProtoReflect.Descriptor instead.
func (*ReplicationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{14}
}</span>

func (x *ReplicationRequest) GetOperations() []*Operation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Operations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ReplicationRequest) GetLogIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ReplicationRequest) GetLeaderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Operation struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Type          string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"` // PUT, DELETE
        Key           string                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
        Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
        Timestamp     int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Operation) Reset() <span class="cov0" title="0">{
        *x = Operation{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Operation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Operation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Operation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Operation.ProtoReflect.Descriptor instead.
func (*Operation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{15}
}</span>

func (x *Operation) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetTimestamp() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Operation) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReplicationResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        LastApplied   int64                  `protobuf:"varint,2,opt,name=last_applied,json=lastApplied,proto3" json:"last_applied,omitempty"`
        Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReplicationResponse) Reset() <span class="cov0" title="0">{
        *x = ReplicationResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReplicationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReplicationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReplicationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReplicationResponse.ProtoReflect.Descriptor instead.
func (*ReplicationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{16}
}</span>

func (x *ReplicationResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ReplicationResponse) GetLastApplied() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastApplied
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ReplicationResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SyncRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        LastIndex     int64                  `protobuf:"varint,2,opt,name=last_index,json=lastIndex,proto3" json:"last_index,omitempty"` // Last known log index
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SyncRequest) Reset() <span class="cov0" title="0">{
        *x = SyncRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SyncRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SyncRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SyncRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SyncRequest.ProtoReflect.Descriptor instead.
func (*SyncRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{17}
}</span>

func (x *SyncRequest) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SyncRequest) GetLastIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SyncResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Entries       []*LogEntry            `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
        CurrentIndex  int64                  `protobuf:"varint,2,opt,name=current_index,json=currentIndex,proto3" json:"current_index,omitempty"`
        HasMore       bool                   `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
        Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SyncResponse) Reset() <span class="cov0" title="0">{
        *x = SyncResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SyncResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SyncResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SyncResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SyncResponse.ProtoReflect.Descriptor instead.
func (*SyncResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{18}
}</span>

func (x *SyncResponse) GetEntries() []*LogEntry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entries
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SyncResponse) GetCurrentIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SyncResponse) GetHasMore() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasMore
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *SyncResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Health and monitoring messages
type PingRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        Timestamp     int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() <span class="cov0" title="0">{
        *x = PingRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{19}
}</span>

func (x *PingRequest) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PingRequest) GetTimestamp() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        Timestamp     int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() <span class="cov0" title="0">{
        *x = PingResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{20}
}</span>

func (x *PingResponse) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PingResponse) GetTimestamp() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PingResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ClusterStatusRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ClusterStatusRequest) Reset() <span class="cov0" title="0">{
        *x = ClusterStatusRequest{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ClusterStatusRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClusterStatusRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClusterStatusRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClusterStatusRequest.ProtoReflect.Descriptor instead.
func (*ClusterStatusRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{21}
}</span>

type ClusterStatusResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        LeaderId      string                 `protobuf:"bytes,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
        TotalNodes    int32                  `protobuf:"varint,2,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
        ActiveNodes   int32                  `protobuf:"varint,3,opt,name=active_nodes,json=activeNodes,proto3" json:"active_nodes,omitempty"`
        FailedNodes   int32                  `protobuf:"varint,4,opt,name=failed_nodes,json=failedNodes,proto3" json:"failed_nodes,omitempty"`
        Nodes         []*NodeInfo            `protobuf:"bytes,5,rep,name=nodes,proto3" json:"nodes,omitempty"`
        Health        *ClusterHealth         `protobuf:"bytes,6,opt,name=health,proto3" json:"health,omitempty"`
        Error         string                 `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ClusterStatusResponse) Reset() <span class="cov0" title="0">{
        *x = ClusterStatusResponse{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ClusterStatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClusterStatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClusterStatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClusterStatusResponse.ProtoReflect.Descriptor instead.
func (*ClusterStatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{22}
}</span>

func (x *ClusterStatusResponse) GetLeaderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClusterStatusResponse) GetTotalNodes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalNodes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ClusterStatusResponse) GetActiveNodes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActiveNodes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ClusterStatusResponse) GetFailedNodes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FailedNodes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ClusterStatusResponse) GetNodes() []*NodeInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Nodes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ClusterStatusResponse) GetHealth() *ClusterHealth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Health
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ClusterStatusResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ClusterHealth struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Status         string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`                                         // healthy, degraded, unhealthy
        ConsensusRatio float64                `protobuf:"fixed64,2,opt,name=consensus_ratio,json=consensusRatio,proto3" json:"consensus_ratio,omitempty"` // Ratio of nodes that can reach consensus
        LastElection   int64                  `protobuf:"varint,3,opt,name=last_election,json=lastElection,proto3" json:"last_election,omitempty"`        // Unix timestamp of last leader election
        Uptime         int64                  `protobuf:"varint,4,opt,name=uptime,proto3" json:"uptime,omitempty"`                                        // Cluster uptime in seconds
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *ClusterHealth) Reset() <span class="cov0" title="0">{
        *x = ClusterHealth{}
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ClusterHealth) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClusterHealth) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClusterHealth) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cluster_cluster_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClusterHealth.ProtoReflect.Descriptor instead.
func (*ClusterHealth) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cluster_cluster_proto_rawDescGZIP(), []int{23}
}</span>

func (x *ClusterHealth) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClusterHealth) GetConsensusRatio() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConsensusRatio
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ClusterHealth) GetLastElection() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastElection
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ClusterHealth) GetUptime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uptime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_proto_cluster_cluster_proto protoreflect.FileDescriptor

const file_proto_cluster_cluster_proto_rawDesc = "" +
        "\n" +
        "\x1bproto/cluster/cluster.proto\x12\acluster\"\xf7\x01\n" +
        "\vJoinRequest\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x18\n" +
        "\aaddress\x18\x02 \x01(\tR\aaddress\x12\x1b\n" +
        "\traft_port\x18\x03 \x01(\x05R\braftPort\x12\x1b\n" +
        "\tgrpc_port\x18\x04 \x01(\x05R\bgrpcPort\x12&gt;\n" +
        "\bmetadata\x18\x05 \x03(\v2\".cluster.JoinRequest.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x84\x01\n" +
        "\fJoinResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x1b\n" +
        "\tleader_id\x18\x02 \x01(\tR\bleaderId\x12'\n" +
        "\x05nodes\x18\x03 \x03(\v2\x11.cluster.NodeInfoR\x05nodes\x12\x14\n" +
        "\x05error\x18\x04 \x01(\tR\x05error\"=\n" +
        "\fLeaveRequest\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x14\n" +
        "\x05force\x18\x02 \x01(\bR\x05force\"?\n" +
        "\rLeaveResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"\x11\n" +
        "\x0fGetNodesRequest\"Q\n" +
        "\x10GetNodesResponse\x12'\n" +
        "\x05nodes\x18\x01 \x03(\v2\x11.cluster.NodeInfoR\x05nodes\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"\xb8\x02\n" +
        "\bNodeInfo\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x18\n" +
        "\aaddress\x18\x02 \x01(\tR\aaddress\x12\x1b\n" +
        "\traft_port\x18\x03 \x01(\x05R\braftPort\x12\x1b\n" +
        "\tgrpc_port\x18\x04 \x01(\x05R\bgrpcPort\x12\x14\n" +
        "\x05state\x18\x05 \x01(\tR\x05state\x12\x12\n" +
        "\x04role\x18\x06 \x01(\tR\x04role\x12\x1b\n" +
        "\tlast_seen\x18\a \x01(\x03R\blastSeen\x12;\n" +
        "\bmetadata\x18\b \x03(\v2\x1f.cluster.NodeInfo.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8e\x01\n" +
        "\vVoteRequest\x12\x12\n" +
        "\x04term\x18\x01 \x01(\x03R\x04term\x12!\n" +
        "\fcandidate_id\x18\x02 \x01(\tR\vcandidateId\x12$\n" +
        "\x0elast_log_index\x18\x03 \x01(\x03R\flastLogIndex\x12\"\n" +
        "\rlast_log_term\x18\x04 \x01(\x03R\vlastLogTerm\"E\n" +
        "\fVoteResponse\x12\x12\n" +
        "\x04term\x18\x01 \x01(\x03R\x04term\x12!\n" +
        "\fvote_granted\x18\x02 \x01(\bR\vvoteGranted\"\xdc\x01\n" +
        "\rAppendRequest\x12\x12\n" +
        "\x04term\x18\x01 \x01(\x03R\x04term\x12\x1b\n" +
        "\tleader_id\x18\x02 \x01(\tR\bleaderId\x12$\n" +
        "\x0eprev_log_index\x18\x03 \x01(\x03R\fprevLogIndex\x12\"\n" +
        "\rprev_log_term\x18\x04 \x01(\x03R\vprevLogTerm\x12+\n" +
        "\aentries\x18\x05 \x03(\v2\x11.cluster.LogEntryR\aentries\x12#\n" +
        "\rleader_commit\x18\x06 \x01(\x03R\fleaderCommit\"d\n" +
        "\x0eAppendResponse\x12\x12\n" +
        "\x04term\x18\x01 \x01(\x03R\x04term\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12$\n" +
        "\x0elast_log_index\x18\x03 \x01(\x03R\flastLogIndex\"z\n" +
        "\bLogEntry\x12\x14\n" +
        "\x05index\x18\x01 \x01(\x03R\x05index\x12\x12\n" +
        "\x04term\x18\x02 \x01(\x03R\x04term\x12\x12\n" +
        "\x04type\x18\x03 \x01(\tR\x04type\x12\x12\n" +
        "\x04data\x18\x04 \x01(\fR\x04data\x12\x1c\n" +
        "\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\"\xe0\x01\n" +
        "\x0fSnapshotRequest\x12\x12\n" +
        "\x04term\x18\x01 \x01(\x03R\x04term\x12\x1b\n" +
        "\tleader_id\x18\x02 \x01(\tR\bleaderId\x12.\n" +
        "\x13last_included_index\x18\x03 \x01(\x03R\x11lastIncludedIndex\x12,\n" +
        "\x12last_included_term\x18\x04 \x01(\x03R\x10lastIncludedTerm\x12\x12\n" +
        "\x04data\x18\x05 \x01(\fR\x04data\x12\x12\n" +
        "\x04done\x18\x06 \x01(\bR\x04done\x12\x16\n" +
        "\x06offset\x18\a \x01(\x03R\x06offset\"@\n" +
        "\x10SnapshotResponse\x12\x12\n" +
        "\x04term\x18\x01 \x01(\x03R\x04term\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\"\x82\x01\n" +
        "\x12ReplicationRequest\x122\n" +
        "\n" +
        "operations\x18\x01 \x03(\v2\x12.cluster.OperationR\n" +
        "operations\x12\x1b\n" +
        "\tlog_index\x18\x02 \x01(\x03R\blogIndex\x12\x1b\n" +
        "\tleader_id\x18\x03 \x01(\tR\bleaderId\"\xe0\x01\n" +
        "\tOperation\x12\x12\n" +
        "\x04type\x18\x01 \x01(\tR\x04type\x12\x10\n" +
        "\x03key\x18\x02 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x03 \x01(\fR\x05value\x12\x1c\n" +
        "\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x12&lt;\n" +
        "\bmetadata\x18\x05 \x03(\v2 .cluster.Operation.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"h\n" +
        "\x13ReplicationResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12!\n" +
        "\flast_applied\x18\x02 \x01(\x03R\vlastApplied\x12\x14\n" +
        "\x05error\x18\x03 \x01(\tR\x05error\"E\n" +
        "\vSyncRequest\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1d\n" +
        "\n" +
        "last_index\x18\x02 \x01(\x03R\tlastIndex\"\x91\x01\n" +
        "\fSyncResponse\x12+\n" +
        "\aentries\x18\x01 \x03(\v2\x11.cluster.LogEntryR\aentries\x12#\n" +
        "\rcurrent_index\x18\x02 \x01(\x03R\fcurrentIndex\x12\x19\n" +
        "\bhas_more\x18\x03 \x01(\bR\ahasMore\x12\x14\n" +
        "\x05error\x18\x04 \x01(\tR\x05error\"D\n" +
        "\vPingRequest\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1c\n" +
        "\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\"]\n" +
        "\fPingResponse\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1c\n" +
        "\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x16\n" +
        "\x06status\x18\x03 \x01(\tR\x06status\"\x16\n" +
        "\x14ClusterStatusRequest\"\x8a\x02\n" +
        "\x15ClusterStatusResponse\x12\x1b\n" +
        "\tleader_id\x18\x01 \x01(\tR\bleaderId\x12\x1f\n" +
        "\vtotal_nodes\x18\x02 \x01(\x05R\n" +
        "totalNodes\x12!\n" +
        "\factive_nodes\x18\x03 \x01(\x05R\vactiveNodes\x12!\n" +
        "\ffailed_nodes\x18\x04 \x01(\x05R\vfailedNodes\x12'\n" +
        "\x05nodes\x18\x05 \x03(\v2\x11.cluster.NodeInfoR\x05nodes\x12.\n" +
        "\x06health\x18\x06 \x01(\v2\x16.cluster.ClusterHealthR\x06health\x12\x14\n" +
        "\x05error\x18\a \x01(\tR\x05error\"\x8d\x01\n" +
        "\rClusterHealth\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\x12'\n" +
        "\x0fconsensus_ratio\x18\x02 \x01(\x01R\x0econsensusRatio\x12#\n" +
        "\rlast_election\x18\x03 \x01(\x03R\flastElection\x12\x16\n" +
        "\x06uptime\x18\x04 \x01(\x03R\x06uptime2\x9f\x05\n" +
        "\x0eClusterService\x12:\n" +
        "\vJoinCluster\x12\x14.cluster.JoinRequest\x1a\x15.cluster.JoinResponse\x12=\n" +
        "\fLeaveCluster\x12\x15.cluster.LeaveRequest\x1a\x16.cluster.LeaveResponse\x12?\n" +
        "\bGetNodes\x12\x18.cluster.GetNodesRequest\x1a\x19.cluster.GetNodesResponse\x12:\n" +
        "\vRequestVote\x12\x14.cluster.VoteRequest\x1a\x15.cluster.VoteResponse\x12@\n" +
        "\rAppendEntries\x12\x16.cluster.AppendRequest\x1a\x17.cluster.AppendResponse\x12F\n" +
        "\x0fInstallSnapshot\x12\x18.cluster.SnapshotRequest\x1a\x19.cluster.SnapshotResponse\x12J\n" +
        "\rReplicateData\x12\x1b.cluster.ReplicationRequest\x1a\x1c.cluster.ReplicationResponse\x127\n" +
        "\bSyncData\x12\x14.cluster.SyncRequest\x1a\x15.cluster.SyncResponse\x123\n" +
        "\x04Ping\x12\x14.cluster.PingRequest\x1a\x15.cluster.PingResponse\x12Q\n" +
        "\x10GetClusterStatus\x12\x1d.cluster.ClusterStatusRequest\x1a\x1e.cluster.ClusterStatusResponseB#Z!distributed-kvstore/proto/clusterb\x06proto3"

var (
        file_proto_cluster_cluster_proto_rawDescOnce sync.Once
        file_proto_cluster_cluster_proto_rawDescData []byte
)

func file_proto_cluster_cluster_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_cluster_cluster_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_cluster_cluster_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_cluster_cluster_proto_rawDesc), len(file_proto_cluster_cluster_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_cluster_cluster_proto_rawDescData</span>
}

var file_proto_cluster_cluster_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_proto_cluster_cluster_proto_goTypes = []any{
        (*JoinRequest)(nil),           // 0: cluster.JoinRequest
        (*JoinResponse)(nil),          // 1: cluster.JoinResponse
        (*LeaveRequest)(nil),          // 2: cluster.LeaveRequest
        (*LeaveResponse)(nil),         // 3: cluster.LeaveResponse
        (*GetNodesRequest)(nil),       // 4: cluster.GetNodesRequest
        (*GetNodesResponse)(nil),      // 5: cluster.GetNodesResponse
        (*NodeInfo)(nil),              // 6: cluster.NodeInfo
        (*VoteRequest)(nil),           // 7: cluster.VoteRequest
        (*VoteResponse)(nil),          // 8: cluster.VoteResponse
        (*AppendRequest)(nil),         // 9: cluster.AppendRequest
        (*AppendResponse)(nil),        // 10: cluster.AppendResponse
        (*LogEntry)(nil),              // 11: cluster.LogEntry
        (*SnapshotRequest)(nil),       // 12: cluster.SnapshotRequest
        (*SnapshotResponse)(nil),      // 13: cluster.SnapshotResponse
        (*ReplicationRequest)(nil),    // 14: cluster.ReplicationRequest
        (*Operation)(nil),             // 15: cluster.Operation
        (*ReplicationResponse)(nil),   // 16: cluster.ReplicationResponse
        (*SyncRequest)(nil),           // 17: cluster.SyncRequest
        (*SyncResponse)(nil),          // 18: cluster.SyncResponse
        (*PingRequest)(nil),           // 19: cluster.PingRequest
        (*PingResponse)(nil),          // 20: cluster.PingResponse
        (*ClusterStatusRequest)(nil),  // 21: cluster.ClusterStatusRequest
        (*ClusterStatusResponse)(nil), // 22: cluster.ClusterStatusResponse
        (*ClusterHealth)(nil),         // 23: cluster.ClusterHealth
        nil,                           // 24: cluster.JoinRequest.MetadataEntry
        nil,                           // 25: cluster.NodeInfo.MetadataEntry
        nil,                           // 26: cluster.Operation.MetadataEntry
}
var file_proto_cluster_cluster_proto_depIdxs = []int32{
        24, // 0: cluster.JoinRequest.metadata:type_name -&gt; cluster.JoinRequest.MetadataEntry
        6,  // 1: cluster.JoinResponse.nodes:type_name -&gt; cluster.NodeInfo
        6,  // 2: cluster.GetNodesResponse.nodes:type_name -&gt; cluster.NodeInfo
        25, // 3: cluster.NodeInfo.metadata:type_name -&gt; cluster.NodeInfo.MetadataEntry
        11, // 4: cluster.AppendRequest.entries:type_name -&gt; cluster.LogEntry
        15, // 5: cluster.ReplicationRequest.operations:type_name -&gt; cluster.Operation
        26, // 6: cluster.Operation.metadata:type_name -&gt; cluster.Operation.MetadataEntry
        11, // 7: cluster.SyncResponse.entries:type_name -&gt; cluster.LogEntry
        6,  // 8: cluster.ClusterStatusResponse.nodes:type_name -&gt; cluster.NodeInfo
        23, // 9: cluster.ClusterStatusResponse.health:type_name -&gt; cluster.ClusterHealth
        0,  // 10: cluster.ClusterService.JoinCluster:input_type -&gt; cluster.JoinRequest
        2,  // 11: cluster.ClusterService.LeaveCluster:input_type -&gt; cluster.LeaveRequest
        4,  // 12: cluster.ClusterService.GetNodes:input_type -&gt; cluster.GetNodesRequest
        7,  // 13: cluster.ClusterService.RequestVote:input_type -&gt; cluster.VoteRequest
        9,  // 14: cluster.ClusterService.AppendEntries:input_type -&gt; cluster.AppendRequest
        12, // 15: cluster.ClusterService.InstallSnapshot:input_type -&gt; cluster.SnapshotRequest
        14, // 16: cluster.ClusterService.ReplicateData:input_type -&gt; cluster.ReplicationRequest
        17, // 17: cluster.ClusterService.SyncData:input_type -&gt; cluster.SyncRequest
        19, // 18: cluster.ClusterService.Ping:input_type -&gt; cluster.PingRequest
        21, // 19: cluster.ClusterService.GetClusterStatus:input_type -&gt; cluster.ClusterStatusRequest
        1,  // 20: cluster.ClusterService.JoinCluster:output_type -&gt; cluster.JoinResponse
        3,  // 21: cluster.ClusterService.LeaveCluster:output_type -&gt; cluster.LeaveResponse
        5,  // 22: cluster.ClusterService.GetNodes:output_type -&gt; cluster.GetNodesResponse
        8,  // 23: cluster.ClusterService.RequestVote:output_type -&gt; cluster.VoteResponse
        10, // 24: cluster.ClusterService.AppendEntries:output_type -&gt; cluster.AppendResponse
        13, // 25: cluster.ClusterService.InstallSnapshot:output_type -&gt; cluster.SnapshotResponse
        16, // 26: cluster.ClusterService.ReplicateData:output_type -&gt; cluster.ReplicationResponse
        18, // 27: cluster.ClusterService.SyncData:output_type -&gt; cluster.SyncResponse
        20, // 28: cluster.ClusterService.Ping:output_type -&gt; cluster.PingResponse
        22, // 29: cluster.ClusterService.GetClusterStatus:output_type -&gt; cluster.ClusterStatusResponse
        20, // [20:30] is the sub-list for method output_type
        10, // [10:20] is the sub-list for method input_type
        10, // [10:10] is the sub-list for extension type_name
        10, // [10:10] is the sub-list for extension extendee
        0,  // [0:10] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_cluster_cluster_proto_init() }</span>
func file_proto_cluster_cluster_proto_init() <span class="cov0" title="0">{
        if File_proto_cluster_cluster_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_cluster_cluster_proto_rawDesc), len(file_proto_cluster_cluster_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   27,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_cluster_cluster_proto_goTypes,
                DependencyIndexes: file_proto_cluster_cluster_proto_depIdxs,
                MessageInfos:      file_proto_cluster_cluster_proto_msgTypes,
        }.Build()
        File_proto_cluster_cluster_proto = out.File
        file_proto_cluster_cluster_proto_goTypes = nil
        file_proto_cluster_cluster_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: proto/cluster/cluster.proto

package cluster

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        ClusterService_JoinCluster_FullMethodName      = "/cluster.ClusterService/JoinCluster"
        ClusterService_LeaveCluster_FullMethodName     = "/cluster.ClusterService/LeaveCluster"
        ClusterService_GetNodes_FullMethodName         = "/cluster.ClusterService/GetNodes"
        ClusterService_RequestVote_FullMethodName      = "/cluster.ClusterService/RequestVote"
        ClusterService_AppendEntries_FullMethodName    = "/cluster.ClusterService/AppendEntries"
        ClusterService_InstallSnapshot_FullMethodName  = "/cluster.ClusterService/InstallSnapshot"
        ClusterService_ReplicateData_FullMethodName    = "/cluster.ClusterService/ReplicateData"
        ClusterService_SyncData_FullMethodName         = "/cluster.ClusterService/SyncData"
        ClusterService_Ping_FullMethodName             = "/cluster.ClusterService/Ping"
        ClusterService_GetClusterStatus_FullMethodName = "/cluster.ClusterService/GetClusterStatus"
)

// ClusterServiceClient is the client API for ClusterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Cluster management service for internal node-to-node communication
type ClusterServiceClient interface {
        // Node management
        JoinCluster(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error)
        LeaveCluster(ctx context.Context, in *LeaveRequest, opts ...grpc.CallOption) (*LeaveResponse, error)
        GetNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (*GetNodesResponse, error)
        // Leadership and consensus
        RequestVote(ctx context.Context, in *VoteRequest, opts ...grpc.CallOption) (*VoteResponse, error)
        AppendEntries(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*AppendResponse, error)
        InstallSnapshot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error)
        // Data replication
        ReplicateData(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*ReplicationResponse, error)
        SyncData(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
        // Health and monitoring
        Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
        GetClusterStatus(ctx context.Context, in *ClusterStatusRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error)
}

type clusterServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewClusterServiceClient(cc grpc.ClientConnInterface) ClusterServiceClient <span class="cov0" title="0">{
        return &amp;clusterServiceClient{cc}
}</span>

func (c *clusterServiceClient) JoinCluster(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(JoinResponse)
        err := c.cc.Invoke(ctx, ClusterService_JoinCluster_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) LeaveCluster(ctx context.Context, in *LeaveRequest, opts ...grpc.CallOption) (*LeaveResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LeaveResponse)
        err := c.cc.Invoke(ctx, ClusterService_LeaveCluster_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) GetNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (*GetNodesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetNodesResponse)
        err := c.cc.Invoke(ctx, ClusterService_GetNodes_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) RequestVote(ctx context.Context, in *VoteRequest, opts ...grpc.CallOption) (*VoteResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(VoteResponse)
        err := c.cc.Invoke(ctx, ClusterService_RequestVote_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) AppendEntries(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*AppendResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AppendResponse)
        err := c.cc.Invoke(ctx, ClusterService_AppendEntries_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) InstallSnapshot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SnapshotResponse)
        err := c.cc.Invoke(ctx, ClusterService_InstallSnapshot_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) ReplicateData(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*ReplicationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ReplicationResponse)
        err := c.cc.Invoke(ctx, ClusterService_ReplicateData_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) SyncData(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SyncResponse)
        err := c.cc.Invoke(ctx, ClusterService_SyncData_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PingResponse)
        err := c.cc.Invoke(ctx, ClusterService_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *clusterServiceClient) GetClusterStatus(ctx context.Context, in *ClusterStatusRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ClusterStatusResponse)
        err := c.cc.Invoke(ctx, ClusterService_GetClusterStatus_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ClusterServiceServer is the server API for ClusterService service.
// All implementations must embed UnimplementedClusterServiceServer
// for forward compatibility.
//
// Cluster management service for internal node-to-node communication
type ClusterServiceServer interface {
        // Node management
        JoinCluster(context.Context, *JoinRequest) (*JoinResponse, error)
        LeaveCluster(context.Context, *LeaveRequest) (*LeaveResponse, error)
        GetNodes(context.Context, *GetNodesRequest) (*GetNodesResponse, error)
        // Leadership and consensus
        RequestVote(context.Context, *VoteRequest) (*VoteResponse, error)
        AppendEntries(context.Context, *AppendRequest) (*AppendResponse, error)
        InstallSnapshot(context.Context, *SnapshotRequest) (*SnapshotResponse, error)
        // Data replication
        ReplicateData(context.Context, *ReplicationRequest) (*ReplicationResponse, error)
        SyncData(context.Context, *SyncRequest) (*SyncResponse, error)
        // Health and monitoring
        Ping(context.Context, *PingRequest) (*PingResponse, error)
        GetClusterStatus(context.Context, *ClusterStatusRequest) (*ClusterStatusResponse, error)
        mustEmbedUnimplementedClusterServiceServer()
}

// UnimplementedClusterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClusterServiceServer struct{}

func (UnimplementedClusterServiceServer) JoinCluster(context.Context, *JoinRequest) (*JoinResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}</span>
func (UnimplementedClusterServiceServer) LeaveCluster(context.Context, *LeaveRequest) (*LeaveResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method LeaveCluster not implemented")
}</span>
func (UnimplementedClusterServiceServer) GetNodes(context.Context, *GetNodesRequest) (*GetNodesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetNodes not implemented")
}</span>
func (UnimplementedClusterServiceServer) RequestVote(context.Context, *VoteRequest) (*VoteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}</span>
func (UnimplementedClusterServiceServer) AppendEntries(context.Context, *AppendRequest) (*AppendResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AppendEntries not implemented")
}</span>
func (UnimplementedClusterServiceServer) InstallSnapshot(context.Context, *SnapshotRequest) (*SnapshotResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method InstallSnapshot not implemented")
}</span>
func (UnimplementedClusterServiceServer) ReplicateData(context.Context, *ReplicationRequest) (*ReplicationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReplicateData not implemented")
}</span>
func (UnimplementedClusterServiceServer) SyncData(context.Context, *SyncRequest) (*SyncResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SyncData not implemented")
}</span>
func (UnimplementedClusterServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedClusterServiceServer) GetClusterStatus(context.Context, *ClusterStatusRequest) (*ClusterStatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetClusterStatus not implemented")
}</span>
func (UnimplementedClusterServiceServer) mustEmbedUnimplementedClusterServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedClusterServiceServer) testEmbeddedByValue()                        {<span class="cov0" title="0">}</span>

// UnsafeClusterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServiceServer will
// result in compilation errors.
type UnsafeClusterServiceServer interface {
        mustEmbedUnimplementedClusterServiceServer()
}

func RegisterClusterServiceServer(s grpc.ServiceRegistrar, srv ClusterServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedClusterServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;ClusterService_ServiceDesc, srv)</span>
}

func _ClusterService_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(JoinRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).JoinCluster(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_JoinCluster_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).JoinCluster(ctx, req.(*JoinRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_LeaveCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LeaveRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).LeaveCluster(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_LeaveCluster_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).LeaveCluster(ctx, req.(*LeaveRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetNodesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).GetNodes(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_GetNodes_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).GetNodes(ctx, req.(*GetNodesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(VoteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).RequestVote(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_RequestVote_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).RequestVote(ctx, req.(*VoteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AppendRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).AppendEntries(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_AppendEntries_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).AppendEntries(ctx, req.(*AppendRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_InstallSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SnapshotRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).InstallSnapshot(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_InstallSnapshot_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).InstallSnapshot(ctx, req.(*SnapshotRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_ReplicateData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ReplicationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).ReplicateData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_ReplicateData_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).ReplicateData(ctx, req.(*ReplicationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_SyncData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SyncRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).SyncData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_SyncData_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).SyncData(ctx, req.(*SyncRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).Ping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).Ping(ctx, req.(*PingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ClusterService_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ClusterStatusRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).GetClusterStatus(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ClusterService_GetClusterStatus_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ClusterServiceServer).GetClusterStatus(ctx, req.(*ClusterStatusRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ClusterService_ServiceDesc is the grpc.ServiceDesc for ClusterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "cluster.ClusterService",
        HandlerType: (*ClusterServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "JoinCluster",
                        Handler:    _ClusterService_JoinCluster_Handler,
                },
                {
                        MethodName: "LeaveCluster",
                        Handler:    _ClusterService_LeaveCluster_Handler,
                },
                {
                        MethodName: "GetNodes",
                        Handler:    _ClusterService_GetNodes_Handler,
                },
                {
                        MethodName: "RequestVote",
                        Handler:    _ClusterService_RequestVote_Handler,
                },
                {
                        MethodName: "AppendEntries",
                        Handler:    _ClusterService_AppendEntries_Handler,
                },
                {
                        MethodName: "InstallSnapshot",
                        Handler:    _ClusterService_InstallSnapshot_Handler,
                },
                {
                        MethodName: "ReplicateData",
                        Handler:    _ClusterService_ReplicateData_Handler,
                },
                {
                        MethodName: "SyncData",
                        Handler:    _ClusterService_SyncData_Handler,
                },
                {
                        MethodName: "Ping",
                        Handler:    _ClusterService_Ping_Handler,
                },
                {
                        MethodName: "GetClusterStatus",
                        Handler:    _ClusterService_GetClusterStatus_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/cluster/cluster.proto",
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.7
//         protoc        v6.31.1
// source: proto/kvstore/kvstore.proto

package kvstore

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Basic operations messages
type PutRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        TtlSeconds    int64                  `protobuf:"varint,3,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"` // Time to live in seconds (0 = no expiration)
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PutRequest) Reset() <span class="cov0" title="0">{
        *x = PutRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PutRequest.ProtoReflect.Descriptor instead.
func (*PutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{0}
}</span>

func (x *PutRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PutRequest) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PutRequest) GetTtlSeconds() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TtlSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PutResponse) Reset() <span class="cov0" title="0">{
        *x = PutResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PutResponse.ProtoReflect.Descriptor instead.
func (*PutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PutResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *PutResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() <span class="cov0" title="0">{
        *x = GetRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Found         bool                   `protobuf:"varint,1,opt,name=found,proto3" json:"found,omitempty"`
        Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
        ExpiresAt     int64                  `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Unix timestamp (0 = no expiration)
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() <span class="cov0" title="0">{
        *x = GetResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetResponse) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetResponse) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{4}
}</span>

func (x *DeleteRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Existed       bool                   `protobuf:"varint,2,opt,name=existed,proto3" json:"existed,omitempty"` // Whether the key existed before deletion
        Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{5}
}</span>

func (x *DeleteResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DeleteResponse) GetExisted() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Existed
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DeleteResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ExistsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ExistsRequest) Reset() <span class="cov0" title="0">{
        *x = ExistsRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ExistsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExistsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExistsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExistsRequest.ProtoReflect.Descriptor instead.
func (*ExistsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{6}
}</span>

func (x *ExistsRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ExistsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Exists        bool                   `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ExistsResponse) Reset() <span class="cov0" title="0">{
        *x = ExistsResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ExistsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExistsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExistsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExistsResponse.ProtoReflect.Descriptor instead.
func (*ExistsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ExistsResponse) GetExists() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Exists
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ExistsResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Advanced operations messages
type ListRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Prefix        string                 `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
        Limit         int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`  // Maximum number of items to return (0 = no limit)
        Cursor        string                 `protobuf:"bytes,3,opt,name=cursor,proto3" json:"cursor,omitempty"` // Pagination cursor
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListRequest) Reset() <span class="cov0" title="0">{
        *x = ListRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListRequest.ProtoReflect.Descriptor instead.
func (*ListRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{8}
}</span>

func (x *ListRequest) GetPrefix() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListRequest) GetCursor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cursor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*KeyValue            `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        NextCursor    string                 `protobuf:"bytes,2,opt,name=next_cursor,json=nextCursor,proto3" json:"next_cursor,omitempty"` // Cursor for next page
        HasMore       bool                   `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`         // Whether there are more results
        Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListResponse) Reset() <span class="cov0" title="0">{
        *x = ListResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListResponse.ProtoReflect.Descriptor instead.
func (*ListResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ListResponse) GetItems() []*KeyValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListResponse) GetNextCursor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NextCursor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListResponse) GetHasMore() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasMore
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ListResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListKeysRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Prefix        string                 `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
        Limit         int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Cursor        string                 `protobuf:"bytes,3,opt,name=cursor,proto3" json:"cursor,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListKeysRequest) Reset() <span class="cov0" title="0">{
        *x = ListKeysRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListKeysRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListKeysRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListKeysRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListKeysRequest.ProtoReflect.Descriptor instead.
func (*ListKeysRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListKeysRequest) GetPrefix() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListKeysRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListKeysRequest) GetCursor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cursor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListKeysResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Keys          []string               `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
        NextCursor    string                 `protobuf:"bytes,2,opt,name=next_cursor,json=nextCursor,proto3" json:"next_cursor,omitempty"`
        HasMore       bool                   `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
        Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListKeysResponse) Reset() <span class="cov0" title="0">{
        *x = ListKeysResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListKeysResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListKeysResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListKeysResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListKeysResponse.ProtoReflect.Descriptor instead.
func (*ListKeysResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ListKeysResponse) GetKeys() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListKeysResponse) GetNextCursor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NextCursor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListKeysResponse) GetHasMore() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasMore
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ListKeysResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyValue struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KeyValue) Reset() <span class="cov0" title="0">{
        *x = KeyValue{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KeyValue) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KeyValue) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KeyValue) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KeyValue.ProtoReflect.Descriptor instead.
func (*KeyValue) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{12}
}</span>

func (x *KeyValue) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KeyValue) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KeyValue) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *KeyValue) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Batch operations messages
type BatchPutRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*PutItem             `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchPutRequest) Reset() <span class="cov0" title="0">{
        *x = BatchPutRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchPutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchPutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchPutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchPutRequest.ProtoReflect.Descriptor instead.
func (*BatchPutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{13}
}</span>

func (x *BatchPutRequest) GetItems() []*PutItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PutItem struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        TtlSeconds    int64                  `protobuf:"varint,3,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PutItem) Reset() <span class="cov0" title="0">{
        *x = PutItem{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PutItem) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PutItem) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PutItem) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PutItem.ProtoReflect.Descriptor instead.
func (*PutItem) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{14}
}</span>

func (x *PutItem) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PutItem) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PutItem) GetTtlSeconds() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TtlSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type BatchPutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        SuccessCount  int32                  `protobuf:"varint,1,opt,name=success_count,json=successCount,proto3" json:"success_count,omitempty"`
        ErrorCount    int32                  `protobuf:"varint,2,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
        Errors        []*BatchError          `protobuf:"bytes,3,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchPutResponse) Reset() <span class="cov0" title="0">{
        *x = BatchPutResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchPutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchPutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchPutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchPutResponse.ProtoReflect.Descriptor instead.
func (*BatchPutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{15}
}</span>

func (x *BatchPutResponse) GetSuccessCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SuccessCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BatchPutResponse) GetErrorCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ErrorCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BatchPutResponse) GetErrors() []*BatchError <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchGetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Keys          []string               `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchGetRequest) Reset() <span class="cov0" title="0">{
        *x = BatchGetRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchGetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchGetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchGetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchGetRequest.ProtoReflect.Descriptor instead.
func (*BatchGetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{16}
}</span>

func (x *BatchGetRequest) GetKeys() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchGetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Results       []*GetResult           `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchGetResponse) Reset() <span class="cov0" title="0">{
        *x = BatchGetResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchGetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchGetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchGetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchGetResponse.ProtoReflect.Descriptor instead.
func (*BatchGetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{17}
}</span>

func (x *BatchGetResponse) GetResults() []*GetResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Results
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BatchGetResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetResult) Reset() <span class="cov0" title="0">{
        *x = GetResult{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetResult.ProtoReflect.Descriptor instead.
func (*GetResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{18}
}</span>

func (x *GetResult) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetResult) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetResult) GetValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetResult) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetResult) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type BatchDeleteRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Keys          []string               `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchDeleteRequest) Reset() <span class="cov0" title="0">{
        *x = BatchDeleteRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchDeleteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchDeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchDeleteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchDeleteRequest.ProtoReflect.Descriptor instead.
func (*BatchDeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{19}
}</span>

func (x *BatchDeleteRequest) GetKeys() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchDeleteResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        SuccessCount  int32                  `protobuf:"varint,1,opt,name=success_count,json=successCount,proto3" json:"success_count,omitempty"`
        ErrorCount    int32                  `protobuf:"varint,2,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
        Errors        []*BatchError          `protobuf:"bytes,3,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchDeleteResponse) Reset() <span class="cov0" title="0">{
        *x = BatchDeleteResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchDeleteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchDeleteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchDeleteResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchDeleteResponse.ProtoReflect.Descriptor instead.
func (*BatchDeleteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{20}
}</span>

func (x *BatchDeleteResponse) GetSuccessCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SuccessCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BatchDeleteResponse) GetErrorCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ErrorCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BatchDeleteResponse) GetErrors() []*BatchError <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchError struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchError) Reset() <span class="cov0" title="0">{
        *x = BatchError{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchError) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchError) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchError) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchError.ProtoReflect.Descriptor instead.
func (*BatchError) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{21}
}</span>

func (x *BatchError) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BatchError) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Storage management messages
type BackupRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"` // Backup file path
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BackupRequest) Reset() <span class="cov0" title="0">{
        *x = BackupRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BackupRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BackupRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BackupRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BackupRequest.ProtoReflect.Descriptor instead.
func (*BackupRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{22}
}</span>

func (x *BackupRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BackupResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`  // Actual backup file path
        Size          int64                  `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"` // Backup file size in bytes
        Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BackupResponse) Reset() <span class="cov0" title="0">{
        *x = BackupResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BackupResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BackupResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BackupResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BackupResponse.ProtoReflect.Descriptor instead.
func (*BackupResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{23}
}</span>

func (x *BackupResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BackupResponse) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BackupResponse) GetSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BackupResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RestoreRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"` // Restore file path
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RestoreRequest) Reset() <span class="cov0" title="0">{
        *x = RestoreRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RestoreRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RestoreRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RestoreRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RestoreRequest.ProtoReflect.Descriptor instead.
func (*RestoreRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{24}
}</span>

func (x *RestoreRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RestoreResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        RestoredCount int64                  `protobuf:"varint,2,opt,name=restored_count,json=restoredCount,proto3" json:"restored_count,omitempty"` // Number of keys restored
        Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RestoreResponse) Reset() <span class="cov0" title="0">{
        *x = RestoreResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RestoreResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RestoreResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RestoreResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RestoreResponse.ProtoReflect.Descriptor instead.
func (*RestoreResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{25}
}</span>

func (x *RestoreResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *RestoreResponse) GetRestoredCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RestoredCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RestoreResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatsRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        IncludeDetails bool                   `protobuf:"varint,1,opt,name=include_details,json=includeDetails,proto3" json:"include_details,omitempty"` // Include detailed statistics
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *StatsRequest) Reset() <span class="cov0" title="0">{
        *x = StatsRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[26]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[26]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsRequest.ProtoReflect.Descriptor instead.
func (*StatsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{26}
}</span>

func (x *StatsRequest) GetIncludeDetails() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IncludeDetails
        }</span>
        <span class="cov0" title="0">return false</span>
}

type StatsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TotalKeys     int64                  `protobuf:"varint,1,opt,name=total_keys,json=totalKeys,proto3" json:"total_keys,omitempty"`
        TotalSize     int64                  `protobuf:"varint,2,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`                                                     // Total size in bytes
        LsmSize       int64                  `protobuf:"varint,3,opt,name=lsm_size,json=lsmSize,proto3" json:"lsm_size,omitempty"`                                                           // LSM tree size
        VlogSize      int64                  `protobuf:"varint,4,opt,name=vlog_size,json=vlogSize,proto3" json:"vlog_size,omitempty"`                                                        // Value log size
        Details       map[string]string      `protobuf:"bytes,5,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Additional detailed stats
        Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsResponse) Reset() <span class="cov0" title="0">{
        *x = StatsResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsResponse.ProtoReflect.Descriptor instead.
func (*StatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{27}
}</span>

func (x *StatsResponse) GetTotalKeys() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalKeys
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetTotalSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetLsmSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LsmSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetVlogSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VlogSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetDetails() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StatsResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Health and status messages
type HealthRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HealthRequest) Reset() <span class="cov0" title="0">{
        *x = HealthRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[28]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HealthRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[28]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthRequest.ProtoReflect.Descriptor instead.
func (*HealthRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{28}
}</span>

type HealthResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Healthy       bool                   `protobuf:"varint,1,opt,name=healthy,proto3" json:"healthy,omitempty"`
        Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        UptimeSeconds int64                  `protobuf:"varint,3,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
        Version       string                 `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HealthResponse) Reset() <span class="cov0" title="0">{
        *x = HealthResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[29]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HealthResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[29]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
func (*HealthResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{29}
}</span>

func (x *HealthResponse) GetHealthy() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Healthy
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *HealthResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HealthResponse) GetUptimeSeconds() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UptimeSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *HealthResponse) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatusRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatusRequest) Reset() <span class="cov0" title="0">{
        *x = StatusRequest{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[30]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatusRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[30]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{30}
}</span>

type StatusResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        Role          string                 `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`                                                                                   // leader, follower, candidate
        State         string                 `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`                                                                                 // running, starting, stopping
        Peers         []string               `protobuf:"bytes,4,rep,name=peers,proto3" json:"peers,omitempty"`                                                                                 // Connected peers
        LastApplied   int64                  `protobuf:"varint,5,opt,name=last_applied,json=lastApplied,proto3" json:"last_applied,omitempty"`                                                 // Last applied log index
        CommitIndex   int64                  `protobuf:"varint,6,opt,name=commit_index,json=commitIndex,proto3" json:"commit_index,omitempty"`                                                 // Commit index
        LeaderId      string                 `protobuf:"bytes,7,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`                                                           // Current leader ID
        Metadata      map[string]string      `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Additional metadata
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatusResponse) Reset() <span class="cov0" title="0">{
        *x = StatusResponse{}
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[31]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_kvstore_kvstore_proto_msgTypes[31]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_kvstore_kvstore_proto_rawDescGZIP(), []int{31}
}</span>

func (x *StatusResponse) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatusResponse) GetRole() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatusResponse) GetState() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.State
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatusResponse) GetPeers() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Peers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StatusResponse) GetLastApplied() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastApplied
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatusResponse) GetCommitIndex() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommitIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatusResponse) GetLeaderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeaderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatusResponse) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_kvstore_kvstore_proto protoreflect.FileDescriptor

const file_proto_kvstore_kvstore_proto_rawDesc = "" +
        "\n" +
        "\x1bproto/kvstore/kvstore.proto\x12\akvstore\"U\n" +
        "\n" +
        "PutRequest\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\fR\x05value\x12\x1f\n" +
        "\vttl_seconds\x18\x03 \x01(\x03R\n" +
        "ttlSeconds\"=\n" +
        "\vPutResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"\x1e\n" +
        "\n" +
        "GetRequest\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\"\x8d\x01\n" +
        "\vGetResponse\x12\x14\n" +
        "\x05found\x18\x01 \x01(\bR\x05found\x12\x14\n" +
        "\x05value\x18\x02 \x01(\fR\x05value\x12\x14\n" +
        "\x05error\x18\x03 \x01(\tR\x05error\x12\x1d\n" +
        "\n" +
        "created_at\x18\x04 \x01(\x03R\tcreatedAt\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x05 \x01(\x03R\texpiresAt\"!\n" +
        "\rDeleteRequest\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\"Z\n" +
        "\x0eDeleteResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\aexisted\x18\x02 \x01(\bR\aexisted\x12\x14\n" +
        "\x05error\x18\x03 \x01(\tR\x05error\"!\n" +
        "\rExistsRequest\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\"&gt;\n" +
        "\x0eExistsResponse\x12\x16\n" +
        "\x06exists\x18\x01 \x01(\bR\x06exists\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"S\n" +
        "\vListRequest\x12\x16\n" +
        "\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x14\n" +
        "\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06cursor\x18\x03 \x01(\tR\x06cursor\"\x89\x01\n" +
        "\fListResponse\x12'\n" +
        "\x05items\x18\x01 \x03(\v2\x11.kvstore.KeyValueR\x05items\x12\x1f\n" +
        "\vnext_cursor\x18\x02 \x01(\tR\n" +
        "nextCursor\x12\x19\n" +
        "\bhas_more\x18\x03 \x01(\bR\ahasMore\x12\x14\n" +
        "\x05error\x18\x04 \x01(\tR\x05error\"W\n" +
        "\x0fListKeysRequest\x12\x16\n" +
        "\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x14\n" +
        "\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06cursor\x18\x03 \x01(\tR\x06cursor\"x\n" +
        "\x10ListKeysResponse\x12\x12\n" +
        "\x04keys\x18\x01 \x03(\tR\x04keys\x12\x1f\n" +
        "\vnext_cursor\x18\x02 \x01(\tR\n" +
        "nextCursor\x12\x19\n" +
        "\bhas_more\x18\x03 \x01(\bR\ahasMore\x12\x14\n" +
        "\x05error\x18\x04 \x01(\tR\x05error\"p\n" +
        "\bKeyValue\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\fR\x05value\x12\x1d\n" +
        "\n" +
        "created_at\x18\x03 \x01(\x03R\tcreatedAt\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x04 \x01(\x03R\texpiresAt\"9\n" +
        "\x0fBatchPutRequest\x12&amp;\n" +
        "\x05items\x18\x01 \x03(\v2\x10.kvstore.PutItemR\x05items\"R\n" +
        "\aPutItem\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\fR\x05value\x12\x1f\n" +
        "\vttl_seconds\x18\x03 \x01(\x03R\n" +
        "ttlSeconds\"\x85\x01\n" +
        "\x10BatchPutResponse\x12#\n" +
        "\rsuccess_count\x18\x01 \x01(\x05R\fsuccessCount\x12\x1f\n" +
        "\verror_count\x18\x02 \x01(\x05R\n" +
        "errorCount\x12+\n" +
        "\x06errors\x18\x03 \x03(\v2\x13.kvstore.BatchErrorR\x06errors\"%\n" +
        "\x0fBatchGetRequest\x12\x12\n" +
        "\x04keys\x18\x01 \x03(\tR\x04keys\"V\n" +
        "\x10BatchGetResponse\x12,\n" +
        "\aresults\x18\x01 \x03(\v2\x12.kvstore.GetResultR\aresults\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"\x87\x01\n" +
        "\tGetResult\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05found\x18\x02 \x01(\bR\x05found\x12\x14\n" +
        "\x05value\x18\x03 \x01(\fR\x05value\x12\x1d\n" +
        "\n" +
        "created_at\x18\x04 \x01(\x03R\tcreatedAt\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x05 \x01(\x03R\texpiresAt\"(\n" +
        "\x12BatchDeleteRequest\x12\x12\n" +
        "\x04keys\x18\x01 \x03(\tR\x04keys\"\x88\x01\n" +
        "\x13BatchDeleteResponse\x12#\n" +
        "\rsuccess_count\x18\x01 \x01(\x05R\fsuccessCount\x12\x1f\n" +
        "\verror_count\x18\x02 \x01(\x05R\n" +
        "errorCount\x12+\n" +
        "\x06errors\x18\x03 \x03(\v2\x13.kvstore.BatchErrorR\x06errors\"4\n" +
        "\n" +
        "BatchError\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"#\n" +
        "\rBackupRequest\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\"h\n" +
        "\x0eBackupResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\x12\x12\n" +
        "\x04size\x18\x03 \x01(\x03R\x04size\x12\x14\n" +
        "\x05error\x18\x04 \x01(\tR\x05error\"$\n" +
        "\x0eRestoreRequest\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\"h\n" +
        "\x0fRestoreResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12%\n" +
        "\x0erestored_count\x18\x02 \x01(\x03R\rrestoredCount\x12\x14\n" +
        "\x05error\x18\x03 \x01(\tR\x05error\"7\n" +
        "\fStatsRequest\x12'\n" +
        "\x0finclude_details\x18\x01 \x01(\bR\x0eincludeDetails\"\x96\x02\n" +
        "\rStatsResponse\x12\x1d\n" +
        "\n" +
        "total_keys\x18\x01 \x01(\x03R\ttotalKeys\x12\x1d\n" +
        "\n" +
        "total_size\x18\x02 \x01(\x03R\ttotalSize\x12\x19\n" +
        "\blsm_size\x18\x03 \x01(\x03R\alsmSize\x12\x1b\n" +
        "\tvlog_size\x18\x04 \x01(\x03R\bvlogSize\x12=\n" +
        "\adetails\x18\x05 \x03(\v2#.kvstore.StatsResponse.DetailsEntryR\adetails\x12\x14\n" +
        "\x05error\x18\x06 \x01(\tR\x05error\x1a:\n" +
        "\fDetailsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x0f\n" +
        "\rHealthRequest\"\x83\x01\n" +
        "\x0eHealthResponse\x12\x18\n" +
        "\ahealthy\x18\x01 \x01(\bR\ahealthy\x12\x16\n" +
        "\x06status\x18\x02 \x01(\tR\x06status\x12%\n" +
        "\x0euptime_seconds\x18\x03 \x01(\x03R\ruptimeSeconds\x12\x18\n" +
        "\aversion\x18\x04 \x01(\tR\aversion\"\x0f\n" +
        "\rStatusRequest\"\xcc\x02\n" +
        "\x0eStatusResponse\x12\x17\n" +
        "\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x12\n" +
        "\x04role\x18\x02 \x01(\tR\x04role\x12\x14\n" +
        "\x05state\x18\x03 \x01(\tR\x05state\x12\x14\n" +
        "\x05peers\x18\x04 \x03(\tR\x05peers\x12!\n" +
        "\flast_applied\x18\x05 \x01(\x03R\vlastApplied\x12!\n" +
        "\fcommit_index\x18\x06 \x01(\x03R\vcommitIndex\x12\x1b\n" +
        "\tleader_id\x18\a \x01(\tR\bleaderId\x12A\n" +
        "\bmetadata\x18\b \x03(\v2%.kvstore.StatusResponse.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x012\xcc\x06\n" +
        "\aKVStore\x120\n" +
        "\x03Put\x12\x13.kvstore.PutRequest\x1a\x14.kvstore.PutResponse\x120\n" +
        "\x03Get\x12\x13.kvstore.GetRequest\x1a\x14.kvstore.GetResponse\x129\n" +
        "\x06Delete\x12\x16.kvstore.DeleteRequest\x1a\x17.kvstore.DeleteResponse\x129\n" +
        "\x06Exists\x12\x16.kvstore.ExistsRequest\x1a\x17.kvstore.ExistsResponse\x123\n" +
        "\x04List\x12\x14.kvstore.ListRequest\x1a\x15.kvstore.ListResponse\x12?\n" +
        "\bListKeys\x12\x18.kvstore.ListKeysRequest\x1a\x19.kvstore.ListKeysResponse\x12?\n" +
        "\bBatchPut\x12\x18.kvstore.BatchPutRequest\x1a\x19.kvstore.BatchPutResponse\x12?\n" +
        "\bBatchGet\x12\x18.kvstore.BatchGetRequest\x1a\x19.kvstore.BatchGetResponse\x12H\n" +
        "\vBatchDelete\x12\x1b.kvstore.BatchDeleteRequest\x1a\x1c.kvstore.BatchDeleteResponse\x129\n" +
        "\x06Backup\x12\x16.kvstore.BackupRequest\x1a\x17.kvstore.BackupResponse\x12&lt;\n" +
        "\aRestore\x12\x17.kvstore.RestoreRequest\x1a\x18.kvstore.RestoreResponse\x126\n" +
        "\x05Stats\x12\x15.kvstore.StatsRequest\x1a\x16.kvstore.StatsResponse\x129\n" +
        "\x06Health\x12\x16.kvstore.HealthRequest\x1a\x17.kvstore.HealthResponse\x129\n" +
        "\x06Status\x12\x16.kvstore.StatusRequest\x1a\x17.kvstore.StatusResponseB#Z!distributed-kvstore/proto/kvstoreb\x06proto3"

var (
        file_proto_kvstore_kvstore_proto_rawDescOnce sync.Once
        file_proto_kvstore_kvstore_proto_rawDescData []byte
)

func file_proto_kvstore_kvstore_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_kvstore_kvstore_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_kvstore_kvstore_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_kvstore_kvstore_proto_rawDesc), len(file_proto_kvstore_kvstore_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_kvstore_kvstore_proto_rawDescData</span>
}

var file_proto_kvstore_kvstore_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_proto_kvstore_kvstore_proto_goTypes = []any{
        (*PutRequest)(nil),          // 0: kvstore.PutRequest
        (*PutResponse)(nil),         // 1: kvstore.PutResponse
        (*GetRequest)(nil),          // 2: kvstore.GetRequest
        (*GetResponse)(nil),         // 3: kvstore.GetResponse
        (*DeleteRequest)(nil),       // 4: kvstore.DeleteRequest
        (*DeleteResponse)(nil),      // 5: kvstore.DeleteResponse
        (*ExistsRequest)(nil),       // 6: kvstore.ExistsRequest
        (*ExistsResponse)(nil),      // 7: kvstore.ExistsResponse
        (*ListRequest)(nil),         // 8: kvstore.ListRequest
        (*ListResponse)(nil),        // 9: kvstore.ListResponse
        (*ListKeysRequest)(nil),     // 10: kvstore.ListKeysRequest
        (*ListKeysResponse)(nil),    // 11: kvstore.ListKeysResponse
        (*KeyValue)(nil),            // 12: kvstore.KeyValue
        (*BatchPutRequest)(nil),     // 13: kvstore.BatchPutRequest
        (*PutItem)(nil),             // 14: kvstore.PutItem
        (*BatchPutResponse)(nil),    // 15: kvstore.BatchPutResponse
        (*BatchGetRequest)(nil),     // 16: kvstore.BatchGetRequest
        (*BatchGetResponse)(nil),    // 17: kvstore.BatchGetResponse
        (*GetResult)(nil),           // 18: kvstore.GetResult
        (*BatchDeleteRequest)(nil),  // 19: kvstore.BatchDeleteRequest
        (*BatchDeleteResponse)(nil), // 20: kvstore.BatchDeleteResponse
        (*BatchError)(nil),          // 21: kvstore.BatchError
        (*BackupRequest)(nil),       // 22: kvstore.BackupRequest
        (*BackupResponse)(nil),      // 23: kvstore.BackupResponse
        (*RestoreRequest)(nil),      // 24: kvstore.RestoreRequest
        (*RestoreResponse)(nil),     // 25: kvstore.RestoreResponse
        (*StatsRequest)(nil),        // 26: kvstore.StatsRequest
        (*StatsResponse)(nil),       // 27: kvstore.StatsResponse
        (*HealthRequest)(nil),       // 28: kvstore.HealthRequest
        (*HealthResponse)(nil),      // 29: kvstore.HealthResponse
        (*StatusRequest)(nil),       // 30: kvstore.StatusRequest
        (*StatusResponse)(nil),      // 31: kvstore.StatusResponse
        nil,                         // 32: kvstore.StatsResponse.DetailsEntry
        nil,                         // 33: kvstore.StatusResponse.MetadataEntry
}
var file_proto_kvstore_kvstore_proto_depIdxs = []int32{
        12, // 0: kvstore.ListResponse.items:type_name -&gt; kvstore.KeyValue
        14, // 1: kvstore.BatchPutRequest.items:type_name -&gt; kvstore.PutItem
        21, // 2: kvstore.BatchPutResponse.errors:type_name -&gt; kvstore.BatchError
        18, // 3: kvstore.BatchGetResponse.results:type_name -&gt; kvstore.GetResult
        21, // 4: kvstore.BatchDeleteResponse.errors:type_name -&gt; kvstore.BatchError
        32, // 5: kvstore.StatsResponse.details:type_name -&gt; kvstore.StatsResponse.DetailsEntry
        33, // 6: kvstore.StatusResponse.metadata:type_name -&gt; kvstore.StatusResponse.MetadataEntry
        0,  // 7: kvstore.KVStore.Put:input_type -&gt; kvstore.PutRequest
        2,  // 8: kvstore.KVStore.Get:input_type -&gt; kvstore.GetRequest
        4,  // 9: kvstore.KVStore.Delete:input_type -&gt; kvstore.DeleteRequest
        6,  // 10: kvstore.KVStore.Exists:input_type -&gt; kvstore.ExistsRequest
        8,  // 11: kvstore.KVStore.List:input_type -&gt; kvstore.ListRequest
        10, // 12: kvstore.KVStore.ListKeys:input_type -&gt; kvstore.ListKeysRequest
        13, // 13: kvstore.KVStore.BatchPut:input_type -&gt; kvstore.BatchPutRequest
        16, // 14: kvstore.KVStore.BatchGet:input_type -&gt; kvstore.BatchGetRequest
        19, // 15: kvstore.KVStore.BatchDelete:input_type -&gt; kvstore.BatchDeleteRequest
        22, // 16: kvstore.KVStore.Backup:input_type -&gt; kvstore.BackupRequest
        24, // 17: kvstore.KVStore.Restore:input_type -&gt; kvstore.RestoreRequest
        26, // 18: kvstore.KVStore.Stats:input_type -&gt; kvstore.StatsRequest
        28, // 19: kvstore.KVStore.Health:input_type -&gt; kvstore.HealthRequest
        30, // 20: kvstore.KVStore.Status:input_type -&gt; kvstore.StatusRequest
        1,  // 21: kvstore.KVStore.Put:output_type -&gt; kvstore.PutResponse
        3,  // 22: kvstore.KVStore.Get:output_type -&gt; kvstore.GetResponse
        5,  // 23: kvstore.KVStore.Delete:output_type -&gt; kvstore.DeleteResponse
        7,  // 24: kvstore.KVStore.Exists:output_type -&gt; kvstore.ExistsResponse
        9,  // 25: kvstore.KVStore.List:output_type -&gt; kvstore.ListResponse
        11, // 26: kvstore.KVStore.ListKeys:output_type -&gt; kvstore.ListKeysResponse
        15, // 27: kvstore.KVStore.BatchPut:output_type -&gt; kvstore.BatchPutResponse
        17, // 28: kvstore.KVStore.BatchGet:output_type -&gt; kvstore.BatchGetResponse
        20, // 29: kvstore.KVStore.BatchDelete:output_type -&gt; kvstore.BatchDeleteResponse
        23, // 30: kvstore.KVStore.Backup:output_type -&gt; kvstore.BackupResponse
        25, // 31: kvstore.KVStore.Restore:output_type -&gt; kvstore.RestoreResponse
        27, // 32: kvstore.KVStore.Stats:output_type -&gt; kvstore.StatsResponse
        29, // 33: kvstore.KVStore.Health:output_type -&gt; kvstore.HealthResponse
        31, // 34: kvstore.KVStore.Status:output_type -&gt; kvstore.StatusResponse
        21, // [21:35] is the sub-list for method output_type
        7,  // [7:21] is the sub-list for method input_type
        7,  // [7:7] is the sub-list for extension type_name
        7,  // [7:7] is the sub-list for extension extendee
        0,  // [0:7] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_kvstore_kvstore_proto_init() }</span>
func file_proto_kvstore_kvstore_proto_init() <span class="cov0" title="0">{
        if File_proto_kvstore_kvstore_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_kvstore_kvstore_proto_rawDesc), len(file_proto_kvstore_kvstore_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   34,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_kvstore_kvstore_proto_goTypes,
                DependencyIndexes: file_proto_kvstore_kvstore_proto_depIdxs,
                MessageInfos:      file_proto_kvstore_kvstore_proto_msgTypes,
        }.Build()
        File_proto_kvstore_kvstore_proto = out.File
        file_proto_kvstore_kvstore_proto_goTypes = nil
        file_proto_kvstore_kvstore_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: proto/kvstore/kvstore.proto

package kvstore

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        KVStore_Put_FullMethodName         = "/kvstore.KVStore/Put"
        KVStore_Get_FullMethodName         = "/kvstore.KVStore/Get"
        KVStore_Delete_FullMethodName      = "/kvstore.KVStore/Delete"
        KVStore_Exists_FullMethodName      = "/kvstore.KVStore/Exists"
        KVStore_List_FullMethodName        = "/kvstore.KVStore/List"
        KVStore_ListKeys_FullMethodName    = "/kvstore.KVStore/ListKeys"
        KVStore_BatchPut_FullMethodName    = "/kvstore.KVStore/BatchPut"
        KVStore_BatchGet_FullMethodName    = "/kvstore.KVStore/BatchGet"
        KVStore_BatchDelete_FullMethodName = "/kvstore.KVStore/BatchDelete"
        KVStore_Backup_FullMethodName      = "/kvstore.KVStore/Backup"
        KVStore_Restore_FullMethodName     = "/kvstore.KVStore/Restore"
        KVStore_Stats_FullMethodName       = "/kvstore.KVStore/Stats"
        KVStore_Health_FullMethodName      = "/kvstore.KVStore/Health"
        KVStore_Status_FullMethodName      = "/kvstore.KVStore/Status"
)

// KVStoreClient is the client API for KVStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Key-value store service definition
type KVStoreClient interface {
        // Basic CRUD operations
        Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error)
        Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
        Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
        Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
        // Advanced operations
        List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
        ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
        // Batch operations
        BatchPut(ctx context.Context, in *BatchPutRequest, opts ...grpc.CallOption) (*BatchPutResponse, error)
        BatchGet(ctx context.Context, in *BatchGetRequest, opts ...grpc.CallOption) (*BatchGetResponse, error)
        BatchDelete(ctx context.Context, in *BatchDeleteRequest, opts ...grpc.CallOption) (*BatchDeleteResponse, error)
        // Storage management
        Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*BackupResponse, error)
        Restore(ctx context.Context, in *RestoreRequest, opts ...grpc.CallOption) (*RestoreResponse, error)
        Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error)
        // Health and status
        Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
        Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type kVStoreClient struct {
        cc grpc.ClientConnInterface
}

func NewKVStoreClient(cc grpc.ClientConnInterface) KVStoreClient <span class="cov0" title="0">{
        return &amp;kVStoreClient{cc}
}</span>

func (c *kVStoreClient) Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PutResponse)
        err := c.cc.Invoke(ctx, KVStore_Put_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetResponse)
        err := c.cc.Invoke(ctx, KVStore_Get_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteResponse)
        err := c.cc.Invoke(ctx, KVStore_Delete_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ExistsResponse)
        err := c.cc.Invoke(ctx, KVStore_Exists_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListResponse)
        err := c.cc.Invoke(ctx, KVStore_List_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListKeysResponse)
        err := c.cc.Invoke(ctx, KVStore_ListKeys_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) BatchPut(ctx context.Context, in *BatchPutRequest, opts ...grpc.CallOption) (*BatchPutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BatchPutResponse)
        err := c.cc.Invoke(ctx, KVStore_BatchPut_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) BatchGet(ctx context.Context, in *BatchGetRequest, opts ...grpc.CallOption) (*BatchGetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BatchGetResponse)
        err := c.cc.Invoke(ctx, KVStore_BatchGet_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) BatchDelete(ctx context.Context, in *BatchDeleteRequest, opts ...grpc.CallOption) (*BatchDeleteResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BatchDeleteResponse)
        err := c.cc.Invoke(ctx, KVStore_BatchDelete_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*BackupResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BackupResponse)
        err := c.cc.Invoke(ctx, KVStore_Backup_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Restore(ctx context.Context, in *RestoreRequest, opts ...grpc.CallOption) (*RestoreResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RestoreResponse)
        err := c.cc.Invoke(ctx, KVStore_Restore_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatsResponse)
        err := c.cc.Invoke(ctx, KVStore_Stats_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(HealthResponse)
        err := c.cc.Invoke(ctx, KVStore_Health_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVStoreClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, KVStore_Status_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// KVStoreServer is the server API for KVStore service.
// All implementations must embed UnimplementedKVStoreServer
// for forward compatibility.
//
// Key-value store service definition
type KVStoreServer interface {
        // Basic CRUD operations
        Put(context.Context, *PutRequest) (*PutResponse, error)
        Get(context.Context, *GetRequest) (*GetResponse, error)
        Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
        Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
        // Advanced operations
        List(context.Context, *ListRequest) (*ListResponse, error)
        ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
        // Batch operations
        BatchPut(context.Context, *BatchPutRequest) (*BatchPutResponse, error)
        BatchGet(context.Context, *BatchGetRequest) (*BatchGetResponse, error)
        BatchDelete(context.Context, *BatchDeleteRequest) (*BatchDeleteResponse, error)
        // Storage management
        Backup(context.Context, *BackupRequest) (*BackupResponse, error)
        Restore(context.Context, *RestoreRequest) (*RestoreResponse, error)
        Stats(context.Context, *StatsRequest) (*StatsResponse, error)
        // Health and status
        Health(context.Context, *HealthRequest) (*HealthResponse, error)
        Status(context.Context, *StatusRequest) (*StatusResponse, error)
        mustEmbedUnimplementedKVStoreServer()
}

// UnimplementedKVStoreServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKVStoreServer struct{}

func (UnimplementedKVStoreServer) Put(context.Context, *PutRequest) (*PutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}</span>
func (UnimplementedKVStoreServer) Get(context.Context, *GetRequest) (*GetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}</span>
func (UnimplementedKVStoreServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}</span>
func (UnimplementedKVStoreServer) Exists(context.Context, *ExistsRequest) (*ExistsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}</span>
func (UnimplementedKVStoreServer) List(context.Context, *ListRequest) (*ListResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}</span>
func (UnimplementedKVStoreServer) ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}</span>
func (UnimplementedKVStoreServer) BatchPut(context.Context, *BatchPutRequest) (*BatchPutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchPut not implemented")
}</span>
func (UnimplementedKVStoreServer) BatchGet(context.Context, *BatchGetRequest) (*BatchGetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchGet not implemented")
}</span>
func (UnimplementedKVStoreServer) BatchDelete(context.Context, *BatchDeleteRequest) (*BatchDeleteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchDelete not implemented")
}</span>
func (UnimplementedKVStoreServer) Backup(context.Context, *BackupRequest) (*BackupResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Backup not implemented")
}</span>
func (UnimplementedKVStoreServer) Restore(context.Context, *RestoreRequest) (*RestoreResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}</span>
func (UnimplementedKVStoreServer) Stats(context.Context, *StatsRequest) (*StatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Stats not implemented")
}</span>
func (UnimplementedKVStoreServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}</span>
func (UnimplementedKVStoreServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}</span>
func (UnimplementedKVStoreServer) mustEmbedUnimplementedKVStoreServer() {<span class="cov0" title="0">}</span>
func (UnimplementedKVStoreServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafeKVStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVStoreServer will
// result in compilation errors.
type UnsafeKVStoreServer interface {
        mustEmbedUnimplementedKVStoreServer()
}

func RegisterKVStoreServer(s grpc.ServiceRegistrar, srv KVStoreServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedKVStoreServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;KVStore_ServiceDesc, srv)</span>
}

func _KVStore_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Put(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Put_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Put(ctx, req.(*PutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Get(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Get_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Get(ctx, req.(*GetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Delete(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Delete_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Delete(ctx, req.(*DeleteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ExistsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Exists(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Exists_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Exists(ctx, req.(*ExistsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).List(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_List_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).List(ctx, req.(*ListRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListKeysRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).ListKeys(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_ListKeys_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).ListKeys(ctx, req.(*ListKeysRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_BatchPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BatchPutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).BatchPut(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_BatchPut_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).BatchPut(ctx, req.(*BatchPutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_BatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BatchGetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).BatchGet(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_BatchGet_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).BatchGet(ctx, req.(*BatchGetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_BatchDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BatchDeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).BatchDelete(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_BatchDelete_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).BatchDelete(ctx, req.(*BatchDeleteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Backup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BackupRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Backup(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Backup_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Backup(ctx, req.(*BackupRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RestoreRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Restore(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Restore_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Restore(ctx, req.(*RestoreRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StatsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Stats(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Stats_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Stats(ctx, req.(*StatsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(HealthRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Health(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Health_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Health(ctx, req.(*HealthRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVStore_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StatusRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Status(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KVStore_Status_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVStoreServer).Status(ctx, req.(*StatusRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// KVStore_ServiceDesc is the grpc.ServiceDesc for KVStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KVStore_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "kvstore.KVStore",
        HandlerType: (*KVStoreServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Put",
                        Handler:    _KVStore_Put_Handler,
                },
                {
                        MethodName: "Get",
                        Handler:    _KVStore_Get_Handler,
                },
                {
                        MethodName: "Delete",
                        Handler:    _KVStore_Delete_Handler,
                },
                {
                        MethodName: "Exists",
                        Handler:    _KVStore_Exists_Handler,
                },
                {
                        MethodName: "List",
                        Handler:    _KVStore_List_Handler,
                },
                {
                        MethodName: "ListKeys",
                        Handler:    _KVStore_ListKeys_Handler,
                },
                {
                        MethodName: "BatchPut",
                        Handler:    _KVStore_BatchPut_Handler,
                },
                {
                        MethodName: "BatchGet",
                        Handler:    _KVStore_BatchGet_Handler,
                },
                {
                        MethodName: "BatchDelete",
                        Handler:    _KVStore_BatchDelete_Handler,
                },
                {
                        MethodName: "Backup",
                        Handler:    _KVStore_Backup_Handler,
                },
                {
                        MethodName: "Restore",
                        Handler:    _KVStore_Restore_Handler,
                },
                {
                        MethodName: "Stats",
                        Handler:    _KVStore_Stats_Handler,
                },
                {
                        MethodName: "Health",
                        Handler:    _KVStore_Health_Handler,
                },
                {
                        MethodName: "Status",
                        Handler:    _KVStore_Status_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/kvstore/kvstore.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
