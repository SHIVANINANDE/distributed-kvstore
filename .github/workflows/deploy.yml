name: Deployment & Rollback

on:
  repository_dispatch:
    types: [new_release, deploy]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version:
        description: 'Version to deploy'
        required: true
        default: 'latest'
      action:
        description: 'Deployment action'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - rollback
        - canary
        - blue-green
      rollback_version:
        description: 'Version to rollback to (for rollback action)'
        required: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment Validation
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deploy_version: ${{ steps.version.outputs.version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      environment: ${{ steps.config.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine deployment configuration
      id: config
      run: |
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "action=deploy" >> $GITHUB_OUTPUT
        else
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
        fi

    - name: Determine version to deploy
      id: version
      run: |
        if [ "${{ github.event.inputs.action }}" = "rollback" ]; then
          echo "version=${{ github.event.inputs.rollback_version }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          echo "version=${{ github.event.client_payload.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        fi
        
        # Get previous version for comparison
        PREVIOUS_VERSION=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "v0.0.0")
        echo "previous_version=${PREVIOUS_VERSION#v}" >> $GITHUB_OUTPUT

    - name: Validate deployment prerequisites
      run: |
        # Check if version exists
        if [ "${{ steps.version.outputs.version }}" != "latest" ]; then
          if ! git tag -l | grep -q "^v${{ steps.version.outputs.version }}$"; then
            echo "Error: Version v${{ steps.version.outputs.version }} does not exist"
            exit 1
          fi
        fi
        
        # Check environment-specific prerequisites
        case "${{ steps.config.outputs.environment }}" in
          production)
            # Production requires manual approval and higher security
            echo "Production deployment requires additional validation"
            ;;
          staging)
            echo "Staging deployment validation passed"
            ;;
        esac

    - name: Security scan for deployment
      if: steps.config.outputs.action == 'deploy'
      run: |
        # Quick security validation before deployment
        echo "Running pre-deployment security checks..."
        # Add security validation logic here

  # Environment Approval
  environment-approval:
    name: Environment Approval
    runs-on: ubuntu-latest
    needs: pre-deployment
    environment: 
      name: ${{ needs.pre-deployment.outputs.environment }}
      url: https://${{ needs.pre-deployment.outputs.environment }}.kvstore.example.com
    if: needs.pre-deployment.outputs.environment == 'production'
    
    steps:
    - name: Manual approval checkpoint
      run: |
        echo "Deployment to ${{ needs.pre-deployment.outputs.environment }} approved"
        echo "Version: ${{ needs.pre-deployment.outputs.deploy_version }}"

  # Blue-Green Deployment
  blue-green-deploy:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, environment-approval]
    if: always() && !failure() && github.event.inputs.action == 'blue-green'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

    - name: Deploy to blue environment
      run: |
        # Deploy new version to blue environment
        kubectl apply -f k8s/manifests/ --namespace=kvstore-blue
        
        # Wait for rollout to complete
        kubectl rollout status statefulset/kvstore -n kvstore-blue --timeout=600s

    - name: Run health checks on blue environment
      run: |
        # Health check script
        ./scripts/health-check.sh kvstore-blue

    - name: Switch traffic to blue environment
      run: |
        # Update service selectors to point to blue environment
        kubectl patch service kvstore -n kvstore -p '{"spec":{"selector":{"deployment":"blue"}}}'

    - name: Monitor deployment
      run: |
        # Monitor for 5 minutes after traffic switch
        sleep 300
        ./scripts/monitor-deployment.sh kvstore-blue

  # Canary Deployment
  canary-deploy:
    name: Canary Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, environment-approval]
    if: always() && !failure() && github.event.inputs.action == 'canary'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

    - name: Deploy canary version (10% traffic)
      run: |
        # Create canary deployment with 10% traffic
        envsubst < k8s/deploy-templates/canary.yaml | kubectl apply -f -
        
        # Configure traffic splitting
        kubectl apply -f - <<EOF
        apiVersion: networking.istio.io/v1beta1
        kind: VirtualService
        metadata:
          name: kvstore-canary
          namespace: kvstore
        spec:
          hosts:
          - kvstore.example.com
          http:
          - match:
            - headers:
                canary:
                  exact: "true"
            route:
            - destination:
                host: kvstore-canary
              weight: 100
          - route:
            - destination:
                host: kvstore
              weight: 90
            - destination:
                host: kvstore-canary
              weight: 10
        EOF

    - name: Monitor canary metrics
      run: |
        # Monitor canary for 10 minutes
        python3 scripts/canary-analysis.py --duration=600 --threshold=0.01

    - name: Promote canary (50% traffic)
      run: |
        # Increase canary traffic to 50%
        kubectl patch virtualservice kvstore-canary -n kvstore --type='json' \
          -p='[{"op": "replace", "path": "/spec/http/1/route/0/weight", "value": 50}]'
        kubectl patch virtualservice kvstore-canary -n kvstore --type='json' \
          -p='[{"op": "replace", "path": "/spec/http/1/route/1/weight", "value": 50}]'

    - name: Final canary validation
      run: |
        # Monitor for another 5 minutes
        python3 scripts/canary-analysis.py --duration=300 --threshold=0.005

    - name: Complete canary promotion
      run: |
        # Switch 100% traffic to canary
        kubectl patch service kvstore -n kvstore -p '{"spec":{"selector":{"version":"canary"}}}'
        
        # Clean up old deployment
        kubectl delete deployment kvstore-old -n kvstore --ignore-not-found=true

  # Standard Rolling Deployment
  rolling-deploy:
    name: Rolling Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, environment-approval]
    if: always() && !failure() && github.event.inputs.action == 'deploy'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.12.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

    - name: Create deployment backup
      run: |
        # Backup current deployment state
        kubectl get kvstore production-cluster -n kvstore -o yaml > backup-kvstore-$(date +%Y%m%d-%H%M%S).yaml
        
        # Store in artifact for potential rollback
        mkdir -p deployment-backups
        cp backup-kvstore-*.yaml deployment-backups/

    - name: Deploy with Helm
      run: |
        helm upgrade --install kvstore-${{ needs.pre-deployment.outputs.environment }} \
          ./charts/kvstore \
          --namespace kvstore \
          --set image.tag=${{ needs.pre-deployment.outputs.deploy_version }} \
          --set environment=${{ needs.pre-deployment.outputs.environment }} \
          --timeout=600s \
          --wait

    - name: Verify deployment
      run: |
        # Wait for all pods to be ready
        kubectl wait --for=condition=ready pod -l app=kvstore -n kvstore --timeout=600s
        
        # Verify KVStore custom resource is ready
        kubectl wait --for=condition=ready kvstore/production-cluster -n kvstore --timeout=600s

    - name: Run post-deployment tests
      run: |
        # Run smoke tests
        ./scripts/smoke-tests.sh ${{ needs.pre-deployment.outputs.environment }}
        
        # Run integration tests
        ./scripts/integration-tests.sh ${{ needs.pre-deployment.outputs.environment }}

    - name: Update deployment tracking
      run: |
        # Record successful deployment
        kubectl annotate kvstore production-cluster -n kvstore \
          deployment.kvstore.io/deployed-version=${{ needs.pre-deployment.outputs.deploy_version }} \
          deployment.kvstore.io/deployed-at=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
          deployment.kvstore.io/deployed-by="github-actions"

    - name: Upload deployment backup
      uses: actions/upload-artifact@v3
      with:
        name: deployment-backup-${{ needs.pre-deployment.outputs.environment }}
        path: deployment-backups/

  # Rollback Deployment
  rollback-deploy:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, environment-approval]
    if: always() && !failure() && github.event.inputs.action == 'rollback'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.12.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

    - name: Validate rollback version
      run: |
        # Ensure rollback version exists and is different from current
        CURRENT_VERSION=$(kubectl get kvstore production-cluster -n kvstore -o jsonpath='{.spec.cluster.version}')
        ROLLBACK_VERSION=${{ needs.pre-deployment.outputs.deploy_version }}
        
        if [ "$CURRENT_VERSION" = "$ROLLBACK_VERSION" ]; then
          echo "Error: Rollback version is the same as current version"
          exit 1
        fi
        
        echo "Rolling back from $CURRENT_VERSION to $ROLLBACK_VERSION"

    - name: Create pre-rollback backup
      run: |
        kubectl get kvstore production-cluster -n kvstore -o yaml > pre-rollback-backup-$(date +%Y%m%d-%H%M%S).yaml

    - name: Execute rollback
      run: |
        # Use Helm rollback if available
        helm rollback kvstore-${{ needs.pre-deployment.outputs.environment }} \
          --namespace kvstore \
          --timeout=600s \
          --wait || \
        # Fallback to manual rollback
        kubectl patch kvstore production-cluster -n kvstore --type='merge' \
          -p='{"spec":{"cluster":{"version":"'${{ needs.pre-deployment.outputs.deploy_version }}'","image":"'${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-kvstore:${{ needs.pre-deployment.outputs.deploy_version }}'"}}}'

    - name: Wait for rollback completion
      run: |
        # Wait for StatefulSet rollback
        kubectl rollout status statefulset/kvstore -n kvstore --timeout=600s
        
        # Verify all pods are ready
        kubectl wait --for=condition=ready pod -l app=kvstore -n kvstore --timeout=600s

    - name: Validate rollback
      run: |
        # Run smoke tests to ensure rollback was successful
        ./scripts/smoke-tests.sh ${{ needs.pre-deployment.outputs.environment }}
        
        # Verify cluster health
        ./scripts/cluster-health-check.sh

    - name: Update rollback tracking
      run: |
        kubectl annotate kvstore production-cluster -n kvstore \
          deployment.kvstore.io/rolled-back-from=${{ needs.pre-deployment.outputs.previous_version }} \
          deployment.kvstore.io/rolled-back-to=${{ needs.pre-deployment.outputs.deploy_version }} \
          deployment.kvstore.io/rolled-back-at=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
          deployment.kvstore.io/rolled-back-by="github-actions"

  # Automatic Rollback on Failure
  auto-rollback:
    name: Automatic Rollback
    runs-on: ubuntu-latest
    needs: [rolling-deploy, canary-deploy, blue-green-deploy]
    if: failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

    - name: Get previous stable version
      id: prev_version
      run: |
        # Get the last successful deployment version
        PREV_VERSION=$(kubectl get kvstore production-cluster -n kvstore \
          -o jsonpath='{.metadata.annotations.deployment\.kvstore\.io/deployed-version}' 2>/dev/null || echo "")
        
        if [ -z "$PREV_VERSION" ]; then
          # Fallback to previous git tag
          PREV_VERSION=$(git describe --tags --abbrev=0 HEAD~1 | sed 's/v//')
        fi
        
        echo "previous_version=$PREV_VERSION" >> $GITHUB_OUTPUT

    - name: Execute automatic rollback
      run: |
        echo "Deployment failed. Initiating automatic rollback to ${{ steps.prev_version.outputs.previous_version }}"
        
        # Perform rollback
        kubectl patch kvstore production-cluster -n kvstore --type='merge' \
          -p='{"spec":{"cluster":{"version":"'${{ steps.prev_version.outputs.previous_version }}'","image":"'${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-kvstore:${{ steps.prev_version.outputs.previous_version }}'"}}}'

    - name: Wait for automatic rollback
      run: |
        kubectl rollout status statefulset/kvstore -n kvstore --timeout=600s
        kubectl wait --for=condition=ready pod -l app=kvstore -n kvstore --timeout=600s

    - name: Notify failure and rollback
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            "text": "🚨 Deployment Failed - Automatic Rollback Executed",
            "attachments": [
              {
                "color": "danger",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Environment",
                    "value": "${{ needs.pre-deployment.outputs.environment }}",
                    "short": true
                  },
                  {
                    "title": "Failed Version",
                    "value": "${{ needs.pre-deployment.outputs.deploy_version }}",
                    "short": true
                  },
                  {
                    "title": "Rolled Back To",
                    "value": "${{ steps.prev_version.outputs.previous_version }}",
                    "short": true
                  },
                  {
                    "title": "Action Required",
                    "value": "Please investigate the deployment failure",
                    "short": false
                  }
                ]
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Post-deployment Monitoring
  post-deployment:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [rolling-deploy, canary-deploy, blue-green-deploy, rollback-deploy]
    if: always() && !failure()
    
    steps:
    - name: Setup monitoring
      run: |
        # Wait 5 minutes for metrics to stabilize
        sleep 300

    - name: Check deployment health
      run: |
        # Run comprehensive health checks
        ./scripts/post-deployment-health-check.sh ${{ needs.pre-deployment.outputs.environment }}

    - name: Monitor key metrics
      run: |
        # Monitor for 15 minutes post-deployment
        python3 scripts/post-deployment-monitor.py \
          --environment=${{ needs.pre-deployment.outputs.environment }} \
          --duration=900 \
          --version=${{ needs.pre-deployment.outputs.deploy_version }}

    - name: Generate deployment report
      run: |
        # Create deployment success report
        python3 scripts/deployment-report.py \
          --environment=${{ needs.pre-deployment.outputs.environment }} \
          --version=${{ needs.pre-deployment.outputs.deploy_version }} \
          --output=deployment-report.html

    - name: Upload deployment report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report-${{ needs.pre-deployment.outputs.environment }}
        path: deployment-report.html

  # Notification
  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [pre-deployment, rolling-deploy, canary-deploy, blue-green-deploy, rollback-deploy, post-deployment]
    if: always() && !failure()
    
    steps:
    - name: Notify successful deployment
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        message: |
          ✅ Deployment Successful!
          
          **Environment**: ${{ needs.pre-deployment.outputs.environment }}
          **Version**: ${{ needs.pre-deployment.outputs.deploy_version }}
          **Action**: ${{ github.event.inputs.action || 'deploy' }}
          **Repository**: ${{ github.repository }}
          
          🔗 **Environment URL**: https://${{ needs.pre-deployment.outputs.environment }}.kvstore.example.com
          📊 **Monitoring**: https://grafana.example.com/d/kvstore-${{ needs.pre-deployment.outputs.environment }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}