package server

import (
	"context"
	"fmt"
	"net"
	"strconv"
	"time"

	"distributed-kvstore/internal/config"
	"distributed-kvstore/internal/logging"
	"distributed-kvstore/internal/storage"
	"distributed-kvstore/proto/kvstore"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type GRPCServer struct {
	kvstore.UnimplementedKVStoreServer
	config  *config.Config
	storage storage.StorageEngine
	logger  *logging.Logger
	server  *grpc.Server
}

func NewGRPCServer(cfg *config.Config, storageEngine storage.StorageEngine, logger *logging.Logger) *GRPCServer {
	return &GRPCServer{
		config:  cfg,
		storage: storageEngine,
		logger:  logger,
	}
}

func (s *GRPCServer) Start() error {
	addr := fmt.Sprintf("%s:%d", s.config.Server.Host, s.config.Server.GRPCPort)
	
	lis, err := net.Listen("tcp", addr)
	if err != nil {
		return fmt.Errorf("failed to listen on %s: %w", addr, err)
	}

	opts := []grpc.ServerOption{
		grpc.UnaryInterceptor(s.loggingInterceptor),
		grpc.MaxRecvMsgSize(int(s.config.Server.MaxBodySize)),
		grpc.MaxSendMsgSize(int(s.config.Server.MaxBodySize)),
	}

	s.server = grpc.NewServer(opts...)
	kvstore.RegisterKVStoreServer(s.server, s)

	s.logger.Info("Starting gRPC server",
		"address", addr,
		"service", "grpc",
	)

	return s.server.Serve(lis)
}

func (s *GRPCServer) Stop() {
	if s.server != nil {
		s.logger.Info("Stopping gRPC server")
		s.server.GracefulStop()
	}
}

func (s *GRPCServer) loggingInterceptor(
	ctx context.Context,
	req interface{},
	info *grpc.UnaryServerInfo,
	handler grpc.UnaryHandler,
) (interface{}, error) {
	start := time.Now()

	resp, err := handler(ctx, req)

	duration := time.Since(start)
	
	if err != nil {
		s.logger.Error("gRPC request failed",
			"method", info.FullMethod,
			"duration_ms", duration.Milliseconds(),
			"error", err.Error(),
		)
	} else {
		s.logger.Debug("gRPC request completed",
			"method", info.FullMethod,
			"duration_ms", duration.Milliseconds(),
		)
	}

	return resp, err
}

func (s *GRPCServer) Put(ctx context.Context, req *kvstore.PutRequest) (*kvstore.PutResponse, error) {
	if req.Key == "" {
		return &kvstore.PutResponse{
			Success: false,
			Error:   "key cannot be empty",
		}, status.Error(codes.InvalidArgument, "key cannot be empty")
	}

	s.logger.DebugContext(ctx, "Processing put request",
		"operation", "put",
		"key", req.Key,
		"ttl", req.TtlSeconds,
	)

	start := time.Now()
	err := s.storage.Put([]byte(req.Key), req.Value)
	duration := time.Since(start)
	
	if err != nil {
		s.logger.DatabaseOperation(ctx, "put", req.Key, duration, err)
		return &kvstore.PutResponse{
			Success: false,
			Error:   err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	return &kvstore.PutResponse{
		Success: true,
	}, nil
}

func (s *GRPCServer) Get(ctx context.Context, req *kvstore.GetRequest) (*kvstore.GetResponse, error) {
	if req.Key == "" {
		return &kvstore.GetResponse{
			Found: false,
			Error: "key cannot be empty",
		}, status.Error(codes.InvalidArgument, "key cannot be empty")
	}

	s.logger.WithFields(logrus.Fields{
		"operation": "get",
		"key":       req.Key,
	}).Debug("Processing get request")

	value, err := s.storage.Get([]byte(req.Key))
	if err != nil {
		if err == storage.ErrKeyNotFound {
			return &kvstore.GetResponse{
				Found: false,
			}, nil
		}
		
		s.logger.WithError(err).WithField("key", req.Key).Error("Failed to get key")
		return &kvstore.GetResponse{
			Found: false,
			Error: err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	return &kvstore.GetResponse{
		Found:     true,
		Value:     value,
		CreatedAt: time.Now().Unix(),
	}, nil
}

func (s *GRPCServer) Delete(ctx context.Context, req *kvstore.DeleteRequest) (*kvstore.DeleteResponse, error) {
	if req.Key == "" {
		return &kvstore.DeleteResponse{
			Success: false,
			Error:   "key cannot be empty",
		}, status.Error(codes.InvalidArgument, "key cannot be empty")
	}

	s.logger.WithFields(logrus.Fields{
		"operation": "delete",
		"key":       req.Key,
	}).Debug("Processing delete request")

	existed, err := s.storage.Exists([]byte(req.Key))
	if err != nil {
		s.logger.WithError(err).WithField("key", req.Key).Error("Failed to check key existence")
		return &kvstore.DeleteResponse{
			Success: false,
			Error:   err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	err = s.storage.Delete([]byte(req.Key))
	if err != nil {
		s.logger.WithError(err).WithField("key", req.Key).Error("Failed to delete key")
		return &kvstore.DeleteResponse{
			Success: false,
			Existed: existed,
			Error:   err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	return &kvstore.DeleteResponse{
		Success: true,
		Existed: existed,
	}, nil
}

func (s *GRPCServer) Exists(ctx context.Context, req *kvstore.ExistsRequest) (*kvstore.ExistsResponse, error) {
	if req.Key == "" {
		return &kvstore.ExistsResponse{
			Exists: false,
			Error:  "key cannot be empty",
		}, status.Error(codes.InvalidArgument, "key cannot be empty")
	}

	s.logger.WithFields(logrus.Fields{
		"operation": "exists",
		"key":       req.Key,
	}).Debug("Processing exists request")

	exists, err := s.storage.Exists([]byte(req.Key))
	if err != nil {
		s.logger.WithError(err).WithField("key", req.Key).Error("Failed to check key existence")
		return &kvstore.ExistsResponse{
			Exists: false,
			Error:  err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	return &kvstore.ExistsResponse{
		Exists: exists,
	}, nil
}

func (s *GRPCServer) List(ctx context.Context, req *kvstore.ListRequest) (*kvstore.ListResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "list",
		"prefix":    req.Prefix,
		"limit":     req.Limit,
		"cursor":    req.Cursor,
	}).Debug("Processing list request")

	data, err := s.storage.List([]byte(req.Prefix))
	if err != nil {
		s.logger.WithError(err).WithField("prefix", req.Prefix).Error("Failed to list keys")
		return &kvstore.ListResponse{
			Error: err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	var items []*kvstore.KeyValue
	count := 0
	
	for key, value := range data {
		if req.Limit > 0 && count >= int(req.Limit) {
			break
		}
		
		items = append(items, &kvstore.KeyValue{
			Key:       key,
			Value:     value,
			CreatedAt: time.Now().Unix(),
		})
		count++
	}

	return &kvstore.ListResponse{
		Items:   items,
		HasMore: req.Limit > 0 && len(data) > int(req.Limit),
	}, nil
}

func (s *GRPCServer) ListKeys(ctx context.Context, req *kvstore.ListKeysRequest) (*kvstore.ListKeysResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "list_keys",
		"prefix":    req.Prefix,
		"limit":     req.Limit,
		"cursor":    req.Cursor,
	}).Debug("Processing list keys request")

	data, err := s.storage.List([]byte(req.Prefix))
	if err != nil {
		s.logger.WithError(err).WithField("prefix", req.Prefix).Error("Failed to list keys")
		return &kvstore.ListKeysResponse{
			Error: err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	var keys []string
	count := 0
	
	for key := range data {
		if req.Limit > 0 && count >= int(req.Limit) {
			break
		}
		keys = append(keys, key)
		count++
	}

	return &kvstore.ListKeysResponse{
		Keys:    keys,
		HasMore: req.Limit > 0 && len(data) > int(req.Limit),
	}, nil
}

func (s *GRPCServer) BatchPut(ctx context.Context, req *kvstore.BatchPutRequest) (*kvstore.BatchPutResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "batch_put",
		"count":     len(req.Items),
	}).Debug("Processing batch put request")

	successCount := int32(0)
	errorCount := int32(0)
	var errors []*kvstore.BatchError

	for _, item := range req.Items {
		if item.Key == "" {
			errorCount++
			errors = append(errors, &kvstore.BatchError{
				Key:   item.Key,
				Error: "key cannot be empty",
			})
			continue
		}

		err := s.storage.Put([]byte(item.Key), item.Value)
		if err != nil {
			errorCount++
			errors = append(errors, &kvstore.BatchError{
				Key:   item.Key,
				Error: err.Error(),
			})
			s.logger.WithError(err).WithField("key", item.Key).Error("Failed to put key in batch")
		} else {
			successCount++
		}
	}

	return &kvstore.BatchPutResponse{
		SuccessCount: successCount,
		ErrorCount:   errorCount,
		Errors:       errors,
	}, nil
}

func (s *GRPCServer) BatchGet(ctx context.Context, req *kvstore.BatchGetRequest) (*kvstore.BatchGetResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "batch_get",
		"count":     len(req.Keys),
	}).Debug("Processing batch get request")

	var results []*kvstore.GetResult

	for _, key := range req.Keys {
		if key == "" {
			results = append(results, &kvstore.GetResult{
				Key:   key,
				Found: false,
			})
			continue
		}

		value, err := s.storage.Get([]byte(key))
		if err != nil {
			if err == storage.ErrKeyNotFound {
				results = append(results, &kvstore.GetResult{
					Key:   key,
					Found: false,
				})
			} else {
				s.logger.WithError(err).WithField("key", key).Error("Failed to get key in batch")
				return &kvstore.BatchGetResponse{
					Error: err.Error(),
				}, status.Error(codes.Internal, err.Error())
			}
		} else {
			results = append(results, &kvstore.GetResult{
				Key:       key,
				Found:     true,
				Value:     value,
				CreatedAt: time.Now().Unix(),
			})
		}
	}

	return &kvstore.BatchGetResponse{
		Results: results,
	}, nil
}

func (s *GRPCServer) BatchDelete(ctx context.Context, req *kvstore.BatchDeleteRequest) (*kvstore.BatchDeleteResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "batch_delete",
		"count":     len(req.Keys),
	}).Debug("Processing batch delete request")

	successCount := int32(0)
	errorCount := int32(0)
	var errors []*kvstore.BatchError

	for _, key := range req.Keys {
		if key == "" {
			errorCount++
			errors = append(errors, &kvstore.BatchError{
				Key:   key,
				Error: "key cannot be empty",
			})
			continue
		}

		err := s.storage.Delete([]byte(key))
		if err != nil {
			errorCount++
			errors = append(errors, &kvstore.BatchError{
				Key:   key,
				Error: err.Error(),
			})
			s.logger.WithError(err).WithField("key", key).Error("Failed to delete key in batch")
		} else {
			successCount++
		}
	}

	return &kvstore.BatchDeleteResponse{
		SuccessCount: successCount,
		ErrorCount:   errorCount,
		Errors:       errors,
	}, nil
}

func (s *GRPCServer) Backup(ctx context.Context, req *kvstore.BackupRequest) (*kvstore.BackupResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "backup",
		"path":      req.Path,
	}).Info("Processing backup request")

	if req.Path == "" {
		return &kvstore.BackupResponse{
			Success: false,
			Error:   "backup path cannot be empty",
		}, status.Error(codes.InvalidArgument, "backup path cannot be empty")
	}

	err := s.storage.Backup(req.Path)
	if err != nil {
		s.logger.WithError(err).WithField("path", req.Path).Error("Failed to create backup")
		return &kvstore.BackupResponse{
			Success: false,
			Error:   err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	return &kvstore.BackupResponse{
		Success: true,
		Path:    req.Path,
	}, nil
}

func (s *GRPCServer) Restore(ctx context.Context, req *kvstore.RestoreRequest) (*kvstore.RestoreResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation": "restore",
		"path":      req.Path,
	}).Info("Processing restore request")

	if req.Path == "" {
		return &kvstore.RestoreResponse{
			Success: false,
			Error:   "restore path cannot be empty",
		}, status.Error(codes.InvalidArgument, "restore path cannot be empty")
	}

	err := s.storage.Restore(req.Path)
	if err != nil {
		s.logger.WithError(err).WithField("path", req.Path).Error("Failed to restore from backup")
		return &kvstore.RestoreResponse{
			Success: false,
			Error:   err.Error(),
		}, status.Error(codes.Internal, err.Error())
	}

	return &kvstore.RestoreResponse{
		Success: true,
	}, nil
}

func (s *GRPCServer) Stats(ctx context.Context, req *kvstore.StatsRequest) (*kvstore.StatsResponse, error) {
	s.logger.WithFields(logrus.Fields{
		"operation":       "stats",
		"include_details": req.IncludeDetails,
	}).Debug("Processing stats request")

	stats := s.storage.Stats()

	response := &kvstore.StatsResponse{
		TotalSize: int64(stats["total_size"].(int64)),
		LsmSize:   int64(stats["lsm_size"].(int64)),
		VlogSize:  int64(stats["vlog_size"].(int64)),
	}

	if req.IncludeDetails {
		details := make(map[string]string)
		for key, value := range stats {
			switch v := value.(type) {
			case string:
				details[key] = v
			case int64:
				details[key] = strconv.FormatInt(v, 10)
			case int:
				details[key] = strconv.Itoa(v)
			default:
				details[key] = fmt.Sprintf("%v", v)
			}
		}
		response.Details = details
	}

	return response, nil
}

func (s *GRPCServer) Health(ctx context.Context, req *kvstore.HealthRequest) (*kvstore.HealthResponse, error) {
	return &kvstore.HealthResponse{
		Healthy:       true,
		Status:        "healthy",
		UptimeSeconds: int64(time.Since(time.Now()).Seconds()),
		Version:       "1.0.0",
	}, nil
}

func (s *GRPCServer) Status(ctx context.Context, req *kvstore.StatusRequest) (*kvstore.StatusResponse, error) {
	return &kvstore.StatusResponse{
		NodeId:      s.config.Cluster.NodeID,
		Role:        "standalone",
		State:       "running",
		Peers:       s.config.Cluster.Peers,
		LastApplied: 0,
		CommitIndex: 0,
		LeaderId:    s.config.Cluster.NodeID,
		Metadata: map[string]string{
			"storage_engine": s.config.Storage.Engine,
			"data_path":      s.config.Storage.DataPath,
		},
	}, nil
}